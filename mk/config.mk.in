#								 -*-makefile-*-
# @configure_input@
#
################################################################################
#
# config.mk.in
#
# This file supplies defaults for many tweakable build configuration
# options.  Some of the defaults are filled in by the autoconf-generated
# configure script.
#
# DO NOT EDIT THIS FILE!
#
# 	- config.mk is auto-generated from config.mk.in by configure.
#	  If you edit config.mk your changes will be spammed.
#
#	- Settings in this file may be overriden by giving replacement
#	  definitions in build.mk.  See build.mk.sample for a good
#	  starting point for a build.mk file.
#
#	  If you don't have a build.mk file then you get defaults for everything.
#	  The defaults should provide a reasonable vanilla build.

# TOP: the top of the fptools hierarchy, absolute path.
# On Windows this is a c:/foo/bar style path.
TOP		= @hardtop@

include $(TOP)/mk/project.mk

# By default, be verbose
V = 1

################################################################################
#
#		Global configuration options
#
################################################################################

NO_INCLUDE_DEPS = NO
NO_INCLUDE_PKGDATA = NO

################################################################################
#
# Variables that control how the compiler itself is built
#
################################################################################

# The compiler used to build GHC is $(GHC).  To change the actual compiler
# used, re-configure with --with-ghc=<path-to-ghc>.

# Extra option flags to pass to the compiler that compiles the compiler
# (Ones that are essential are wired into compiler/Makefile)
# Typical options to use here:
#
#	-DDEBUG		include debugging code and assertions (will make the
#			compiler slower and produce debugging output, but useful
#			for development)
#
#	-dcore-lint	check the types after every pass of the compiler;
#			a pretty strong internal check of the compiler being
#			used to compile GHC.  Useful when bootstrapping.
GhcHcOpts=-Rghc-timing

# Extra options added to specific stages of the compiler bootstrap.
# These are placed later on the command line, and may therefore
# override options from $(GhcHcOpts).
#
# See Note [Stage number in build variables].
#
# -haddock is needed so the GHCi :doc command can find docs
#   in the .hi-files for the ghc library
GhcStage1HcOpts=
GhcStage2HcOpts=-O2 -haddock
GhcStage3HcOpts=-O2 -haddock


# Note [Stage number in build variables].
#
# There are (unfortunately) two different naming schemes for build variables
# specific to a certain stage.
#
# * GhcStage1HcOpts/GhcStage2HcOpts/GhcStage3HcOpts:
#
#   The stage number refers to the compiler stage being built (ghc library
#   and executable).
#
# * SRC_HC_OPTS_STAGE$4 and SRC_HC_WARNING_OPTS_STAGE$4:
#
#   The stage number refers to the compiler stage the options are passed to.

GhcDebugged=NO

# GhcProfiled=YES means compile a profiled stage-2 compiler
GhcProfiled=NO

# WITH_TERMINFO can be used to disable terminfo support throughout the compiler
# and its tools. This is handy in the case of cross-compilation, where we may
# not have an ncurses build for the target.
ifeq "$(TargetOS_CPP)" "ios"
# iOS has no terminfo support
WITH_TERMINFO=NO
else ifeq "$(Windows_Target)" "YES"
WITH_TERMINFO=NO
else
WITH_TERMINFO=YES
endif

ifeq "$(findstring $(TargetOS_CPP),linux freebsd dragonfly openbsd netbsd solaris2 kfreebsdgnu haiku linux-android)" ""
TargetElf = NO
else
TargetElf = YES
endif

# Some platforms don't support shared libraries
NoSharedLibsPlatformList = \
	powerpc-ibm-aix \
	x86_64-unknown-mingw32 \
	i386-unknown-mingw32

ifeq "$(SOLARIS_BROKEN_SHLD)" "YES"
NoSharedLibsPlatformList += i386-unknown-solaris2
endif

PlatformSupportsSharedLibs = $(if $(filter $(TARGETPLATFORM),\
    $(NoSharedLibsPlatformList)),NO,YES)

# DYNAMIC_BY_DEFAULT says whether this compiler will default to
# building dynamic executables, i.e. -dynamic is on.  We do this for
# most platforms because it lets us use the system dynamic linker
# instead of our own linker for GHCi.
#
# Currently this isn't possible on Windows, and we have not yet enabled
# it on i386 while we consider the performance implications.
#
ifeq "$(TargetOS_CPP)" "mingw32"
DYNAMIC_BY_DEFAULT = NO
else ifeq "$(TargetArch_CPP)" "i386"
DYNAMIC_BY_DEFAULT = NO
else
DYNAMIC_BY_DEFAULT = YES
endif

# For now, we unconditionally disable dynamic-by-default, as the
# cabal-install's that are in the wild don't handle it properly.
DYNAMIC_BY_DEFAULT = NO

# If building both v and dyn ways, then use -dynamic-too to build them.
# This makes the build faster.
DYNAMIC_TOO = YES

# Use the dynamic way when building programs in the GHC tree. In
# particular, this means that GHCi will use DLLs rather than loading
# object files directly.
ifeq "$(TargetOS_CPP)" "mingw32"
# This doesn't work on Windows yet
DYNAMIC_GHC_PROGRAMS = NO
DYNAMIC_TOO=NO
else ifeq "$(PlatformSupportsSharedLibs)" "NO"
DYNAMIC_GHC_PROGRAMS = NO
else
DYNAMIC_GHC_PROGRAMS = YES
endif

# Build a compiler that will build *unregisterised* libraries and
# binaries by default.  Unregisterised code is supposed to compile and
# run without any support for architecture-specific assembly mangling,
# register assignment or tail-calls, and is therefore a good way to get
# started when porting GHC to new architectures.
#
# NOTE: the stage1 compiler will be a registerised binary (assuming
# the compiler you build with is generating registerised binaries), but
# the stage2 compiler will be an unregisterised binary.
#
GhcUnregisterised=@Unregisterised@

# Build a compiler with a native code generator backend
# (as well as a C backend)
#
# Target platforms supported:
#   i386, powerpc, powerpc64, sparc
#   IOS is not supported
ArchSupportsNCG=$(strip $(patsubst $(TargetArch_CPP), YES, $(findstring $(TargetArch_CPP), i386 x86_64 powerpc powerpc64 powerpc64le sparc)))
OsSupportsNCG=$(strip $(patsubst $(TargetOS_CPP), YES, $(patsubst ios,,$(TargetOS_CPP))))

GhcWithNativeCodeGen := $(strip\
    $(if $(filter YESYESNO,\
		  $(OsSupportsNCG)$(ArchSupportsNCG)$(GhcUnregisterised)),YES,NO))

# ArchSupportsSMP should be set iff there is support for that arch in
# includes/stg/SMP.h
ifeq "$(TargetArch_CPP)" "arm"
# We don't support load/store barriers pre-ARMv7. See #10433.
ArchSupportsSMP=$(if $(filter $(ARM_ISA),ARMv5 ARMv6),NO,YES)
else
ArchSupportsSMP=$(strip $(patsubst $(TargetArch_CPP), YES, $(findstring $(TargetArch_CPP), i386 x86_64 sparc powerpc powerpc64 powerpc64le aarch64)))
endif

# The THREADED_RTS requires `BaseReg` to be in a register and the
# `GhcUnregisterised` mode doesn't allow that.
GhcWithSMP := $(strip $(if $(filter YESNO, $(ArchSupportsSMP)$(GhcUnregisterised)),YES,NO))

# Whether to include GHCi in the compiler.  Depends on whether the RTS linker
# has support for this OS/ARCH combination.

OsSupportsGHCi=$(strip $(patsubst $(TargetOS_CPP), YES, $(findstring $(TargetOS_CPP), mingw32 linux solaris2 freebsd dragonfly netbsd openbsd darwin kfreebsdgnu)))
ArchSupportsGHCi=$(strip $(patsubst $(TargetArch_CPP), YES, $(findstring $(TargetArch_CPP), i386 x86_64 powerpc powerpc64 powerpc64le sparc sparc64 arm aarch64)))

ifeq "$(OsSupportsGHCi)$(ArchSupportsGHCi)" "YESYES"
GhcWithInterpreter=YES
else
GhcWithInterpreter=$(if $(findstring YES,$(DYNAMIC_GHC_PROGRAMS)),YES,NO)
endif

# GhcEnableTablesNextToCode tells us whether the target architecture
# supports placing info tables directly before the entry code
# (see TABLES_NEXT_TO_CODE in the RTS).  Whether we actually compile for
# TABLES_NEXT_TO_CODE depends on whether we're building unregisterised
# code or not, which may be decided by options to the compiler later.
ifneq "$(findstring $(TargetArch_CPP)X, ia64X powerpc64X powerpc64leX)" ""
GhcEnableTablesNextToCode=NO
else
GhcEnableTablesNextToCode=YES
endif

# Whether to use libffi for adjustors (foreign import "wrapper") or
# not.  If we have built-in support (rts/Adjustor.c) then we use that,
# otherwise we fall back on libffi, which is slightly slower.
ArchHasAdjustorSupport = $(if $(findstring $(TargetArch_CPP),i386 x86_64),YES,NO)
ifeq "$(ArchHasAdjustorSupport)" "YES"
UseLibFFIForAdjustors=NO
else
UseLibFFIForAdjustors=YES
endif

# On Windows we normally want to make a relocatable bindist, to we
# ignore flags like libdir
ifeq "$(Windows_Host)" "YES"
RelocatableBuild = YES
else
RelocatableBuild = NO
endif

# needs to be after $(RelocatableBuild) is set above
include $(TOP)/mk/install.mk

# When building bindists we set this to yes so that the binaries are as
# portable as possible.
BeConservative = NO

ExtraMakefileSanityChecks = NO

#------------------------------------------------------------------------------
# Options for Libraries

# Which directory (in libraries/) contains the integer library?
INTEGER_LIBRARY=integer-gmp

# We build the libraries at least the "vanilla" way (way "v")
# Technically we don't need the v way if DYNAMIC_GHC_PROGRAMS is YES,
# but with -dynamic-too it's cheap, and makes life easier.
GhcLibWays = v

# In addition to the normal sequential way, the default is to also build
# profiled prelude libraries
# $(if $(filter ...)) allows controlling this expression from build.mk.
GhcLibWays += $(if $(filter $(BUILD_PROF_LIBS),NO),,p)

# Backward compatibility: although it would be cleaner to test for
# PlatformSupportsSharedLibs, or perhaps a new variable BUILD_SHARED_LIBS,
# some users currently expect that DYNAMIC_GHC_PROGRAMS=NO in build.mk implies
# that dyn is not added to GhcLibWays.
GhcLibWays += $(if $(filter $(DYNAMIC_GHC_PROGRAMS),NO),,dyn)

# Handy way to test whether we're building shared libs or not.
BuildSharedLibs=$(strip $(if $(findstring dyn,$(GhcLibWays)),YES,NO))

# In addition, the RTS is built in some further variations.  Ways that
# make sense here:
#
#   thr           : threaded
#   thr_p         : threaded + profiled + eventlog
#   debug         : debugging + eventlog
#   thr_debug     : debugging + threaded, + eventlog
#   l             : eventlog
#   p             : profiled + eventlog
#   thr_l         : threaded + eventlog
#
# Note how there are a few cases which are handled specially (in packageHsLibs)
# to reduce the number of distinct ways,
#
#   debug     implies  eventlog
#   profiled  implies  eventlog
#
# This means, for instance, that there is no debug_l way.
#
GhcRTSWays=l

# Usually want the debug version
GhcRTSWays += debug

# We always have the threaded versions, but note that SMP support may be disabled
# (see GhcWithSMP).
GhcRTSWays += thr thr_debug thr_l
GhcRTSWays += $(if $(findstring p, $(GhcLibWays)),thr_p,)
GhcRTSWays += $(if $(findstring dyn, $(GhcLibWays)),dyn debug_dyn thr_dyn thr_debug_dyn l_dyn thr_l_dyn,)
GhcRTSWays += $(if $(findstring p, $(GhcLibWays)),thr_debug_p debug_p,)

# We can only build GHCi threaded if we have a threaded RTS:
GhcThreaded = $(if $(findstring thr,$(GhcRTSWays)),YES,NO)

# Option flags to pass to GHC when it's compiling modules in
# fptools/libraries.  Typically these are things like -O or
# -dcore-lint or -H32m.  The ones that are *essential* are wired into
# the build system.
#
# 	-O(2) is pretty desirable, otherwise no inlining of prelude
#		things (incl "+") happens when compiling with this compiler
#
#       -haddock is needed so the GHCi :doc command can find the boot
#               library docs in the respective .hi-files

GhcLibHcOpts=-O2 -haddock

# Strip local symbols from libraries?  This can make the libraries smaller,
# but makes debugging somewhat more difficult.  Doesn't work with all ld's.
#
StripLibraries=NO

# ----------------------------------------------------------------------------
# Object-file splitting
#
# 	Set SplitObjs=YES or NO in your build.mk
#
#	Don't use -split-objs in in GhcLibHcOpts, because the build
#		system needs to do other special magic if you are
#		doing object-file splitting

ArchSupportsSplitObjs=$(if $(filter \
  $(TargetArch_CPP),i386 x86_64 powerpc sparc),YES,NO)#

# We used to support splitting on Darwin, but there is no point, since Darwin
# uses subsections via symbols
OsSupportsSplitObjs=$(if $(filter $(TargetOS_CPP),\
   mingw32 linux solaris2 freebsd dragonfly netbsd openbsd),YES,NO)
SplitObjsBroken = @SplitObjsBroken@

SupportsSplitObjs := $(if $(and $(filter YES,$(ArchSupportsSplitObjs)),\
                                $(filter YES,$(OsSupportsSplitObjs)),\
                                $(filter NO,$(SplitObjsBroken)),\
                                $(filter YES,$(GhcWithNativeCodeGen))),YES,NO)

# By default, enable SplitObjs for the libraries if this build supports it.
# Unless SplitSections is enabled - then let that take precedence.
SplitObjs = $(if $(and $(filter YES,$(SupportsSplitObjs)),\
                       $(filter NO,$(SplitSections))),YES,NO)

# ----------------------------------------------------------------------------
# Section splitting
#
# Similar to -ffunction-sections -fdata-sections in GCC. Provides space saving
# like SplitObjs, but doesn't require post-processing and splitting of object
# files.
#
# Set SplitSections=YES or NO in your build.mk to override the default.
#
# This is not supported on Darwin (where you can use subsections-via-symbols
# instead) and Windows is disabled until we figure the linking performance
# issues related to BFD out. (See #11445, #12913 and related tickets.)
OsSupportsSplitSections=$(if $(filter $(TargetOS_CPP),darwin),NO,YES)
SupportsSplitSections=$(if $(and $(filter YES,$(OsSupportsSplitSections)),\
                                   $(filter YES,$(LdIsGNULd))),YES,NO)
SplitSections ?= $(SupportsSplitSections)

# ----------------------------------------------------------------------------

# There are a number of things which technically depend on GHC (e.g. if
# ghc changes then Haskell files may be compiled differently, or Cabal
# packages may be configured differently). By default we therefore
# have dependencies on the compiler executable.

# However, in practice, having a dependency on GHC is just a pain: We
# normally don't want to spend time recompiling other things while
# we're working on the compiler, and even if we did, GHC will normally
# decide compilation isn't needed anyway. So by setting LAX_DEPENDENCIES
# to YES you can turn these dependencies into order-only dependencies,
# i.e. GHC must exist, but if it's newer than other targets then
# rebuilding is not necessary.

LAX_DEPENDENCIES = NO

# ----------------------------------------------------------------------------
# Options for GHC's RTS

# Build an optimised RTS.  Remember that we need to turn on
# optimisation both for C code (-optc-O2) and .cmm code (-O2).  For
# the debugging RTS flavour, rts/ghc.mk overrides these to turn off
# optimisation.
GhcRtsHcOpts=-O2
GhcRtsCcOpts=-O2 -fomit-frame-pointer -g

# Configuration for libffi
UseSystemLibFFI=@UseSystemLibFFI@
# Flags to go into package.conf for rts
FFILibDir=@FFILibDir@
FFIIncludeDir=@FFIIncludeDir@

# GHC needs arch-specific tweak at least in
#     rts/Libdw.c:set_initial_registers()
GhcRtsWithLibdw=$(strip $(if $(filter $(TargetArch_CPP),i386 x86_64),@UseLibdw@,NO))

################################################################################
#
#		Paths (see paths.mk)
#
################################################################################

BINDIST               = NO
BIN_DIST_NAME         = ghc-$(ProjectVersion)
BIN_DIST_PREP_DIR     = bindistprep/$(BIN_DIST_NAME)
BIN_DIST_PREP_TAR     = bindistprep/$(BIN_DIST_NAME)-$(TARGETPLATFORM).tar
BIN_DIST_PREP_TAR_COMP = $(BIN_DIST_PREP_TAR).$(TAR_COMP_EXT)
BIN_DIST_TAR_COMP     = $(BIN_DIST_NAME)-$(TARGETPLATFORM).tar.$(TAR_COMP_EXT)

# -----------------------------------------------------------------------------
# Utilities programs: flags

# If you want to give any standard flags to pretty much any utility
# (see utils.mk for a complete list), by adding a line here
#
# 	SRC_P_OPTS += ...
#
# where P is the utility. For example, to add -O to all Haskell
# compilations,
#
#	SRC_HC_OPTS += -O


# SRC_HC_OPTS includes flags to be added to *every* Haskell
# compilation.  Setting SRC_HC_OPTS is a good way to set the default
# optimisation level (-O) and heap size (-H<size>).
#
# SRC_HC_OPTS is *not* for adding flags that are required to make your
# build work.  Examples:
#
#  - instead of using -pgmc/-pgma-/-pgml, use the --with-gcc option to configure
#
#  - if you need -optc, -opta, or -optl flags, the CONF_CC_* and CONF_LD_*
#    variables are more appropriate (set via configure)
#
# Note that SRC_HC_OPTS are added to every Haskell compilation,
# including when using the bootstrapping compiler (stage 0), So don't
# put options here that are only supported by very recent GHCs.
#
SRC_HC_OPTS += -H32m -O


# See Note [Stage number in build variables].
SRC_HC_OPTS_STAGE0 =
SRC_HC_OPTS_STAGE1 =
SRC_HC_OPTS_STAGE2 =

# Warning suppression flags. See mk/warnings.mk.
SRC_CC_WARNING_OPTS =
SRC_HC_WARNING_OPTS =

# See Note [Stage number in build variables].
SRC_HC_WARNING_OPTS_STAGE0 =
SRC_HC_WARNING_OPTS_STAGE1 =
SRC_HC_WARNING_OPTS_STAGE2 =

# -----------------------------------------------------------------------------
# Names of programs in the GHC tree

MKDIRHIER           = $(INPLACE_BIN)/mkdirhier

GENERATED_FILE  = chmod a-w
EXECUTABLE_FILE = chmod +x

#-----------------------------------------------------------------------------
# Installed GHC

# $(GHC) points to installed version of the compiler.
#
# NOTE: Don't override $(GHC) in build.mk, use configure --with-ghc instead
# (because the version numbers have to be calculated).

GHC := @WithGhc@
# If we have a make dependency on c:/ghc/ghc, and the file is actually
# called c:/ghc/ghc.exe, then make will think that ghc doesn't exist
# and that it doesn't know how to create it.
ifneq "$(wildcard $(GHC).exe)" ""
GHC := $(GHC).exe
endif

GHC_STAGE0  = $(GHC)
GHC_STAGE1  = $(ghc-stage1_INPLACE)
GHC_STAGE2  = $(ghc-stage2_INPLACE)
GHC_STAGE3  = $(ghc-stage3_INPLACE)

BOOTSTRAPPING_CONF = libraries/bootstrapping.conf

INPLACE_PACKAGE_CONF = $(INPLACE_LIB)/package.conf.d

GhcVersion	= @GhcVersion@
GhcPatchLevel	= @GhcPatchLevel@
GhcMajVersion	= @GhcMajVersion@
GhcMinVersion	= @GhcMinVersion@

# Canonicalised ghc version number, used for easy (integer) version
# comparisons.  We must expand $(GhcMinVersion) to two digits by
# adding a leading zero if necessary:
ifneq "$(findstring $(GhcMinVersion), 0 1 2 3 4 5 6 7 8 9)" ""
GhcCanonVersion = $(GhcMajVersion)0$(GhcMinVersion)
else
GhcCanonVersion = $(GhcMajVersion)$(GhcMinVersion)
endif

GHC_PACKAGE_DB_FLAG = @GHC_PACKAGE_DB_FLAG@

#-----------------------------------------------------------------------------
# C compiler
#
# NB. Don't override $(CC) using build.mk,  re-configure using
# the flag CC=<blah> instead.  The reason is that the configure script
# needs to know which gcc you're using in order to perform its tests.

GccVersion            = @GccVersion@

# TargetPlatformFull retains the string passed to configure so we have it in
# the necessary format to pass to libffi's configure.
TargetPlatformFull    = @TargetPlatformFull@
GccLT46         = @GccLT46@
GccIsClang      = @GccIsClang@

CC              = @CC@
CC_STAGE0       = @CC_STAGE0@
CC_STAGE1       = $(CC)
CC_STAGE2       = $(CC)
CC_STAGE3       = $(CC)

AS              = @CC@
AS_STAGE0       = @CC_STAGE0@
AS_STAGE1       = $(AS)
AS_STAGE2       = $(AS)
AS_STAGE3       = $(AS)

# why no LD=@LD@ ?
LD_STAGE0       = @LD_STAGE0@
LD_STAGE1       = $(LD)
LD_STAGE2       = $(LD)
LD_STAGE3       = $(LD)

# Cross-compiling options
# See Note [CrossCompiling vs Stage1Only]
CrossCompiling        = @CrossCompiling@

# Change this to YES if you're building a cross-compiler and don't
# want to build stage 2.
# See Note [CrossCompiling vs Stage1Only]
# See Note [Stage1Only vs stage=1]
Stage1Only = NO

# Installed tools prefix:
#    we add prefix to crosscompiler GHC only (ghc-stage1),
#    not cross-built GHC (not ghc-stage2).
CrossCompilePrefix    = $(if $(filter YES,$(Stage1Only)),@CrossCompilePrefix@,)

# Install stage 2 by default, or stage 1 in the cross compiler
# case. Can be changed to 3
INSTALL_GHC_STAGE= $(if $(filter YES,$(Stage1Only)),1,2)

# Note [CrossCompiling vs Stage1Only]
#
# There are 4 possible settings:
#
# 1 CrossCompiling=NO Stage1Only=NO
#   The default.
#
# 2 CrossCompiling=NO Stage1Only=YES
#   Don't build ghc-stage2. See Note [Stage1Only vs stage=1].
#
# 3 CrossCompiling=YES Stage1Only=YES
#   Building a cross-compiler (ghc-stage1). See [1] and
#   Note [Stage1Only vs stage=1].
#
# 4 CrossCompiling=YES Stage1Only=NO
#   Cross-compiling GHC itself. See [1].
#
# [1] https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling

# Note [Stage1Only vs stage=1]
#
# Stage1Only=YES means:
#   - don't build ghc-stage2 (the executable)
#   - don't build utils that rely on ghc-stage2
#     See Note [No stage2 packages when CrossCompiling or Stage1Only] in
#     ./ghc.mk.
#   - install ghc-stage1 instead of ghc-stage2
#   - install the ghc-pkg that was built with the stage0 compiler
#   - (*do* still build compiler/stage2 (i.e. the ghc library))
#   - (*do* still build all other libraries)
#
# stage=1 means:
#   - don't build compiler/stage2 (i.e. the ghc library)
#   - don't build ghc-stage2 (the executable)
#   Note: these are the only two things it does. If you want to exclude more
#   stuff, combine it with Stage1Only=YES, or run make in the ghc or compiler
#   directory.
#
# running make in the ghc or compiler directory means:
#   - don't build any packages in the libraries/ directory, except the ones
#     listed in PACKAGES_STAGE0 (i.e. the boot libraries)
#
# You may wonder why Stage1Only=YES still builds compiler/stage2. Quoting
# simonmar in #7639:
#
#     "strictly speaking building compiler/stage2 is correct, because it is
#     the ghc package that can be used with [ghc-stage1]. If you don't
#     want to build it, then setting stage=1 in your mk/build.mk should
#     disable it."

# C compiler and linker flags from configure (e.g. -m<blah> to select
# correct C compiler backend). The stage number is the stage of GHC
# that is being used to compile with.
CONF_CC_OPTS_STAGE0 = @CONF_CC_OPTS_STAGE0@
CONF_CC_OPTS_STAGE1 = @CONF_CC_OPTS_STAGE1@
CONF_CC_OPTS_STAGE2 = @CONF_CC_OPTS_STAGE2@
CONF_GCC_LINKER_OPTS_STAGE0 = @CONF_GCC_LINKER_OPTS_STAGE0@
CONF_GCC_LINKER_OPTS_STAGE1 = @CONF_GCC_LINKER_OPTS_STAGE1@
CONF_GCC_LINKER_OPTS_STAGE2 = @CONF_GCC_LINKER_OPTS_STAGE2@
CONF_LD_LINKER_OPTS_STAGE0 = @CONF_LD_LINKER_OPTS_STAGE0@
CONF_LD_LINKER_OPTS_STAGE1 = @CONF_LD_LINKER_OPTS_STAGE1@
CONF_LD_LINKER_OPTS_STAGE2 = @CONF_LD_LINKER_OPTS_STAGE2@
CONF_CPP_OPTS_STAGE0 = @CONF_CPP_OPTS_STAGE0@
CONF_CPP_OPTS_STAGE1 = @CONF_CPP_OPTS_STAGE1@
CONF_CPP_OPTS_STAGE2 = @CONF_CPP_OPTS_STAGE2@
CONF_HC_OPTS_STAGE0 = @CONF_HC_OPTS_STAGE0@
CONF_HC_OPTS_STAGE1 = @CONF_HC_OPTS_STAGE1@
CONF_HC_OPTS_STAGE2 = @CONF_HC_OPTS_STAGE2@

# The .hsc files aren't currently safe for cross-compilation on Windows:
#     libraries\haskeline\.\System\Console\Haskeline\Backend\Win32.hsc:160
#     directive "let" is not safe for cross-compilation
ifneq "$(Windows_Host)" "YES"
SRC_HSC2HS_OPTS += --cross-safe
endif
SRC_HSC2HS_OPTS += $(foreach d,$(GMP_INCLUDE_DIRS),-I$(d))

define set_stage_HSC2HS_OPTS
# $1 = stage
SRC_HSC2HS_OPTS_STAGE$1 += $$(addprefix --cflag=,$$(filter-out -O,$$(SRC_CC_OPTS) $$(CONF_CC_OPTS_STAGE$1)))
SRC_HSC2HS_OPTS_STAGE$1 += $$(addprefix --cflag=,$$(CONF_CPP_OPTS_STAGE$1))
SRC_HSC2HS_OPTS_STAGE$1 += $$(addprefix --lflag=,$$(CONF_GCC_LINKER_OPTS_STAGE$1))
endef
$(eval $(call set_stage_HSC2HS_OPTS,0))
$(eval $(call set_stage_HSC2HS_OPTS,1))
$(eval $(call set_stage_HSC2HS_OPTS,2))
ifeq "$(CrossCompiling)" "YES"
SRC_HSC2HS_OPTS_STAGE1 += --cross-compile
SRC_HSC2HS_OPTS_STAGE2 += --cross-compile
ifeq "$(Windows_Target)" "YES"
# We'll assume we compile with gcc or clang, and both support `-S` and can as such use the
# --via-asm pass, which should be faster and is required for cross compiling to windows, as
# the c compiler complains about non-constant expressions even though they are constant and
# end up as constants in the assembly.
SRC_HSC2HS_OPTS_STAGE1 += --via-asm
SRC_HSC2HS_OPTS_STAGE2 += --via-asm
endif
endif
SRC_HSC2HS_OPTS_STAGE0 += --cflag=-D$(HostArch_CPP)_HOST_ARCH --cflag=-D$(HostOS_CPP)_HOST_OS
SRC_HSC2HS_OPTS_STAGE1 += --cflag=-D$(TargetArch_CPP)_HOST_ARCH --cflag=-D$(TargetOS_CPP)_HOST_OS
SRC_HSC2HS_OPTS_STAGE2 += --cflag=-D$(TargetArch_CPP)_HOST_ARCH --cflag=-D$(TargetOS_CPP)_HOST_OS

ifeq "$(TARGETPLATFORM)" "i386-unknown-mingw32"
WINDRES = $(INPLACE_MINGW)/bin/windres
else ifeq "$(TARGETPLATFORM)" "x86_64-unknown-mingw32"
WINDRES = $(INPLACE_MINGW)/bin/windres
endif

#-----------------------------------------------------------------------------
# Mingwex Library
#
HaveLibMingwEx	= @HaveLibMingwEx@
ifeq "$(TARGETPLATFORM)" "i386-unknown-mingw32"
DLLTOOL			= inplace/mingw/bin/dlltool.exe
else ifeq "$(TARGETPLATFORM)" "x86_64-unknown-mingw32"
DLLTOOL			= inplace/mingw/bin/dlltool.exe
endif

#-----------------------------------------------------------------------------
# Other standard (ha!) Unix utilities

AR			= @ArCmd@
AR_OPTS			= @ArArgs@
ArSupportsAtFile = @ArSupportsAtFile@

AR_STAGE0 = @AR_STAGE0@
AR_STAGE1 = $(AR)
AR_STAGE2 = $(AR)
AR_STAGE3 = $(AR)
AR_OPTS_STAGE0 = @AR_OPTS_STAGE0@
AR_OPTS_STAGE1 = $(AR_OPTS)
AR_OPTS_STAGE2 = $(AR_OPTS)
AR_OPTS_STAGE3 = $(AR_OPTS)
EXTRA_AR_ARGS_STAGE0 = $(EXTRA_AR_ARGS)
EXTRA_AR_ARGS_STAGE1 = $(EXTRA_AR_ARGS)
EXTRA_AR_ARGS_STAGE2 = $(EXTRA_AR_ARGS)
EXTRA_AR_ARGS_STAGE3 = $(EXTRA_AR_ARGS)
ArSupportsAtFile_STAGE0 = @ArSupportsAtFile_STAGE0@
ArSupportsAtFile_STAGE1 = $(ArSupportsAtFile)
ArSupportsAtFile_STAGE2 = $(ArSupportsAtFile)
ArSupportsAtFile_STAGE3 = $(ArSupportsAtFile)

CONTEXT_DIFF		= @ContextDiffCmd@
CP			= cp

# It's not easy to separate the CPP program from its flags, as
# AC_PROG_CPP defines CPP as "/usr/bin/gcc -E"
CPP			= @CPP@ @CPPFLAGS@
HS_CPP			= @HaskellCPPCmd@ @HaskellCPPArgs@

FIND			= @FindCmd@

#
# Sigh - the autoconf macro for INSTALL will subst a relative path to the fallback
# install-sh script (if chosen). This not terribly useful to us, so we convert
# it into an abs. path.
#
INSTALL			= @INSTALL@
INSTALL			:= $(subst .././install-sh,$(TOP)/install-sh,$(INSTALL))

LN_S			= @LN_S@
MV			= mv
PERL 			= @PerlCmd@
PIC			= pic
RANLIB_CMD = @RANLIB_CMD@
REAL_RANLIB_CMD = @REAL_RANLIB_CMD@
SED			= @SedCmd@
SHELL			= @SHELL@

HaveDtrace		= @HaveDtrace@
USE_DTRACE = $(HaveDtrace)
DTRACE			= @DtraceCmd@

LD_NO_GOLD = @LdNoGoldCmd@
LD = @LdCmd@
NM = @NmCmd@
AR = @ArCmd@
OBJDUMP = @ObjdumpCmd@

CLANG = @ClangCmd@
LLC = @LlcCmd@
OPT = @OptCmd@

# GNU ld supports input via a linker script, which is useful to avoid
# overflowing command-line length limits.
LdIsGNULd		= @LdIsGNULd@

# Set to YES if ld has the --build-id flag.  Sometimes we need to
# disable it with --build-id=none.
LdHasBuildId	        = @LdHasBuildId@

# Set to YES if ld has the --no_compact_unwind flag. See #5019
# and compiler/main/DriverPipeline.hs.
LdHasNoCompactUnwind	= @LdHasNoCompactUnwind@

# On MSYS, building with SplitObjs=YES fails with
#   ar: Bad file number
# see #3201.  We need to specify a smaller max command-line size
# to work around it.  32767 doesn't work; 30000 does, but says
#     xargs: value for -s option should be < 28153
# so we now use 20000 to be comfortably below this bound
XARGS = xargs
ifeq "$(Windows_Host)" "YES"
XARGS_OPTS = -s 20000
endif

ifeq "$(TARGETPLATFORM)" "x86_64-unknown-mingw32"
STRIP_CMD      = $(TOP)/inplace/mingw/bin/strip.exe
else ifeq "$(TARGETPLATFORM)" "arm-unknown-linux"
# The Cortex A8 hardware apparently has a bug which ld.gold will check for;
# however in order to do so it must have unstripped executables lest we
# see warnings of the form (see #10376, #10464),
#
#     /usr/bin/ld.gold: warning: cannot scan executable section 1 of ... for
#     Cortex-A8 erratum because it has no mapping symbols.
#
# Consequently we disabling stripping by default on this architecture.
# The hack of using `:` to disable stripping is implemented by ghc-cabal.
STRIP_CMD      = :
else
STRIP_CMD      = @StripCmd@
endif
PATCH_CMD      = @PatchCmd@
TAR_CMD        = @TarCmd@
BZIP2_CMD      = @Bzip2Cmd@
GZIP_CMD       = @GzipCmd@
XZ_CMD         = @XzCmd@

# xz is default compression
TAR_COMP      ?= xz

# select compression command and .tar extension based on TAR_COMP value
ifeq "$(TAR_COMP)" "bzip2"
TAR_COMP_CMD  = $(BZIP2_CMD) $(TAR_COMP_OPTS)
TAR_COMP_EXT  = bz2
else ifeq "$(TAR_COMP)" "gzip"
TAR_COMP_CMD  = $(GZIP_CMD) $(TAR_COMP_OPTS)
TAR_COMP_EXT  = gz
else ifeq "$(TAR_COMP)" "xz"
TAR_COMP_CMD  = $(XZ_CMD) $(TAR_COMP_OPTS)
TAR_COMP_EXT  = xz
else
$(error $$(TAR_COMP) set to unknown value "$(TAR_COMP)" (supported: "bzip2", "gzip", "xz"))
endif

ifeq "$(Windows_Host)" "YES"
TOUCH_CMD      = $(utils/touchy_dist_INPLACE)
TOUCH_DEP      = $(TOUCH_CMD)
else
TOUCH_CMD      = touch
TOUCH_DEP      =
endif

HSCOLOUR_CMD   = @HSCOLOUR@

TIME_CMD       = @TimeCmd@

#-----------------------------------------------------------------------------
# Sphinx stuff

SPHINXBUILD              = @SPHINXBUILD@
BUILD_MAN                = @BUILD_MAN@
BUILD_SPHINX_HTML        = @BUILD_SPHINX_HTML@
BUILD_SPHINX_PDF         = @BUILD_SPHINX_PDF@
SPHINXOPTS               = -D latex_paper_size=letter
XELATEX                  = @XELATEX@

#-----------------------------------------------------------------------------
# 		FPtools support software

#
# ghc-pkg
#
GHC_PKG		        = @GhcPkgCmd@

#
# Happy
#
HAPPY			= @HappyCmd@
HAPPY_VERSION		= @HappyVersion@
#
# Options to pass to Happy when we're going to compile the output with GHC
#
SRC_HAPPY_OPTS		= -agc --strict

#
# Alex
#
ALEX			= @AlexCmd@
ALEX_VERSION		= @AlexVersion@
#
# Options to pass to Alex when we're going to compile the output with GHC
#
SRC_ALEX_OPTS = -g
# The compiler isn't using the Unicode support in Alex 3.0 yet, in fact we do our own
# Unicode handling, so diable Alex's.
compiler_ALEX_OPTS = --latin1

# Should we build haddock docs?
HADDOCK_DOCS = YES
# And HsColour the sources?
ifeq "$(HSCOLOUR_CMD)" ""
HSCOLOUR_SRCS = NO
else
HSCOLOUR_SRCS = YES
endif

# Build and install the "extra" packages (see ./packages)?
BUILD_EXTRA_PKGS = NO

################################################################################
#
#    Library configure arguments
#
################################################################################

CONFIGURE_ARGS = @CONFIGURE_ARGS@

################################################################################
#
#    To be passed to sub-builds
#
################################################################################

ICONV_INCLUDE_DIRS = @ICONV_INCLUDE_DIRS@
ICONV_LIB_DIRS = @ICONV_LIB_DIRS@

GMP_INCLUDE_DIRS = @GMP_INCLUDE_DIRS@
GMP_LIB_DIRS = @GMP_LIB_DIRS@

CURSES_LIB_DIRS = @CURSES_LIB_DIRS@

# See Note [Disable -O2 in unregisterised mode]
# Be careful: 'GhcUnregisterised' should be defined earlier in this file.
ifeq "$(GhcUnregisterised)" "YES"
GhcStage1HcOpts=
GhcStage2HcOpts=
GhcStage3HcOpts=

GhcLibHcOpts=
endif

# Note [Disable -O2 in unregisterised mode]
# Disable -O2 optimization in unregisterised mode. Otherwise amount
# of generated C code # makes things very slow to compile (~5 minutes
# on core-i7 for 'compiler/hsSyn/HsExpr.hs') and sometimes not compile
# at all: powerpc64 overflows TOC section on 'compiler/hsSyn/HsExpr.hs'
#         ia64 overflows short data section on 'compiler/main/DynFlags.hs'
