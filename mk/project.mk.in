# WARNING: mk/project.mk is automatically generated from mk/project.mk.in by
# ./configure.  Make sure you are editing mk/project.mk.in, not mk/project.mk.

################################################################################
#
# GHC Version
#

# ProjectVersion    is treated as a *string*
# ProjectVersionInt is treated as an *integer* (for cpp defines)

# Versioning scheme: A.B.C
#         A: major version, decimal, any number of digits
#         B: minor version, decimal, any number of digits
#	  C: patchlevel, one digit, omitted if zero.
#
# ProjectVersionInt does *not* contain the patchlevel (rationale: this
# figure is used for conditional compilations, and library interfaces
# etc. are not supposed to change between patchlevels).
#
# The ProjectVersionInt is included in interface files, and GHC
# checks that it's reading interface generated by the same ProjectVersion
# as itself. It does this even though interface file syntax may not 
# change between versions.  Rationale: calling conventions or other 
# random .o-file stuff might change even if the .hi syntax doesn't

ProjectName       = @ProjectName@
ProjectTags       =
ProjectVersion    = @ProjectVersion@$(ProjectTags)
ProjectVersionInt = @ProjectVersionInt@
ProjectPatchLevel = @ProjectPatchLevel@

################################################################################
#
#		Platform variables
#
################################################################################

# A "platform" is the GNU cpu-type/manufacturer/operating-system target machine
# specifier.  E.g. sparc-sun-solaris2
#
# Build  platform: the platform on which we are doing this build
# Host   platform: the platform on which these binaries will run
# Target platform: the platform for which this compiler will generate code
#
# We don't support build & host being different, because the build
# process creates binaries that are run during the build, and also
# installed.
#
# If host & target are different, then we are building a compiler
# which will generate intermediate .hc files to port to the target
# architecture for bootstrapping.  The libraries and stage 2 compiler
# will be built as HC files for the target system, and likely won't
# build on this host platform.
#
# An important invariant is that for any piece of source code, the
# platform on which the code is going to run is the HOST platform,
# and the platform on which we are building is the BUILD platform.
# Additionally for the compiler, the platform this compiler will
# generate code for is the TARGET.  TARGET is not meaningful outside
# the compiler sources.
#
# Guidelines for when to use HOST vs. TARGET:
#
#  - In the build system (Makefile, foo.mk), normally we should test
#    $(HOSTPLATFORM).  There are some cases (eg. installation), where
#    we expect $(HOSTPLATFORM)==$(TARGETPLATFORM), so in those cases it
#    doesn't matter which is used.
#
#  - In the compiler itself, we should test HOST or TARGET depending
#    on whether the conditional relates to the code being generated, or
#    the platform on which the compiler is running.  See the section
#    on "Coding Style" in the commentary for more details.
#
#  - In all other code, we should be testing HOST only.
#
# NOTE: cross-compiling is not well supported by the build system.
# You have to do a lot of work by hand to cross compile: see the
# section on "Porting GHC" in the Building Guide.

HOSTPLATFORM			= @HostPlatform@
TARGETPLATFORM			= @TargetPlatform@
BUILDPLATFORM			= @BuildPlatform@

HostPlatform_CPP		= @HostPlatform_CPP@
HostArch_CPP			= @HostArch_CPP@
HostOS_CPP			= @HostOS_CPP@
HostVendor_CPP	                = @HostVendor_CPP@

TargetPlatform_CPP		= @TargetPlatform_CPP@
TargetArch_CPP			= @TargetArch_CPP@
TargetOS_CPP			= @TargetOS_CPP@
TargetVendor_CPP                = @TargetVendor_CPP@

BuildPlatform_CPP		= @BuildPlatform_CPP@
BuildArch_CPP			= @BuildArch_CPP@
BuildOS_CPP			= @BuildOS_CPP@
BuildVendor_CPP                 = @BuildVendor_CPP@

@HostPlatform_CPP@_HOST           = 1
@TargetPlatform_CPP@_TARGET       = 1
@BuildPlatform_CPP@_BUILD         = 1

@HostArch_CPP@_HOST_ARCH          = 1
@TargetArch_CPP@_TARGET_ARCH      = 1
@BuildArch_CPP@_BUILD_ARCH        = 1

@HostOS_CPP@_HOST_OS              = 1
@TargetOS_CPP@_TARGET_OS          = 1
@BuildOS_CPP@_BUILD_OS            = 1

@HostVendor_CPP@_HOST_VENDOR      = 1
@TargetVendor_CPP@_TARGET_VENDOR  = 1
@BuildVendor_CPP@_BUILD_VENDOR    = 1

################################################################################
#
#		Global configuration options
#
################################################################################

# Leading underscores on symbol names in object files
# Valid options: YES/NO
#
LeadingUnderscore=@LeadingUnderscore@

# Pin a suffix on executables? If so, what (Windows only).
exeext0=@exeext@
exeext1=@exeext@
exeext2=@exeext@
exeext3=@exeext@
soext=@soext@

# Windows_Host=YES if on a Windows platform
ifneq "$(findstring $(HostOS_CPP), mingw32 cygwin32)" ""
Windows_Host=YES
else
Windows_Host=NO
endif

# Windows_Target=YES if we are targetting a Windows platform
ifneq "$(findstring $(TargetOS_CPP), mingw32 cygwin32)" ""
Windows_Target=YES
else
Windows_Target=NO
endif

# Tell the build system what the host operating system is
# This distinguishes "msys" and "cygwin", which are not
# not distinguished by HOST_OS_CPP
OSTYPE=@OSTYPE@

# In case of Solaris OS, does it provide broken shared libs
# linker or not?
SOLARIS_BROKEN_SHLD=@SOLARIS_BROKEN_SHLD@

# Do we have a C compiler using an LLVM back end?
CC_LLVM_BACKEND = @CC_LLVM_BACKEND@
