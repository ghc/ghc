<para>
<indexterm><primary>language, GHC</primary></indexterm>
<indexterm><primary>extensions, GHC</primary></indexterm>
As with all known Haskell systems, GHC implements some extensions to
the language.  To use them, you'll need to give a <option>-fglasgow-exts</option>
<indexterm><primary>-fglasgow-exts option</primary></indexterm> option.
</para>

<para>
Virtually all of the Glasgow extensions serve to give you access to
the underlying facilities with which we implement Haskell.  Thus, you
can get at the Raw Iron, if you are willing to write some non-standard
code at a more primitive level.  You need not be &ldquo;stuck&rdquo; on
performance because of the implementation costs of Haskell's
&ldquo;high-level&rdquo; features&mdash;you can always code &ldquo;under&rdquo; them.  In an extreme case, you can write all your time-critical code in C, and then just glue it together with Haskell!
</para>

<para>
Executive summary of our extensions:
</para>

  <variablelist>

    <varlistentry>
      <term>Unboxed types and primitive operations:</Term>
      <listitem>
	<para>You can get right down to the raw machine types and
        operations; included in this are &ldquo;primitive
        arrays&rdquo; (direct access to Big Wads of Bytes).  Please
        see <XRef LinkEnd="glasgow-unboxed"> and following.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Type system extensions:</term>
      <listitem>
	<para> GHC supports a large number of extensions to Haskell's
        type system.  Specifically:</para>

	<variablelist>
	  <varlistentry>
	    <term>Class method types:</term>
	    <listitem>
	      <para><xref LinkEnd="classs-method-types"></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Multi-parameter type classes:</term>
	    <listitem>
	      <para><xref LinkEnd="multi-param-type-classes"></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Functional dependencies:</term>
	    <listitem>
	      <para><xref LinkEnd="functional-dependencies"></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Implicit parameters:</term>
	    <listitem>
	      <para><xref LinkEnd="implicit-parameters"></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Linear implicit parameters:</term>
	    <listitem>
	      <para><xref LinkEnd="linear-implicit-parameters"></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Local universal quantification:</term>
	    <listitem>
	      <para><xref LinkEnd="universal-quantification"></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Extistentially quantification in data types:</term>
	    <listitem>
	      <para><xref LinkEnd="existential-quantification"></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Scoped type variables:</term>
	    <listitem>
	      <para>Scoped type variables enable the programmer to
              supply type signatures for some nested declarations,
              where this would not be legal in Haskell 98.  Details in
              <xref LinkEnd="scoped-type-variables">.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Pattern guards</term>
      <listitem>
	<para>Instead of being a boolean expression, a guard is a list
	of qualifiers, exactly as in a list comprehension. See <xref
	LinkEnd="pattern-guards">.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Data types with no constructors</term>
      <listitem>
	<para>See <xref LinkEnd="nullary-types">.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Parallel list comprehensions</term>
      <listitem>
	<para>An extension to the list comprehension syntax to support
	<literal>zipWith</literal>-like functionality.  See <xref
	linkend="parallel-list-comprehensions">.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Foreign calling:</term>
      <listitem>
	<para>Just what it sounds like.  We provide
        <emphasis>lots</emphasis> of rope that you can dangle around
        your neck.  Please see <xref LinkEnd="ffi">.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Pragmas</term>
      <listitem>
	<para>Pragmas are special instructions to the compiler placed
        in the source file.  The pragmas GHC supports are described in
        <xref LinkEnd="pragmas">.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Rewrite rules:</term>
      <listitem>
	<para>The programmer can specify rewrite rules as part of the
        source program (in a pragma).  GHC applies these rewrite rules
        wherever it can.  Details in <xref
        LinkEnd="rewrite-rules">.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Generic classes:</term>
      <listitem>
	<para>(Note: support for generic classes is currently broken
        in GHC 5.02).</para>

	<para>Generic class declarations allow you to define a class
        whose methods say how to work over an arbitrary data type.
        Then it's really easy to make any new type into an instance of
        the class.  This generalises the rather ad-hoc "deriving"
        feature of Haskell 98.  Details in <xref
        LinkEnd="generic-classes">.</para>
      </listitem>
    </varlistentry>
  </variablelist>

<para>
Before you get too carried away working at the lowest level (e.g.,
sloshing <literal>MutableByteArray&num;</literal>s around your
program), you may wish to check if there are libraries that provide a
&ldquo;Haskellised veneer&rdquo; over the features you want.  See
<xref linkend="book-hslibs">.
</para>

  <sect1 id="options-language">
    <title>Language options</title>

    <indexterm><primary>language</primary><secondary>option</secondary>
    </indexterm>
    <indexterm><primary>options</primary><secondary>language</secondary>
    </indexterm>
    <indexterm><primary>extensions</primary><secondary>options controlling</secondary>
    </indexterm>

    <para> These flags control what variation of the language are
    permitted.  Leaving out all of them gives you standard Haskell
    98.</para>

    <variablelist>

      <varlistentry>
	<term><option>-fglasgow-exts</option>:</term>
	<indexterm><primary><option>-fglasgow-exts</option></primary></indexterm>
	<listitem>
	  <para>This simultaneously enables all of the extensions to
          Haskell 98 described in <xref
          linkend="ghc-language-features">, except where otherwise
          noted. </para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fno-monomorphism-restriction</option>:</term>
	<indexterm><primary><option>-fno-monomorphism-restriction</option></primary></indexterm>
	<listitem>
	  <para> Switch off the Haskell 98 monomorphism restriction.
          Independent of the <option>-fglasgow-exts</option>
          flag. </para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fallow-overlapping-instances</option></term>
	<term><option>-fallow-undecidable-instances</option></term>
	<term><option>-fallow-incoherent-instances</option></term>
	<term><option>-fcontext-stack</option></term>
	<indexterm><primary><option>-fallow-overlapping-instances</option></primary></indexterm>
	<indexterm><primary><option>-fallow-undecidable-instances</option></primary></indexterm>
	<indexterm><primary><option>-fcontext-stack</option></primary></indexterm>
	<listitem>
	  <para> See <xref LinkEnd="instance-decls">.  Only relevant
          if you also use <option>-fglasgow-exts</option>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-finline-phase</option></term>
	<indexterm><primary><option>-finline-phase</option></primary></indexterm>
	<listitem>
	  <para>See <xref LinkEnd="rewrite-rules">.  Only relevant if
          you also use <option>-fglasgow-exts</option>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fgenerics</option></term>
	<indexterm><primary><option>-fgenerics</option></primary></indexterm>
	<listitem>
	  <para>See <xref LinkEnd="generic-classes">.  Independent of
          <option>-fglasgow-exts</option>.</para>
	</listitem>
      </varlistentry>

	<varlistentry>
	  <term><option>-fno-implicit-prelude</option></term>
	  <listitem>
	    <para><indexterm><primary>-fno-implicit-prelude
            option</primary></indexterm> GHC normally imports
            <filename>Prelude.hi</filename> files for you.  If you'd
            rather it didn't, then give it a
            <option>-fno-implicit-prelude</option> option.  The idea
            is that you can then import a Prelude of your own.  (But
            don't call it <literal>Prelude</literal>; the Haskell
            module namespace is flat, and you must not conflict with
            any Prelude module.)</para>

	    <para>Even though you have not imported the Prelude, all
            the built-in syntax still refers to the built-in Haskell
            Prelude types and values, as specified by the Haskell
            Report.  For example, the type <literal>[Int]</literal>
            still means <literal>Prelude.[] Int</literal>; tuples
            continue to refer to the standard Prelude tuples; the
            translation for list comprehensions continues to use
            <literal>Prelude.map</literal> etc.</para>

	    <para> With one group of exceptions!  You may want to
            define your own numeric class hierarchy.  It completely
            defeats that purpose if the literal "1" means
            "<literal>Prelude.fromInteger 1</literal>", which is what
            the Haskell Report specifies.  So the
            <option>-fno-implicit-prelude</option> flag causes the
            following pieces of built-in syntax to refer to <emphasis>whatever
            is in scope</emphasis>, not the Prelude versions:</para>

	    <itemizedlist>
	      <listitem>
		<para>Integer and fractional literals mean
                "<literal>fromInteger 1</literal>" and
                "<literal>fromRational 3.2</literal>", not the
                Prelude-qualified versions; both in expressions and in
                patterns.</para>
	      </listitem>

	      <listitem>
		<para>Negation (e.g. "<literal>- (f x)</literal>")
		means "<literal>negate (f x)</literal>" (not
		<literal>Prelude.negate</literal>).</para>
	      </listitem>

	      <listitem>
		<para>In an n+k pattern, the standard Prelude
                <literal>Ord</literal> class is still used for comparison,
                but the necessary subtraction uses whatever
                "<literal>(-)</literal>" is in scope (not
                "<literal>Prelude.(-)</literal>").</para>
	      </listitem>
	    </itemizedlist>

	     <para>Note: Negative literals, such as <literal>-3</literal>, are
             specified by (a careful reading of) the Haskell Report as 
             meaning <literal>Prelude.negate (Prelude.fromInteger 3)</literal>.
             However, GHC deviates from this slightly, and treats them as meaning
             <literal>fromInteger (-3)</literal>.  One particular effect of this
             slightly-non-standard reading is that there is no difficulty with
             the literal <literal>-2147483648</literal> at type <literal>Int</literal>;
             it means <literal>fromInteger (-2147483648)</literal>.  The strict interpretation
             would be <literal>negate (fromInteger 2147483648)</literal>,
             and the call to <literal>fromInteger</literal> would overflow
             (at type <literal>Int</literal>, remember).
             </para>

	  </listitem>
	</varlistentry>

    </variablelist>
  </sect1>

<!-- UNBOXED TYPES AND PRIMITIVE OPERATIONS -->
&primitives;

<sect1 id="glasgow-ST-monad">
<title>Primitive state-transformer monad</title>

<para>
<indexterm><primary>state transformers (Glasgow extensions)</primary></indexterm>
<indexterm><primary>ST monad (Glasgow extension)</primary></indexterm>
</para>

<para>
This monad underlies our implementation of arrays, mutable and
immutable, and our implementation of I/O, including &ldquo;C calls&rdquo;.
</para>

<para>
The <literal>ST</literal> library, which provides access to the
<function>ST</function> monad, is described in <xref
linkend="sec-ST">.
</para>

</sect1>

<sect1 id="glasgow-prim-arrays">
<title>Primitive arrays, mutable and otherwise
</title>

<para>
<indexterm><primary>primitive arrays (Glasgow extension)</primary></indexterm>
<indexterm><primary>arrays, primitive (Glasgow extension)</primary></indexterm>
</para>

<para>
GHC knows about quite a few flavours of Large Swathes of Bytes.
</para>

<para>
First, GHC distinguishes between primitive arrays of (boxed) Haskell
objects (type <literal>Array&num; obj</literal>) and primitive arrays of bytes (type
<literal>ByteArray&num;</literal>).
</para>

<para>
Second, it distinguishes between&hellip;
<variablelist>

<varlistentry>
<term>Immutable:</term>
<listitem>
<para>
Arrays that do not change (as with &ldquo;standard&rdquo; Haskell arrays); you
can only read from them.  Obviously, they do not need the care and
attention of the state-transformer monad.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Mutable:</term>
<listitem>
<para>
Arrays that may be changed or &ldquo;mutated.&rdquo;  All the operations on them
live within the state-transformer monad and the updates happen
<emphasis>in-place</emphasis>.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>&ldquo;Static&rdquo; (in C land):</term>
<listitem>
<para>
A C routine may pass an <literal>Addr&num;</literal> pointer back into Haskell land.  There
are then primitive operations with which you may merrily grab values
over in C land, by indexing off the &ldquo;static&rdquo; pointer.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>&ldquo;Stable&rdquo; pointers:</term>
<listitem>
<para>
If, for some reason, you wish to hand a Haskell pointer (i.e.,
<emphasis>not</emphasis> an unboxed value) to a C routine, you first make the
pointer &ldquo;stable,&rdquo; so that the garbage collector won't forget that it
exists.  That is, GHC provides a safe way to pass Haskell pointers to
C.
</para>

<para>
Please see <xref LinkEnd="sec-stable-pointers"> for more details.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>&ldquo;Foreign objects&rdquo;:</term>
<listitem>
<para>
A &ldquo;foreign object&rdquo; is a safe way to pass an external object (a
C-allocated pointer, say) to Haskell and have Haskell do the Right
Thing when it no longer references the object.  So, for example, C
could pass a large bitmap over to Haskell and say &ldquo;please free this
memory when you're done with it.&rdquo;
</para>

<para>
Please see <xref LinkEnd="sec-ForeignObj"> for more details.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

<para>
The libraries documentatation gives more details on all these
&ldquo;primitive array&rdquo; types and the operations on them.
</para>

</sect1>


<sect1 id="nullary-types">
<title>Data types with no constructors</title>

<para>With the <option>-fglasgow-exts</option> flag, GHC lets you declare
a data type with no constructors.  For example:</para>
<programlisting>
  data S      -- S :: *
  data T a    -- T :: * -> *
</programlisting>
<para>Syntactically, the declaration lacks the "= constrs" part.  The 
type can be parameterised, but only over ordinary types, of kind *; since
Haskell does not have kind signatures, you cannot parameterise over higher-kinded
types.</para>

<para>Such data types have only one value, namely bottom.
Nevertheless, they can be useful when defining "phantom types".</para>
</sect1>

<sect1 id="pattern-guards">
<title>Pattern guards</title>

<para>
<indexterm><primary>Pattern guards (Glasgow extension)</primary></indexterm>
The discussion that follows is an abbreviated version of Simon Peyton Jones's original <ULink URL="http://research.microsoft.com/~simonpj/Haskell/guards.html">proposal</ULink>. (Note that the proposal was written before pattern guards were implemented, so refers to them as unimplemented.)
</para>

<para>
Suppose we have an abstract data type of finite maps, with a
lookup operation:

<programlisting>
lookup :: FiniteMap -> Int -> Maybe Int
</programlisting>

The lookup returns <function>Nothing</function> if the supplied key is not in the domain of the mapping, and <function>(Just v)</function> otherwise,
where <VarName>v</VarName> is the value that the key maps to.  Now consider the following definition:
</para>

<programlisting>
clunky env var1 var2 | ok1 && ok2 = val1 + val2
| otherwise  = var1 + var2
where
  m1 = lookup env var1
  m2 = lookup env var2
  ok1 = maybeToBool m1
  ok2 = maybeToBool m2
  val1 = expectJust m1
  val2 = expectJust m2
</programlisting>

<para>
The auxiliary functions are 
</para>

<programlisting>
maybeToBool :: Maybe a -&gt; Bool
maybeToBool (Just x) = True
maybeToBool Nothing  = False

expectJust :: Maybe a -&gt; a
expectJust (Just x) = x
expectJust Nothing  = error "Unexpected Nothing"
</programlisting>

<para>
What is <function>clunky</function> doing? The guard <literal>ok1 &&
ok2</literal> checks that both lookups succeed, using
<function>maybeToBool</function> to convert the <function>Maybe</function>
types to booleans. The (lazily evaluated) <function>expectJust</function>
calls extract the values from the results of the lookups, and binds the
returned values to <VarName>val1</VarName> and <VarName>val2</VarName>
respectively.  If either lookup fails, then clunky takes the
<literal>otherwise</literal> case and returns the sum of its arguments.
</para>

<para>
This is certainly legal Haskell, but it is a tremendously verbose and
un-obvious way to achieve the desired effect.  Arguably, a more direct way
to write clunky would be to use case expressions:
</para>

<programlisting>
clunky env var1 var1 = case lookup env var1 of
  Nothing -&gt; fail
  Just val1 -&gt; case lookup env var2 of
    Nothing -&gt; fail
    Just val2 -&gt; val1 + val2
where
  fail = val1 + val2
</programlisting>

<para>
This is a bit shorter, but hardly better.  Of course, we can rewrite any set
of pattern-matching, guarded equations as case expressions; that is
precisely what the compiler does when compiling equations! The reason that
Haskell provides guarded equations is because they allow us to write down
the cases we want to consider, one at a time, independently of each other. 
This structure is hidden in the case version.  Two of the right-hand sides
are really the same (<function>fail</function>), and the whole expression
tends to become more and more indented. 
</para>

<para>
Here is how I would write clunky:
</para>

<programlisting>
clunky env var1 var1
  | Just val1 &lt;- lookup env var1
  , Just val2 &lt;- lookup env var2
  = val1 + val2
...other equations for clunky...
</programlisting>

<para>
The semantics should be clear enough.  The qualifers are matched in order. 
For a <literal>&lt;-</literal> qualifier, which I call a pattern guard, the
right hand side is evaluated and matched against the pattern on the left. 
If the match fails then the whole guard fails and the next equation is
tried.  If it succeeds, then the appropriate binding takes place, and the
next qualifier is matched, in the augmented environment.  Unlike list
comprehensions, however, the type of the expression to the right of the
<literal>&lt;-</literal> is the same as the type of the pattern to its
left.  The bindings introduced by pattern guards scope over all the
remaining guard qualifiers, and over the right hand side of the equation.
</para>

<para>
Just as with list comprehensions, boolean expressions can be freely mixed
with among the pattern guards.  For example:
</para>

<programlisting>
f x | [y] <- x
    , y > 3
    , Just z <- h y
    = ...
</programlisting>

<para>
Haskell's current guards therefore emerge as a special case, in which the
qualifier list has just one element, a boolean expression.
</para>
</sect1>

  <sect1 id="parallel-list-comprehensions">
    <title>Parallel List Comprehensions</title>
    <indexterm><primary>list comprehensions</primary><secondary>parallel</secondary>
    </indexterm>
    <indexterm><primary>parallel list comprehensions</primary>
    </indexterm>

    <para>Parallel list comprehensions are a natural extension to list
    comprehensions.  List comprehensions can be thought of as a nice
    syntax for writing maps and filters.  Parallel comprehensions
    extend this to include the zipWith family.</para>

    <para>A parallel list comprehension has multiple independent
    branches of qualifier lists, each separated by a `|' symbol.  For
    example, the following zips together two lists:</para>

<programlisting>
   [ (x, y) | x <- xs | y <- ys ] 
</programlisting>

    <para>The behavior of parallel list comprehensions follows that of
    zip, in that the resulting list will have the same length as the
    shortest branch.</para>

    <para>We can define parallel list comprehensions by translation to
    regular comprehensions.  Here's the basic idea:</para>

    <para>Given a parallel comprehension of the form: </para>

<programlisting>
   [ e | p1 <- e11, p2 <- e12, ... 
       | q1 <- e21, q2 <- e22, ... 
       ... 
   ] 
</programlisting>

    <para>This will be translated to: </para>

<programlisting>
   [ e | ((p1,p2), (q1,q2), ...) <- zipN [(p1,p2) | p1 <- e11, p2 <- e12, ...] 
                                         [(q1,q2) | q1 <- e21, q2 <- e22, ...] 
                                         ... 
   ] 
</programlisting>

    <para>where `zipN' is the appropriate zip for the given number of
    branches.</para>

  </sect1>

<sect1 id="class-method-types">
<title>Class method types
</title>
<para>
Haskell 98 prohibits class method types to mention constraints on the
class type variable, thus:
<programlisting>
  class Seq s a where
    fromList :: [a] -> s a
    elem     :: Eq a => a -> s a -> Bool
</programlisting>
The type of <literal>elem</literal> is illegal in Haskell 98, because it
contains the constraint <literal>Eq a</literal>, constrains only the 
class type variable (in this case <literal>a</literal>).
</para>
<para>
With the <option>-fglasgow-exts</option> GHC lifts this restriction.
</para>

</sect1>

<sect1 id="multi-param-type-classes">
<title>Multi-parameter type classes
</title>

<para>
This section documents GHC's implementation of multi-parameter type
classes.  There's lots of background in the paper <ULink
URL="http://research.microsoft.com/~simonpj/multi.ps.gz" >Type
classes: exploring the design space</ULink > (Simon Peyton Jones, Mark
Jones, Erik Meijer).
</para>

<para>
I'd like to thank people who reported shorcomings in the GHC 3.02
implementation.  Our default decisions were all conservative ones, and
the experience of these heroic pioneers has given useful concrete
examples to support several generalisations.  (These appear below as
design choices not implemented in 3.02.)
</para>

<para>
I've discussed these notes with Mark Jones, and I believe that Hugs
will migrate towards the same design choices as I outline here.
Thanks to him, and to many others who have offered very useful
feedback.
</para>

<sect2>
<title>Types</title>

<para>
There are the following restrictions on the form of a qualified
type:
</para>

<para>

<programlisting>
  forall tv1..tvn (c1, ...,cn) => type
</programlisting>

</para>

<para>
(Here, I write the "foralls" explicitly, although the Haskell source
language omits them; in Haskell 1.4, all the free type variables of an
explicit source-language type signature are universally quantified,
except for the class type variables in a class declaration.  However,
in GHC, you can give the foralls if you want.  See <xref LinkEnd="universal-quantification">).
</para>

<para>

<OrderedList>
<listitem>

<para>
 <emphasis>Each universally quantified type variable
<literal>tvi</literal> must be mentioned (i.e. appear free) in <literal>type</literal></emphasis>.

The reason for this is that a value with a type that does not obey
this restriction could not be used without introducing
ambiguity. Here, for example, is an illegal type:


<programlisting>
  forall a. Eq a => Int
</programlisting>


When a value with this type was used, the constraint <literal>Eq tv</literal>
would be introduced where <literal>tv</literal> is a fresh type variable, and
(in the dictionary-translation implementation) the value would be
applied to a dictionary for <literal>Eq tv</literal>.  The difficulty is that we
can never know which instance of <literal>Eq</literal> to use because we never
get any more information about <literal>tv</literal>.

</para>
</listitem>
<listitem>

<para>
 <emphasis>Every constraint <literal>ci</literal> must mention at least one of the
universally quantified type variables <literal>tvi</literal></emphasis>.

For example, this type is OK because <literal>C a b</literal> mentions the
universally quantified type variable <literal>b</literal>:


<programlisting>
  forall a. C a b => burble
</programlisting>


The next type is illegal because the constraint <literal>Eq b</literal> does not
mention <literal>a</literal>:


<programlisting>
  forall a. Eq b => burble
</programlisting>


The reason for this restriction is milder than the other one.  The
excluded types are never useful or necessary (because the offending
context doesn't need to be witnessed at this point; it can be floated
out).  Furthermore, floating them out increases sharing. Lastly,
excluding them is a conservative choice; it leaves a patch of
territory free in case we need it later.

</para>
</listitem>

</OrderedList>

</para>

<para>
These restrictions apply to all types, whether declared in a type signature
or inferred.
</para>

<para>
Unlike Haskell 1.4, constraints in types do <emphasis>not</emphasis> have to be of
the form <emphasis>(class type-variables)</emphasis>.  Thus, these type signatures
are perfectly OK
</para>

<para>

<programlisting>
  f :: Eq (m a) => [m a] -> [m a]
  g :: Eq [a] => ...
</programlisting>

</para>

<para>
This choice recovers principal types, a property that Haskell 1.4 does not have.
</para>

</sect2>

<sect2>
<title>Class declarations</title>

<para>

<OrderedList>
<listitem>

<para>
 <emphasis>Multi-parameter type classes are permitted</emphasis>. For example:


<programlisting>
  class Collection c a where
    union :: c a -> c a -> c a
    ...etc.
</programlisting>



</para>
</listitem>
<listitem>

<para>
 <emphasis>The class hierarchy must be acyclic</emphasis>.  However, the definition
of "acyclic" involves only the superclass relationships.  For example,
this is OK:


<programlisting>
  class C a where {
    op :: D b => a -> b -> b
  }

  class C a => D a where { ... }
</programlisting>


Here, <literal>C</literal> is a superclass of <literal>D</literal>, but it's OK for a
class operation <literal>op</literal> of <literal>C</literal> to mention <literal>D</literal>.  (It
would not be OK for <literal>D</literal> to be a superclass of <literal>C</literal>.)

</para>
</listitem>
<listitem>

<para>
 <emphasis>There are no restrictions on the context in a class declaration
(which introduces superclasses), except that the class hierarchy must
be acyclic</emphasis>.  So these class declarations are OK:


<programlisting>
  class Functor (m k) => FiniteMap m k where
    ...

  class (Monad m, Monad (t m)) => Transform t m where
    lift :: m a -> (t m) a
</programlisting>


</para>
</listitem>
<listitem>

<para>
 <emphasis>In the signature of a class operation, every constraint
must mention at least one type variable that is not a class type
variable</emphasis>.

Thus:


<programlisting>
  class Collection c a where
    mapC :: Collection c b => (a->b) -> c a -> c b
</programlisting>


is OK because the constraint <literal>(Collection a b)</literal> mentions
<literal>b</literal>, even though it also mentions the class variable
<literal>a</literal>.  On the other hand:


<programlisting>
  class C a where
    op :: Eq a => (a,b) -> (a,b)
</programlisting>


is not OK because the constraint <literal>(Eq a)</literal> mentions on the class
type variable <literal>a</literal>, but not <literal>b</literal>.  However, any such
example is easily fixed by moving the offending context up to the
superclass context:


<programlisting>
  class Eq a => C a where
    op ::(a,b) -> (a,b)
</programlisting>


A yet more relaxed rule would allow the context of a class-op signature
to mention only class type variables.  However, that conflicts with
Rule 1(b) for types above.

</para>
</listitem>
<listitem>

<para>
 <emphasis>The type of each class operation must mention <emphasis>all</emphasis> of
the class type variables</emphasis>.  For example:


<programlisting>
  class Coll s a where
    empty  :: s
    insert :: s -> a -> s
</programlisting>


is not OK, because the type of <literal>empty</literal> doesn't mention
<literal>a</literal>.  This rule is a consequence of Rule 1(a), above, for
types, and has the same motivation.

Sometimes, offending class declarations exhibit misunderstandings.  For
example, <literal>Coll</literal> might be rewritten


<programlisting>
  class Coll s a where
    empty  :: s a
    insert :: s a -> a -> s a
</programlisting>


which makes the connection between the type of a collection of
<literal>a</literal>'s (namely <literal>(s a)</literal>) and the element type <literal>a</literal>.
Occasionally this really doesn't work, in which case you can split the
class like this:


<programlisting>
  class CollE s where
    empty  :: s

  class CollE s => Coll s a where
    insert :: s -> a -> s
</programlisting>


</para>
</listitem>

</OrderedList>

</para>

</sect2>

<sect2 id="instance-decls">
<title>Instance declarations</title>

<para>

<OrderedList>
<listitem>

<para>
 <emphasis>Instance declarations may not overlap</emphasis>.  The two instance
declarations


<programlisting>
  instance context1 => C type1 where ...
  instance context2 => C type2 where ...
</programlisting>


"overlap" if <literal>type1</literal> and <literal>type2</literal> unify

However, if you give the command line option
<option>-fallow-overlapping-instances</option><indexterm><primary>-fallow-overlapping-instances
option</primary></indexterm> then overlapping instance declarations are permitted.
However, GHC arranges never to commit to using an instance declaration
if another instance declaration also applies, either now or later.

<itemizedlist>
<listitem>

<para>
 EITHER <literal>type1</literal> and <literal>type2</literal> do not unify
</para>
</listitem>
<listitem>

<para>
 OR <literal>type2</literal> is a substitution instance of <literal>type1</literal>
(but not identical to <literal>type1</literal>), or vice versa.
</para>
</listitem>
</itemizedlist>
Notice that these rules
<itemizedlist>
<listitem>

<para>
 make it clear which instance decl to use
(pick the most specific one that matches)

</para>
</listitem>
<listitem>

<para>
 do not mention the contexts <literal>context1</literal>, <literal>context2</literal>
Reason: you can pick which instance decl
"matches" based on the type.
</para>
</listitem>

</itemizedlist>
However the rules are over-conservative.  Two instance declarations can overlap,
but it can still be clear in particular situations which to use.  For example:
<programlisting>
  instance C (Int,a) where ...
  instance C (a,Bool) where ...
</programlisting>
These are rejected by GHC's rules, but it is clear what to do when trying
to solve the constraint <literal>C (Int,Int)</literal> because the second instance
cannot apply.  Yell if this restriction bites you.
</para>
<para>
GHC is also conservative about committing to an overlapping instance.  For example:
<programlisting>
  class C a where { op :: a -> a }
  instance C [Int] where ...
  instance C a => C [a] where ...
  
  f :: C b => [b] -> [b]
  f x = op x
</programlisting>
From the RHS of f we get the constraint <literal>C [b]</literal>.  But
GHC does not commit to the second instance declaration, because in a paricular
call of f, b might be instantiate to Int, so the first instance declaration
would be appropriate.  So GHC rejects the program.  If you add <option>-fallow-incoherent-instances</option>
GHC will instead silently pick the second instance, without complaining about 
the problem of subsequent instantiations.
</para>
<para>
Regrettably, GHC doesn't guarantee to detect overlapping instance
declarations if they appear in different modules.  GHC can "see" the
instance declarations in the transitive closure of all the modules
imported by the one being compiled, so it can "see" all instance decls
when it is compiling <literal>Main</literal>.  However, it currently chooses not
to look at ones that can't possibly be of use in the module currently
being compiled, in the interests of efficiency.  (Perhaps we should
change that decision, at least for <literal>Main</literal>.)

</para>
</listitem>
<listitem>

<para>
 <emphasis>There are no restrictions on the type in an instance
<emphasis>head</emphasis>, except that at least one must not be a type variable</emphasis>.
The instance "head" is the bit after the "=>" in an instance decl. For
example, these are OK:


<programlisting>
  instance C Int a where ...

  instance D (Int, Int) where ...

  instance E [[a]] where ...
</programlisting>


Note that instance heads <emphasis>may</emphasis> contain repeated type variables.
For example, this is OK:


<programlisting>
  instance Stateful (ST s) (MutVar s) where ...
</programlisting>


The "at least one not a type variable" restriction is to ensure that
context reduction terminates: each reduction step removes one type
constructor.  For example, the following would make the type checker
loop if it wasn't excluded:


<programlisting>
  instance C a => C a where ...
</programlisting>


There are two situations in which the rule is a bit of a pain. First,
if one allows overlapping instance declarations then it's quite
convenient to have a "default instance" declaration that applies if
something more specific does not:


<programlisting>
  instance C a where
    op = ... -- Default
</programlisting>


Second, sometimes you might want to use the following to get the
effect of a "class synonym":


<programlisting>
  class (C1 a, C2 a, C3 a) => C a where { }

  instance (C1 a, C2 a, C3 a) => C a where { }
</programlisting>


This allows you to write shorter signatures:


<programlisting>
  f :: C a => ...
</programlisting>


instead of


<programlisting>
  f :: (C1 a, C2 a, C3 a) => ...
</programlisting>


I'm on the lookout for a simple rule that preserves decidability while
allowing these idioms.  The experimental flag
<option>-fallow-undecidable-instances</option><indexterm><primary>-fallow-undecidable-instances
option</primary></indexterm> lifts this restriction, allowing all the types in an
instance head to be type variables.

</para>
</listitem>
<listitem>

<para>
 <emphasis>Unlike Haskell 1.4, instance heads may use type
synonyms</emphasis>.  As always, using a type synonym is just shorthand for
writing the RHS of the type synonym definition.  For example:


<programlisting>
  type Point = (Int,Int)
  instance C Point   where ...
  instance C [Point] where ...
</programlisting>


is legal.  However, if you added


<programlisting>
  instance C (Int,Int) where ...
</programlisting>


as well, then the compiler will complain about the overlapping
(actually, identical) instance declarations.  As always, type synonyms
must be fully applied.  You cannot, for example, write:


<programlisting>
  type P a = [[a]]
  instance Monad P where ...
</programlisting>


This design decision is independent of all the others, and easily
reversed, but it makes sense to me.

</para>
</listitem>
<listitem>

<para>
<emphasis>The types in an instance-declaration <emphasis>context</emphasis> must all
be type variables</emphasis>. Thus


<programlisting>
instance C a b => Eq (a,b) where ...
</programlisting>


is OK, but


<programlisting>
instance C Int b => Foo b where ...
</programlisting>


is not OK.  Again, the intent here is to make sure that context
reduction terminates.

Voluminous correspondence on the Haskell mailing list has convinced me
that it's worth experimenting with a more liberal rule.  If you use
the flag <option>-fallow-undecidable-instances</option> can use arbitrary
types in an instance context.  Termination is ensured by having a
fixed-depth recursion stack.  If you exceed the stack depth you get a
sort of backtrace, and the opportunity to increase the stack depth
with <option>-fcontext-stack</option><emphasis>N</emphasis>.

</para>
</listitem>

</OrderedList>

</para>

</sect2>

</sect1>

<sect1 id="implicit-parameters">
<title>Implicit parameters
</title>

<para> Implicit paramters are implemented as described in 
"Implicit parameters: dynamic scoping with static types", 
J Lewis, MB Shields, E Meijer, J Launchbury,
27th ACM Symposium on Principles of Programming Languages (POPL'00),
Boston, Jan 2000.
</para>
<para>(Most of the following, stil rather incomplete, documentation is due to Jeff Lewis.)</para>
<para>
A variable is called <emphasis>dynamically bound</emphasis> when it is bound by the calling
context of a function and <emphasis>statically bound</emphasis> when bound by the callee's
context. In Haskell, all variables are statically bound. Dynamic
binding of variables is a notion that goes back to Lisp, but was later
discarded in more modern incarnations, such as Scheme. Dynamic binding
can be very confusing in an untyped language, and unfortunately, typed
languages, in particular Hindley-Milner typed languages like Haskell,
only support static scoping of variables.
</para>
<para>
However, by a simple extension to the type class system of Haskell, we
can support dynamic binding. Basically, we express the use of a
dynamically bound variable as a constraint on the type. These
constraints lead to types of the form <literal>(?x::t') => t</literal>, which says "this
function uses a dynamically-bound variable <literal>?x</literal> 
of type <literal>t'</literal>". For
example, the following expresses the type of a sort function,
implicitly parameterized by a comparison function named <literal>cmp</literal>.
<programlisting>
  sort :: (?cmp :: a -> a -> Bool) => [a] -> [a]
</programlisting>
The dynamic binding constraints are just a new form of predicate in the type class system.
</para>
<para>
An implicit parameter is introduced by the special form <literal>?x</literal>, 
where <literal>x</literal> is
any valid identifier. Use if this construct also introduces new
dynamic binding constraints. For example, the following definition
shows how we can define an implicitly parameterized sort function in
terms of an explicitly parameterized <literal>sortBy</literal> function:
<programlisting>
  sortBy :: (a -> a -> Bool) -> [a] -> [a]

  sort   :: (?cmp :: a -> a -> Bool) => [a] -> [a]
  sort    = sortBy ?cmp
</programlisting>
Dynamic binding constraints behave just like other type class
constraints in that they are automatically propagated. Thus, when a
function is used, its implicit parameters are inherited by the
function that called it. For example, our <literal>sort</literal> function might be used
to pick out the least value in a list:
<programlisting>
  least   :: (?cmp :: a -> a -> Bool) => [a] -> a
  least xs = fst (sort xs)
</programlisting>
Without lifting a finger, the <literal>?cmp</literal> parameter is
propagated to become a parameter of <literal>least</literal> as well. With explicit
parameters, the default is that parameters must always be explicit
propagated. With implicit parameters, the default is to always
propagate them.
</para>
<para>
An implicit parameter differs from other type class constraints in the
following way: All uses of a particular implicit parameter must have
the same type. This means that the type of <literal>(?x, ?x)</literal> 
is <literal>(?x::a) => (a,a)</literal>, and not 
<literal>(?x::a, ?x::b) => (a, b)</literal>, as would be the case for type
class constraints.
</para>
<para>
An implicit parameter is bound using an expression of the form 
<emphasis>expr</emphasis> <literal>with</literal> <emphasis>binds</emphasis>, 
where <literal>with</literal> is a new keyword. This form binds the implicit
parameters arising in the body, not the free variables as a <literal>let</literal> or
<literal>where</literal> would do. For example, we define the <literal>min</literal> function by binding
<literal>cmp</literal>.
<programlisting>
  min :: [a] -> a
  min  = least with ?cmp = (<=)
</programlisting>
Syntactically, the <emphasis>binds</emphasis> part of a <literal>with</literal> construct must be a
collection of simple bindings to variables (no function-style
bindings, and no type signatures); these bindings are neither
polymorphic or recursive.
</para>
<para>
Note the following additional constraints:
<itemizedlist>
<listitem>
<para> You can't have an implicit parameter in the context of a class or instance
declaration.  For example, both these declarations are illegal:
<programlisting>
  class (?x::Int) => C a where ...
  instance (?x::a) => Foo [a] where ...
</programlisting>
Reason: exactly which implicit parameter you pick up depends on exactly where
you invoke a function. But the ``invocation'' of instance declarations is done
behind the scenes by the compiler, so it's hard to figure out exactly where it is done.
Easiest thing is to outlaw the offending types.</para>
</listitem>
</itemizedlist>
</para>

</sect1>

<sect1 id="linear-implicit-parameters">
<title>Linear implicit parameters
</title>
<para>
Linear implicit parameters are an idea developed by Koen Claessen,
Mark Shields, and Simon PJ.  They address the long-standing
problem that monads seem over-kill for certain sorts of problem, notably:
</para>
<itemizedlist>
<listitem> <para> distributing a supply of unique names </para> </listitem>
<listitem> <para> distributing a suppply of random numbers </para> </listitem>
<listitem> <para> distributing an oracle (as in QuickCheck) </para> </listitem>
</itemizedlist>

<para>
Linear implicit parameters are just like ordinary implicit parameters,
except that they are "linear" -- that is, they cannot be copied, and
must be explicitly "split" instead.  Linear implicit parameters are
written '<literal>%x</literal>' instead of '<literal>?x</literal>'.  
(The '/' in the '%' suggests the split!)
</para>
<para>
For example:
<programlisting>
    data NameSupply = ...
    
    splitNS :: NameSupply -> (NameSupply, NameSupply)
    newName :: NameSupply -> Name

    instance PrelSplit.Splittable NameSupply where
	split = splitNS


    f :: (%ns :: NameSupply) => Env -> Expr -> Expr
    f env (Lam x e) = Lam x' (f env e)
		    where
		      x'   = newName %ns
		      env' = extend env x x'
    ...more equations for f...
</programlisting>
Notice that the implicit parameter %ns is consumed 
<itemizedlist>
<listitem> <para> once by the call to <literal>newName</literal> </para> </listitem>
<listitem> <para> once by the recursive call to <literal>f</literal> </para></listitem>
</itemizedlist>
</para>
<para>
So the translation done by the type checker makes
the parameter explicit:
<programlisting>
    f :: NameSupply -> Env -> Expr -> Expr
    f ns env (Lam x e) = Lam x' (f ns1 env e)
		       where
	 		 (ns1,ns2) = splitNS ns
			 x' = newName ns2
			 env = extend env x x'
</programlisting>
Notice the call to 'split' introduced by the type checker.
How did it know to use 'splitNS'?  Because what it really did
was to introduce a call to the overloaded function 'split',
defined by
<programlisting>
	class Splittable a where
	  split :: a -> (a,a)
</programlisting>
The instance for <literal>Splittable NameSupply</literal> tells GHC how to implement
split for name supplies.  But we can simply write
<programlisting>
	g x = (x, %ns, %ns)
</programlisting>
and GHC will infer
<programlisting>
	g :: (Splittable a, %ns :: a) => b -> (b,a,a)
</programlisting>
The <literal>Splittable</literal> class is built into GHC.  It's defined in <literal>PrelSplit</literal>,
and exported by <literal>GlaExts</literal>.
</para>
<para>
Other points:
<itemizedlist>
<listitem> <para> '<literal>?x</literal>' and '<literal>%x</literal>' 
are entirely distinct implicit parameters: you 
  can use them together and they won't intefere with each other. </para>
</listitem>

<listitem> <para> You can bind linear implicit parameters in 'with' clauses. </para> </listitem>

<listitem> <para>You cannot have implicit parameters (whether linear or not)
  in the context of a class or instance declaration. </para></listitem>
</itemizedlist>
</para>

<sect2><title>Warnings</title>

<para>
The monomorphism restriction is even more important than usual.
Consider the example above:
<programlisting>
    f :: (%ns :: NameSupply) => Env -> Expr -> Expr
    f env (Lam x e) = Lam x' (f env e)
		    where
		      x'   = newName %ns
		      env' = extend env x x'
</programlisting>
If we replaced the two occurrences of x' by (newName %ns), which is
usually a harmless thing to do, we get:
<programlisting>
    f :: (%ns :: NameSupply) => Env -> Expr -> Expr
    f env (Lam x e) = Lam (newName %ns) (f env e)
		    where
		      env' = extend env x (newName %ns)
</programlisting>
But now the name supply is consumed in <emphasis>three</emphasis> places
(the two calls to newName,and the recursive call to f), so
the result is utterly different.  Urk!  We don't even have 
the beta rule.
</para>
<para>
Well, this is an experimental change.  With implicit
parameters we have already lost beta reduction anyway, and
(as John Launchbury puts it) we can't sensibly reason about
Haskell programs without knowing their typing.
</para>

</sect2>

</sect1>

<sect1 id="functional-dependencies">
<title>Functional dependencies
</title>

<para> Functional dependencies are implemented as described by Mark Jones
in "Type Classes with Functional Dependencies", Mark P. Jones, 
In Proceedings of the 9th European Symposium on Programming, 
ESOP 2000, Berlin, Germany, March 2000, Springer-Verlag LNCS 1782.
</para>

<para>
There should be more documentation, but there isn't (yet).  Yell if you need it.
</para>
</sect1>


<sect1 id="universal-quantification">
<title>Explicit universal quantification
</title>

<para>
Haskell type signatures are implicitly quantified.  The new keyword <literal>forall</literal>
allows us to say exactly what this means.  For example:
</para>
<para>
<programlisting>
        g :: b -> b
</programlisting>
means this:
<programlisting>
        g :: forall b. (b -> b)
</programlisting>
The two are treated identically.
</para>

<para>
However, GHC's type system supports <emphasis>arbitrary-rank</emphasis> 
explicit universal quantification in
types. 
For example, all the following types are legal:
<programlisting>
    f1 :: forall a b. a -> b -> a
    g1 :: forall a b. (Ord a, Eq  b) => a -> b -> a

    f2 :: (forall a. a->a) -> Int -> Int
    g2 :: (forall a. Eq a => [a] -> a -> Bool) -> Int -> Int

    f3 :: ((forall a. a->a) -> Int) -> Bool -> Bool
</programlisting>
Here, <literal>f1</literal> and <literal>g1</literal> are rank-1 types, and
can be written in standard Haskell (e.g. <literal>f1 :: a->b->a</literal>).
The <literal>forall</literal> makes explicit the universal quantification that
is implicitly added by Haskell.
</para>
<para>
The functions <literal>f2</literal> and <literal>g2</literal> have rank-2 types;
the <literal>forall</literal> is on the left of a function arrrow.  As <literal>g2</literal>
shows, the polymorphic type on the left of the function arrow can be overloaded.
</para>
<para>
The functions <literal>f3</literal> and <literal>g3</literal> have rank-3 types;
they have rank-2 types on the left of a function arrow.
</para>
<para>
GHC allows types of arbitrary rank; you can nest <literal>forall</literal>s
arbitrarily deep in function arrows.   (GHC used to be restricted to rank 2, but
that restriction has now been lifted.)
In particular, a forall-type (also called a "type scheme"),
including an operational type class context, is legal:
<itemizedlist>
<listitem> <para> On the left of a function arrow </para> </listitem>
<listitem> <para> On the right of a function arrow (see <xref linkend="hoist">) </para> </listitem>
<listitem> <para> As the argument of a constructor, or type of a field, in a data type declaration. For
example, any of the <literal>f1,f2,f3,g1,g2,g3</literal> above would be valid
field type signatures.</para> </listitem>
<listitem> <para> As the type of an implicit parameter </para> </listitem>
<listitem> <para> In a pattern type signature (see <xref linkend="scoped-type-variables">) </para> </listitem>
</itemizedlist>
There is one place you cannot put a <literal>forall</literal>:
you cannot instantiate a type variable with a forall-type.  So you cannot 
make a forall-type the argument of a type constructor.  So these types are illegal:
<programlisting>
    x1 :: [forall a. a->a]
    x2 :: (forall a. a->a, Int)
    x3 :: Maybe (forall a. a->a)
</programlisting>
Of course <literal>forall</literal> becomes a keyword; you can't use <literal>forall</literal> as
a type variable any more!
</para>


<sect2 id="univ">
<title>Examples
</title>

<para>
In a <literal>data</literal> or <literal>newtype</literal> declaration one can quantify
the types of the constructor arguments.  Here are several examples:
</para>

<para>

<programlisting>
data T a = T1 (forall b. b -> b -> b) a

data MonadT m = MkMonad { return :: forall a. a -> m a,
                          bind   :: forall a b. m a -> (a -> m b) -> m b
                        }

newtype Swizzle = MkSwizzle (Ord a => [a] -> [a])
</programlisting>

</para>

<para>
The constructors have rank-2 types:
</para>

<para>

<programlisting>
T1 :: forall a. (forall b. b -> b -> b) -> a -> T a
MkMonad :: forall m. (forall a. a -> m a)
                  -> (forall a b. m a -> (a -> m b) -> m b)
                  -> MonadT m
MkSwizzle :: (Ord a => [a] -> [a]) -> Swizzle
</programlisting>

</para>

<para>
Notice that you don't need to use a <literal>forall</literal> if there's an
explicit context.  For example in the first argument of the
constructor <function>MkSwizzle</function>, an implicit "<literal>forall a.</literal>" is
prefixed to the argument type.  The implicit <literal>forall</literal>
quantifies all type variables that are not already in scope, and are
mentioned in the type quantified over.
</para>

<para>
As for type signatures, implicit quantification happens for non-overloaded
types too.  So if you write this:

<programlisting>
  data T a = MkT (Either a b) (b -> b)
</programlisting>

it's just as if you had written this:

<programlisting>
  data T a = MkT (forall b. Either a b) (forall b. b -> b)
</programlisting>

That is, since the type variable <literal>b</literal> isn't in scope, it's
implicitly universally quantified.  (Arguably, it would be better
to <emphasis>require</emphasis> explicit quantification on constructor arguments
where that is what is wanted.  Feedback welcomed.)
</para>

<para>
You construct values of types <literal>T1, MonadT, Swizzle</literal> by applying
the constructor to suitable values, just as usual.  For example,
</para>

<para>

<programlisting>
    a1 :: T Int
    a1 = T1 (\xy->x) 3
    
    a2, a3 :: Swizzle
    a2 = MkSwizzle sort
    a3 = MkSwizzle reverse
    
    a4 :: MonadT Maybe
    a4 = let r x = Just x
	     b m k = case m of
		       Just y -> k y
		       Nothing -> Nothing
         in
         MkMonad r b

    mkTs :: (forall b. b -> b -> b) -> a -> [T a]
    mkTs f x y = [T1 f x, T1 f y]
</programlisting>

</para>

<para>
The type of the argument can, as usual, be more general than the type
required, as <literal>(MkSwizzle reverse)</literal> shows.  (<function>reverse</function>
does not need the <literal>Ord</literal> constraint.)
</para>

<para>
When you use pattern matching, the bound variables may now have
polymorphic types.  For example:
</para>

<para>

<programlisting>
    f :: T a -> a -> (a, Char)
    f (T1 w k) x = (w k x, w 'c' 'd')

    g :: (Ord a, Ord b) => Swizzle -> [a] -> (a -> b) -> [b]
    g (MkSwizzle s) xs f = s (map f (s xs))

    h :: MonadT m -> [m a] -> m [a]
    h m [] = return m []
    h m (x:xs) = bind m x          $ \y ->
                 bind m (h m xs)   $ \ys ->
                 return m (y:ys)
</programlisting>

</para>

<para>
In the function <function>h</function> we use the record selectors <literal>return</literal>
and <literal>bind</literal> to extract the polymorphic bind and return functions
from the <literal>MonadT</literal> data structure, rather than using pattern
matching.
</para>
</sect2>

<sect2>
<title>Type inference</title>

<para>
In general, type inference for arbitrary-rank types is undecideable.
GHC uses an algorithm proposed by Odersky and Laufer ("Putting type annotations to work", POPL'96)
to get a decidable algorithm by requiring some help from the programmer.
We do not yet have a formal specification of "some help" but the rule is this:
</para>
<para>
<emphasis>For a lambda-bound or case-bound variable, x, either the programmer
provides an explicit polymorphic type for x, or GHC's type inference will assume
that x's type has no foralls in it</emphasis>.
</para>
<para>
What does it mean to "provide" an explicit type for x?  You can do that by 
giving a type signature for x directly, using a pattern type signature
(<xref linkend="scoped-type-variables">), thus:
<programlisting>
     \ f :: (forall a. a->a) -> (f True, f 'c')
</programlisting>
Alternatively, you can give a type signature to the enclosing
context, which GHC can "push down" to find the type for the variable:
<programlisting>
     (\ f -> (f True, f 'c')) :: (forall a. a->a) -> (Bool,Char)
</programlisting>
Here the type signature on the expression can be pushed inwards
to give a type signature for f.  Similarly, and more commonly,
one can give a type signature for the function itself:
<programlisting>
     h :: (forall a. a->a) -> (Bool,Char)
     h f = (f True, f 'c')
</programlisting>
You don't need to give a type signature if the lambda bound variable
is a constructor argument.  Here is an example we saw earlier:
<programlisting>
    f :: T a -> a -> (a, Char)
    f (T1 w k) x = (w k x, w 'c' 'd')
</programlisting>
Here we do not need to give a type signature to <literal>w</literal>, because
it is an argument of constructor <literal>T1</literal> and that tells GHC all
it needs to know.
</para>

</sect2>


<sect2 id="implicit-quant">
<title>Implicit quantification</title>

<para>
GHC performs implicit quantification as follows.  <emphasis>At the top level (only) of 
user-written types, if and only if there is no explicit <literal>forall</literal>,
GHC finds all the type variables mentioned in the type that are not already
in scope, and universally quantifies them.</emphasis>  For example, the following pairs are 
equivalent:
<programlisting>
  f :: a -> a
  f :: forall a. a -> a

  g (x::a) = let
                h :: a -> b -> b
                h x y = y
             in ...
  g (x::a) = let
                h :: forall b. a -> b -> b
                h x y = y
             in ...
</programlisting>
</para>
<para>
Notice that GHC does <emphasis>not</emphasis> find the innermost possible quantification
point.  For example:
<programlisting>
  f :: (a -> a) -> Int
           -- MEANS
  f :: forall a. (a -> a) -> Int
           -- NOT
  f :: (forall a. a -> a) -> Int


  g :: (Ord a => a -> a) -> Int
           -- MEANS the illegal type
  g :: forall a. (Ord a => a -> a) -> Int
           -- NOT
  g :: (forall a. Ord a => a -> a) -> Int
</programlisting>
The latter produces an illegal type, which you might think is silly,
but at least the rule is simple.  If you want the latter type, you
can write your for-alls explicitly.  Indeed, doing so is strongly advised
for rank-2 types.
</para>
</sect2>
</sect1>

<sect1 id="hoist">
<title>Type synonyms and hoisting
</title>

<para>
Type synonmys are like macros at the type level, and GHC is much more liberal
about them than Haskell 98.  In particular:
<itemizedlist>
<listitem> <para>You can write a <literal>forall</literal> (including overloading)
in a type synonym, thus:
<programlisting>
  type Discard a = forall b. Show b => a -> b -> (a, String)

  f :: Discard a
  f x y = (x, show y)

  g :: Discard Int -> (Int,Bool)    -- A rank-2 type
  g f = f Int True
</programlisting>
</para>
</listitem>

<listitem><para>
You can write an unboxed tuple in a type synonym:
<programlisting>
  type Pr = (# Int, Int #)

  h :: Int -> Pr
  h x = (# x, x #)
</programlisting>
</para></listitem>
</itemizedlist>
</para>
<para>
GHC does validity checking on types <emphasis>after expanding type synonyms</emphasis> 
so, for example,
this will be rejected:
<programlisting>
  type Pr = (# Int, Int #)

  h :: Pr -> Int
  h x = ...
</programlisting>
because GHC does not allow  unboxed tuples on the left of a function arrow.
</para>

<para>
However, it is often convenient to use these sort of generalised synonyms at the right hand
end of an arrow, thus:
<programlisting>
  type Discard a = forall b. a -> b -> a

  g :: Int -> Discard Int
  g x y z = x+y
</programlisting>
Simply expanding the type synonym would give
<programlisting>
  g :: Int -> (forall b. Int -> b -> Int)
</programlisting>
but GHC "hoists" the <literal>forall</literal> to give the isomorphic type
<programlisting>
  g :: forall b. Int -> Int -> b -> Int
</programlisting>
In general, the rule is this: <emphasis>to determine the type specified by any explicit
user-written type (e.g. in a type signature), GHC expands type synonyms and then repeatedly
performs the transformation:</emphasis>
<programlisting>
  <emphasis>type1</emphasis> -> forall a1..an. <emphasis>context2</emphasis> => <emphasis>type2</emphasis>
==>
  forall a1..an. <emphasis>context2</emphasis> => <emphasis>type1</emphasis> -> <emphasis>type2</emphasis>
</programlisting>
(In fact, GHC tries to retain as much synonym information as possible for use in
error messages, but that is a usability issue.)  This rule applies, of course, whether
or not the <literal>forall</literal> comes from a synonym. For example, here is another
valid way to write <literal>g</literal>'s type signature:
<programlisting>
  g :: Int -> Int -> forall b. b -> Int
</programlisting>
</para>
</sect1>


<sect1 id="existential-quantification">
<title>Existentially quantified data constructors
</title>

<para>
The idea of using existential quantification in data type declarations
was suggested by Laufer (I believe, thought doubtless someone will
correct me), and implemented in Hope+. It's been in Lennart
Augustsson's <Command>hbc</Command> Haskell compiler for several years, and
proved very useful.  Here's the idea.  Consider the declaration:
</para>

<para>

<programlisting>
  data Foo = forall a. MkFoo a (a -> Bool)
           | Nil
</programlisting>

</para>

<para>
The data type <literal>Foo</literal> has two constructors with types:
</para>

<para>

<programlisting>
  MkFoo :: forall a. a -> (a -> Bool) -> Foo
  Nil   :: Foo
</programlisting>

</para>

<para>
Notice that the type variable <literal>a</literal> in the type of <function>MkFoo</function>
does not appear in the data type itself, which is plain <literal>Foo</literal>.
For example, the following expression is fine:
</para>

<para>

<programlisting>
  [MkFoo 3 even, MkFoo 'c' isUpper] :: [Foo]
</programlisting>

</para>

<para>
Here, <literal>(MkFoo 3 even)</literal> packages an integer with a function
<function>even</function> that maps an integer to <literal>Bool</literal>; and <function>MkFoo 'c'
isUpper</function> packages a character with a compatible function.  These
two things are each of type <literal>Foo</literal> and can be put in a list.
</para>

<para>
What can we do with a value of type <literal>Foo</literal>?.  In particular,
what happens when we pattern-match on <function>MkFoo</function>?
</para>

<para>

<programlisting>
  f (MkFoo val fn) = ???
</programlisting>

</para>

<para>
Since all we know about <literal>val</literal> and <function>fn</function> is that they
are compatible, the only (useful) thing we can do with them is to
apply <function>fn</function> to <literal>val</literal> to get a boolean.  For example:
</para>

<para>

<programlisting>
  f :: Foo -> Bool
  f (MkFoo val fn) = fn val
</programlisting>

</para>

<para>
What this allows us to do is to package heterogenous values
together with a bunch of functions that manipulate them, and then treat
that collection of packages in a uniform manner.  You can express
quite a bit of object-oriented-like programming this way.
</para>

<sect2 id="existential">
<title>Why existential?
</title>

<para>
What has this to do with <emphasis>existential</emphasis> quantification?
Simply that <function>MkFoo</function> has the (nearly) isomorphic type
</para>

<para>

<programlisting>
  MkFoo :: (exists a . (a, a -> Bool)) -> Foo
</programlisting>

</para>

<para>
But Haskell programmers can safely think of the ordinary
<emphasis>universally</emphasis> quantified type given above, thereby avoiding
adding a new existential quantification construct.
</para>

</sect2>

<sect2>
<title>Type classes</title>

<para>
An easy extension (implemented in <Command>hbc</Command>) is to allow
arbitrary contexts before the constructor.  For example:
</para>

<para>

<programlisting>
data Baz = forall a. Eq a => Baz1 a a
         | forall b. Show b => Baz2 b (b -> b)
</programlisting>

</para>

<para>
The two constructors have the types you'd expect:
</para>

<para>

<programlisting>
Baz1 :: forall a. Eq a => a -> a -> Baz
Baz2 :: forall b. Show b => b -> (b -> b) -> Baz
</programlisting>

</para>

<para>
But when pattern matching on <function>Baz1</function> the matched values can be compared
for equality, and when pattern matching on <function>Baz2</function> the first matched
value can be converted to a string (as well as applying the function to it).
So this program is legal:
</para>

<para>

<programlisting>
  f :: Baz -> String
  f (Baz1 p q) | p == q    = "Yes"
               | otherwise = "No"
  f (Baz2 v fn)            = show (fn v)
</programlisting>

</para>

<para>
Operationally, in a dictionary-passing implementation, the
constructors <function>Baz1</function> and <function>Baz2</function> must store the
dictionaries for <literal>Eq</literal> and <literal>Show</literal> respectively, and
extract it on pattern matching.
</para>

<para>
Notice the way that the syntax fits smoothly with that used for
universal quantification earlier.
</para>

</sect2>

<sect2>
<title>Restrictions</title>

<para>
There are several restrictions on the ways in which existentially-quantified
constructors can be use.
</para>

<para>

<itemizedlist>
<listitem>

<para>
 When pattern matching, each pattern match introduces a new,
distinct, type for each existential type variable.  These types cannot
be unified with any other type, nor can they escape from the scope of
the pattern match.  For example, these fragments are incorrect:


<programlisting>
f1 (MkFoo a f) = a
</programlisting>


Here, the type bound by <function>MkFoo</function> "escapes", because <literal>a</literal>
is the result of <function>f1</function>.  One way to see why this is wrong is to
ask what type <function>f1</function> has:


<programlisting>
  f1 :: Foo -> a             -- Weird!
</programlisting>


What is this "<literal>a</literal>" in the result type? Clearly we don't mean
this:


<programlisting>
  f1 :: forall a. Foo -> a   -- Wrong!
</programlisting>


The original program is just plain wrong.  Here's another sort of error


<programlisting>
  f2 (Baz1 a b) (Baz1 p q) = a==q
</programlisting>


It's ok to say <literal>a==b</literal> or <literal>p==q</literal>, but
<literal>a==q</literal> is wrong because it equates the two distinct types arising
from the two <function>Baz1</function> constructors.


</para>
</listitem>
<listitem>

<para>
You can't pattern-match on an existentially quantified
constructor in a <literal>let</literal> or <literal>where</literal> group of
bindings. So this is illegal:


<programlisting>
  f3 x = a==b where { Baz1 a b = x }
</programlisting>


You can only pattern-match
on an existentially-quantified constructor in a <literal>case</literal> expression or
in the patterns of a function definition.

The reason for this restriction is really an implementation one.
Type-checking binding groups is already a nightmare without
existentials complicating the picture.  Also an existential pattern
binding at the top level of a module doesn't make sense, because it's
not clear how to prevent the existentially-quantified type "escaping".
So for now, there's a simple-to-state restriction.  We'll see how
annoying it is.

</para>
</listitem>
<listitem>

<para>
You can't use existential quantification for <literal>newtype</literal>
declarations.  So this is illegal:


<programlisting>
  newtype T = forall a. Ord a => MkT a
</programlisting>


Reason: a value of type <literal>T</literal> must be represented as a pair
of a dictionary for <literal>Ord t</literal> and a value of type <literal>t</literal>.
That contradicts the idea that <literal>newtype</literal> should have no
concrete representation.  You can get just the same efficiency and effect
by using <literal>data</literal> instead of <literal>newtype</literal>.  If there is no
overloading involved, then there is more of a case for allowing
an existentially-quantified <literal>newtype</literal>, because the <literal>data</literal>
because the <literal>data</literal> version does carry an implementation cost,
but single-field existentially quantified constructors aren't much
use.  So the simple restriction (no existential stuff on <literal>newtype</literal>)
stands, unless there are convincing reasons to change it.


</para>
</listitem>
<listitem>

<para>
 You can't use <literal>deriving</literal> to define instances of a
data type with existentially quantified data constructors.

Reason: in most cases it would not make sense. For example:&num;

<programlisting>
data T = forall a. MkT [a] deriving( Eq )
</programlisting>

To derive <literal>Eq</literal> in the standard way we would need to have equality
between the single component of two <function>MkT</function> constructors:

<programlisting>
instance Eq T where
  (MkT a) == (MkT b) = ???
</programlisting>

But <VarName>a</VarName> and <VarName>b</VarName> have distinct types, and so can't be compared.
It's just about possible to imagine examples in which the derived instance
would make sense, but it seems altogether simpler simply to prohibit such
declarations.  Define your own instances!
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

</sect1>

<sect1 id="scoped-type-variables">
<title>Scoped Type Variables
</title>

<para>
A <emphasis>pattern type signature</emphasis> can introduce a <emphasis>scoped type
variable</emphasis>.  For example
</para>

<para>

<programlisting>
f (xs::[a]) = ys ++ ys
           where
              ys :: [a]
              ys = reverse xs
</programlisting>

</para>

<para>
The pattern <literal>(xs::[a])</literal> includes a type signature for <VarName>xs</VarName>.
This brings the type variable <literal>a</literal> into scope; it scopes over
all the patterns and right hand sides for this equation for <function>f</function>.
In particular, it is in scope at the type signature for <VarName>y</VarName>.
</para>

<para>
 Pattern type signatures are completely orthogonal to ordinary, separate
type signatures.  The two can be used independently or together.
At ordinary type signatures, such as that for <VarName>ys</VarName>, any type variables
mentioned in the type signature <emphasis>that are not in scope</emphasis> are
implicitly universally quantified.  (If there are no type variables in
scope, all type variables mentioned in the signature are universally
quantified, which is just as in Haskell 98.)  In this case, since <VarName>a</VarName>
is in scope, it is not universally quantified, so the type of <VarName>ys</VarName> is
the same as that of <VarName>xs</VarName>.  In Haskell 98 it is not possible to declare
a type for <VarName>ys</VarName>; a major benefit of scoped type variables is that
it becomes possible to do so.
</para>

<para>
Scoped type variables are implemented in both GHC and Hugs.  Where the
implementations differ from the specification below, those differences
are noted.
</para>

<para>
So much for the basic idea.  Here are the details.
</para>

<sect2>
<title>What a pattern type signature means</title>
<para>
A type variable brought into scope by a pattern type signature is simply
the name for a type.   The restriction they express is that all occurrences
of the same name mean the same type.  For example:
<programlisting>
  f :: [Int] -> Int -> Int
  f (xs::[a]) (y::a) = (head xs + y) :: a
</programlisting>
The pattern type signatures on the left hand side of
<literal>f</literal> express the fact that <literal>xs</literal>
must be a list of things of some type <literal>a</literal>; and that <literal>y</literal>
must have this same type.  The type signature on the expression <literal>(head xs)</literal>
specifies that this expression must have the same type <literal>a</literal>.
<emphasis>There is no requirement that the type named by "<literal>a</literal>" is
in fact a type variable</emphasis>.  Indeed, in this case, the type named by "<literal>a</literal>" is
<literal>Int</literal>.  (This is a slight liberalisation from the original rather complex
rules, which specified that a pattern-bound type variable should be universally quantified.)
For example, all of these are legal:</para>

<programlisting>
  t (x::a) (y::a) = x+y*2

  f (x::a) (y::b) = [x,y]       -- a unifies with b

  g (x::a) = x + 1::Int         -- a unifies with Int

  h x = let k (y::a) = [x,y]    -- a is free in the
        in k x                  -- environment

  k (x::a) True    = ...        -- a unifies with Int
  k (x::Int) False = ...

  w :: [b] -> [b]
  w (x::a) = x                  -- a unifies with [b]
</programlisting>

</sect2>

<sect2>
<title>Scope and implicit quantification</title>

<para>

<itemizedlist>
<listitem>

<para>
All the type variables mentioned in a pattern,
that are not already in scope,
are brought into scope by the pattern.  We describe this set as
the <emphasis>type variables bound by the pattern</emphasis>.
For example:
<programlisting>
  f (x::a) = let g (y::(a,b)) = fst y
             in
             g (x,True)
</programlisting>
The pattern <literal>(x::a)</literal> brings the type variable
<literal>a</literal> into scope, as well as the term 
variable <literal>x</literal>.  The pattern <literal>(y::(a,b))</literal>
contains an occurrence of the already-in-scope type variable <literal>a</literal>,
and brings into scope the type variable <literal>b</literal>.
</para>
</listitem>

<listitem>
<para>
The type variable(s) bound by the pattern have the same scope
as the term variable(s) bound by the pattern.  For example:
<programlisting>
  let
    f (x::a) = <...rhs of f...>
    (p::b, q::b) = (1,2)
  in <...body of let...>
</programlisting>
Here, the type variable <literal>a</literal> scopes over the right hand side of <literal>f</literal>,
just like <literal>x</literal> does; while the type variable <literal>b</literal> scopes over the
body of the <literal>let</literal>, and all the other definitions in the <literal>let</literal>,
just like <literal>p</literal> and <literal>q</literal> do.
Indeed, the newly bound type variables also scope over any ordinary, separate
type signatures in the <literal>let</literal> group.
</para>
</listitem>


<listitem>
<para>
The type variables bound by the pattern may be 
mentioned in ordinary type signatures or pattern 
type signatures anywhere within their scope.

</para>
</listitem>

<listitem>
<para>
 In ordinary type signatures, any type variable mentioned in the
signature that is in scope is <emphasis>not</emphasis> universally quantified.

</para>
</listitem>

<listitem>

<para>
 Ordinary type signatures do not bring any new type variables
into scope (except in the type signature itself!). So this is illegal:

<programlisting>
  f :: a -> a
  f x = x::a
</programlisting>

It's illegal because <VarName>a</VarName> is not in scope in the body of <function>f</function>,
so the ordinary signature <literal>x::a</literal> is equivalent to <literal>x::forall a.a</literal>;
and that is an incorrect typing.

</para>
</listitem>

<listitem>
<para>
The pattern type signature is a monotype:
</para>

<itemizedlist>
<listitem> <para> 
A pattern type signature cannot contain any explicit <literal>forall</literal> quantification.
</para> </listitem>

<listitem>  <para> 
The type variables bound by a pattern type signature can only be instantiated to monotypes,
not to type schemes.
</para> </listitem>

<listitem>  <para> 
There is no implicit universal quantification on pattern type signatures (in contrast to
ordinary type signatures).
</para> </listitem>

</itemizedlist>

</listitem>

<listitem>
<para>

The type variables in the head of a <literal>class</literal> or <literal>instance</literal> declaration
scope over the methods defined in the <literal>where</literal> part.  For example:


<programlisting>
  class C a where
    op :: [a] -> a

    op xs = let ys::[a]
                ys = reverse xs
            in
            head ys
</programlisting>


(Not implemented in Hugs yet, Dec 98).
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2>
<title>Result type signatures</title>

<para>

<itemizedlist>
<listitem>

<para>
 The result type of a function can be given a signature,
thus:


<programlisting>
  f (x::a) :: [a] = [x,x,x]
</programlisting>


The final <literal>:: [a]</literal> after all the patterns gives a signature to the
result type.  Sometimes this is the only way of naming the type variable
you want:


<programlisting>
  f :: Int -> [a] -> [a]
  f n :: ([a] -> [a]) = let g (x::a, y::a) = (y,x)
                        in \xs -> map g (reverse xs `zip` xs)
</programlisting>


</para>
</listitem>

</itemizedlist>

</para>

<para>
Result type signatures are not yet implemented in Hugs.
</para>

</sect2>

<sect2>
<title>Where a pattern type signature can occur</title>

<para>
A pattern type signature can occur in any pattern.  For example:
<itemizedlist>

<listitem>
<para>
A pattern type signature can be on an arbitrary sub-pattern, not
ust on a variable:


<programlisting>
  f ((x,y)::(a,b)) = (y,x) :: (b,a)
</programlisting>


</para>
</listitem>
<listitem>

<para>
 Pattern type signatures, including the result part, can be used
in lambda abstractions:

<programlisting>
  (\ (x::a, y) :: a -> x)
</programlisting>
</para>
</listitem>
<listitem>

<para>
 Pattern type signatures, including the result part, can be used
in <literal>case</literal> expressions:


<programlisting>
  case e of { (x::a, y) :: a -> x }
</programlisting>

</para>
</listitem>

<listitem>
<para>
To avoid ambiguity, the type after the &ldquo;<literal>::</literal>&rdquo; in a result
pattern signature on a lambda or <literal>case</literal> must be atomic (i.e. a single
token or a parenthesised type of some sort).  To see why,
consider how one would parse this:


<programlisting>
  \ x :: a -> b -> x
</programlisting>


</para>
</listitem>

<listitem>

<para>
 Pattern type signatures can bind existential type variables.
For example:


<programlisting>
  data T = forall a. MkT [a]

  f :: T -> T
  f (MkT [t::a]) = MkT t3
                 where
                   t3::[a] = [t,t,t]
</programlisting>


</para>
</listitem>


<listitem>

<para>
Pattern type signatures 
can be used in pattern bindings:

<programlisting>
  f x = let (y, z::a) = x in ...
  f1 x                = let (y, z::Int) = x in ...
  f2 (x::(Int,a))     = let (y, z::a)   = x in ...
  f3 :: (b->b)        = \x -> x
</programlisting>

In all such cases, the binding is not generalised over the pattern-bound
type variables.  Thus <literal>f3</literal> is monomorphic; <literal>f3</literal>
has type <literal>b -&gt; b</literal> for some type <literal>b</literal>, 
and <emphasis>not</emphasis> <literal>forall b. b -&gt; b</literal>.
In contrast, the binding
<programlisting>
  f4 :: b->b
  f4 = \x -> x
</programlisting>
makes a polymorphic function, but <literal>b</literal> is not in scope anywhere
in <literal>f4</literal>'s scope.

</para>
</listitem>
</itemizedlist>
</para>

</sect2>
</sect1>

<sect1 id="sec-kinding">
<title>Explicitly-kinded quantification</title>

<para>
Haskell infers the kind of each type variable.  Sometimes it is nice to be able
to give the kind explicitly as (machine-checked) documentation, 
just as it is nice to give a type signature for a function.  On some occasions,
it is essential to do so.  For example, in his paper "Restricted Data Types in Haskell" (Haskell Workshop 1999)
John Hughes had to define the data type:
<Screen>
     data Set cxt a = Set [a]
                    | Unused (cxt a -> ())
</Screen>
The only use for the <literal>Unused</literal> constructor was to force the correct
kind for the type variable <literal>cxt</literal>.
</para>
<para>
GHC now instead allows you to specify the kind of a type variable directly, wherever
a type variable is explicitly bound.  Namely:
<itemizedlist>
<listitem><para><literal>data</literal> declarations:
<Screen>
  data Set (cxt :: * -> *) a = Set [a]
</Screen></para></listitem>
<listitem><para><literal>type</literal> declarations:
<Screen>
  type T (f :: * -> *) = f Int
</Screen></para></listitem>
<listitem><para><literal>class</literal> declarations:
<Screen>
  class (Eq a) => C (f :: * -> *) a where ...
</Screen></para></listitem>
<listitem><para><literal>forall</literal>'s in type signatures:
<Screen>
  f :: forall (cxt :: * -> *). Set cxt Int
</Screen></para></listitem>
</itemizedlist>
</para>

<para>
The parentheses are required.  Some of the spaces are required too, to
separate the lexemes.  If you write <literal>(f::*->*)</literal> you
will get a parse error, because "<literal>::*->*</literal>" is a
single lexeme in Haskell.
</para>

<para>
As part of the same extension, you can put kind annotations in types
as well.  Thus:
<Screen>
   f :: (Int :: *) -> Int
   g :: forall a. a -> (a :: *)
</Screen>
The syntax is
<Screen>
   atype ::= '(' ctype '::' kind ')
</Screen>
The parentheses are required.
</para>
</sect1>
  
<sect1 id="sec-assertions">
<title>Assertions
<indexterm><primary>Assertions</primary></indexterm>
</title>

<para>
If you want to make use of assertions in your standard Haskell code, you
could define a function like the following:
</para>

<para>

<programlisting>
assert :: Bool -> a -> a
assert False x = error "assertion failed!"
assert _     x = x
</programlisting>

</para>

<para>
which works, but gives you back a less than useful error message --
an assertion failed, but which and where?
</para>

<para>
One way out is to define an extended <function>assert</function> function which also
takes a descriptive string to include in the error message and
perhaps combine this with the use of a pre-processor which inserts
the source location where <function>assert</function> was used.
</para>

<para>
Ghc offers a helping hand here, doing all of this for you. For every
use of <function>assert</function> in the user's source:
</para>

<para>

<programlisting>
kelvinToC :: Double -> Double
kelvinToC k = assert (k &gt;= 0.0) (k+273.15)
</programlisting>

</para>

<para>
Ghc will rewrite this to also include the source location where the
assertion was made,
</para>

<para>

<programlisting>
assert pred val ==> assertError "Main.hs|15" pred val
</programlisting>

</para>

<para>
The rewrite is only performed by the compiler when it spots
applications of <function>Exception.assert</function>, so you can still define and
use your own versions of <function>assert</function>, should you so wish. If not,
import <literal>Exception</literal> to make use <function>assert</function> in your code.
</para>

<para>
To have the compiler ignore uses of assert, use the compiler option
<option>-fignore-asserts</option>. <indexterm><primary>-fignore-asserts option</primary></indexterm> That is,
expressions of the form <literal>assert pred e</literal> will be rewritten to <literal>e</literal>.
</para>

<para>
Assertion failures can be caught, see the documentation for the
<literal>Exception</literal> library (<xref linkend="sec-Exception">)
for the details.
</para>

</sect1>

  <sect1 id="pragmas">
    <title>Pragmas</title>

    <indexterm><primary>pragma</primary></indexterm>

    <para>GHC supports several pragmas, or instructions to the
    compiler placed in the source code.  Pragmas don't normally affect
    the meaning of the program, but they might affect the efficiency
    of the generated code.</para>

    <para>Pragmas all take the form

<literal>{-# <replaceable>word</replaceable> ... #-}</literal>  

    where <replaceable>word</replaceable> indicates the type of
    pragma, and is followed optionally by information specific to that
    type of pragma.  Case is ignored in
    <replaceable>word</replaceable>.  The various values for
    <replaceable>word</replaceable> that GHC understands are described
    in the following sections; any pragma encountered with an
    unrecognised <replaceable>word</replaceable> is (silently)
    ignored.</para>

<sect2 id="inline-pragma">
<title>INLINE pragma

<indexterm><primary>INLINE pragma</primary></indexterm>
<indexterm><primary>pragma, INLINE</primary></indexterm></title>

<para>
GHC (with <option>-O</option>, as always) tries to inline (or &ldquo;unfold&rdquo;)
functions/values that are &ldquo;small enough,&rdquo; thus avoiding the call
overhead and possibly exposing other more-wonderful optimisations.
</para>

<para>
You will probably see these unfoldings (in Core syntax) in your
interface files.
</para>

<para>
Normally, if GHC decides a function is &ldquo;too expensive&rdquo; to inline, it
will not do so, nor will it export that unfolding for other modules to
use.
</para>

<para>
The sledgehammer you can bring to bear is the
<literal>INLINE</literal><indexterm><primary>INLINE pragma</primary></indexterm> pragma, used thusly:

<programlisting>
key_function :: Int -> String -> (Bool, Double)

#ifdef __GLASGOW_HASKELL__
{-# INLINE key_function #-}
#endif
</programlisting>

(You don't need to do the C pre-processor carry-on unless you're going
to stick the code through HBC&mdash;it doesn't like <literal>INLINE</literal> pragmas.)
</para>

<para>
The major effect of an <literal>INLINE</literal> pragma is to declare a function's
&ldquo;cost&rdquo; to be very low.  The normal unfolding machinery will then be
very keen to inline it.
</para>

<para>
An <literal>INLINE</literal> pragma for a function can be put anywhere its type
signature could be put.
</para>

<para>
<literal>INLINE</literal> pragmas are a particularly good idea for the
<literal>then</literal>/<literal>return</literal> (or <literal>bind</literal>/<literal>unit</literal>) functions in a monad.
For example, in GHC's own <literal>UniqueSupply</literal> monad code, we have:

<programlisting>
#ifdef __GLASGOW_HASKELL__
{-# INLINE thenUs #-}
{-# INLINE returnUs #-}
#endif
</programlisting>

</para>

</sect2>

<sect2 id="noinline-pragma">
<title>NOINLINE pragma
</title>

<indexterm><primary>NOINLINE pragma</primary></indexterm>
<indexterm><primary>pragma</primary><secondary>NOINLINE</secondary></indexterm>
<indexterm><primary>NOTINLINE pragma</primary></indexterm>
<indexterm><primary>pragma</primary><secondary>NOTINLINE</secondary></indexterm>

<para>
The <literal>NOINLINE</literal> pragma does exactly what you'd expect:
it stops the named function from being inlined by the compiler.  You
shouldn't ever need to do this, unless you're very cautious about code
size.
</para>

<para><literal>NOTINLINE</literal> is a synonym for
<literal>NOINLINE</literal> (<literal>NOTINLINE</literal> is specified
by Haskell 98 as the standard way to disable inlining, so it should be
used if you want your code to be portable).</para>

</sect2>

    <sect2 id="specialize-pragma">
      <title>SPECIALIZE pragma</title>

      <indexterm><primary>SPECIALIZE pragma</primary></indexterm>
      <indexterm><primary>pragma, SPECIALIZE</primary></indexterm>
      <indexterm><primary>overloading, death to</primary></indexterm>

      <para>(UK spelling also accepted.)  For key overloaded
      functions, you can create extra versions (NB: more code space)
      specialised to particular types.  Thus, if you have an
      overloaded function:</para>

<programlisting>
hammeredLookup :: Ord key => [(key, value)] -> key -> value
</programlisting>

      <para>If it is heavily used on lists with
      <literal>Widget</literal> keys, you could specialise it as
      follows:</para>

<programlisting>
{-# SPECIALIZE hammeredLookup :: [(Widget, value)] -> Widget -> value #-}
</programlisting>

      <para>To get very fancy, you can also specify a named function
      to use for the specialised value, as in:</para>

<programlisting>
{-# RULES hammeredLookup = blah #-}
</programlisting>

      <para>where <literal>blah</literal> is an implementation of
      <literal>hammerdLookup</literal> written specialy for
      <literal>Widget</literal> lookups.  It's <emphasis>Your
      Responsibility</emphasis> to make sure that
      <function>blah</function> really behaves as a specialised
      version of <function>hammeredLookup</function>!!!</para>

      <para>Note we use the <literal>RULE</literal> pragma here to
      indicate that <literal>hammeredLookup</literal> applied at a
      certain type should be replaced by <literal>blah</literal>.  See
      <xref linkend="rules"> for more information on
      <literal>RULES</literal>.</para>

      <para>An example in which using <literal>RULES</literal> for
      specialisation will Win Big:

<programlisting>
toDouble :: Real a => a -> Double
toDouble = fromRational . toRational

{-# SPECIALIZE toDouble :: Int -> Double = i2d #-}
i2d (I# i) = D# (int2Double# i) -- uses Glasgow prim-op directly
</programlisting>

      The <function>i2d</function> function is virtually one machine
      instruction; the default conversion&mdash;via an intermediate
      <literal>Rational</literal>&mdash;is obscenely expensive by
      comparison.</para>

      <para>A <literal>SPECIALIZE</literal> pragma for a function can
      be put anywhere its type signature could be put.</para>

    </sect2>

<sect2 id="specialize-instance-pragma">
<title>SPECIALIZE instance pragma
</title>

<para>
<indexterm><primary>SPECIALIZE pragma</primary></indexterm>
<indexterm><primary>overloading, death to</primary></indexterm>
Same idea, except for instance declarations.  For example:

<programlisting>
instance (Eq a) => Eq (Foo a) where { 
   {-# SPECIALIZE instance Eq (Foo [(Int, Bar)]) #-}
   ... usual stuff ...
 }
</programlisting>
The pragma must occur inside the <literal>where</literal> part
of the instance declaration.
</para>
<para>
Compatible with HBC, by the way, except perhaps in the placement
of the pragma.
</para>

</sect2>

<sect2 id="line-pragma">
<title>LINE pragma
</title>

<para>
<indexterm><primary>LINE pragma</primary></indexterm>
<indexterm><primary>pragma, LINE</primary></indexterm>
</para>

<para>
This pragma is similar to C's <literal>&num;line</literal> pragma, and is mainly for use in
automatically generated Haskell code.  It lets you specify the line
number and filename of the original code; for example
</para>

<para>

<programlisting>
{-# LINE 42 "Foo.vhs" #-}
</programlisting>

</para>

<para>
if you'd generated the current file from something called <filename>Foo.vhs</filename>
and this line corresponds to line 42 in the original.  GHC will adjust
its error messages to refer to the line/file named in the <literal>LINE</literal>
pragma.
</para>

</sect2>

<sect2 id="rules">
<title>RULES pragma</title>

<para>
The RULES pragma lets you specify rewrite rules.  It is described in
<xref LinkEnd="rewrite-rules">.
</para>

</sect2>

<sect2 id="deprecated-pragma">
<title>DEPRECATED pragma</title>

<para>
The DEPRECATED pragma lets you specify that a particular function, class, or type, is deprecated.  
There are two forms.  
</para>
<itemizedlist>
<listitem><para>
You can deprecate an entire module thus:</para>
<programlisting>
   module Wibble {-# DEPRECATED "Use Wobble instead" #-} where
     ...
</programlisting>
<para>
When you compile any module that import <literal>Wibble</literal>, GHC will print
the specified message.</para>
</listitem>

<listitem>
<para>
You can deprecate a function, class, or type, with the following top-level declaration:
</para>
<programlisting>
   {-# DEPRECATED f, C, T "Don't use these" #-}
</programlisting>
<para>
When you compile any module that imports and uses any of the specifed entities, 
GHC will print the specified message.
</para>
</listitem>
</itemizedlist>
<para>You can suppress the warnings with the flag <option>-fno-warn-deprecations</option>.</para>

</sect2>

</sect1>

<sect1 id="rewrite-rules">
<title>Rewrite rules

<indexterm><primary>RULES pagma</primary></indexterm>
<indexterm><primary>pragma, RULES</primary></indexterm>
<indexterm><primary>rewrite rules</primary></indexterm></title>

<para>
The programmer can specify rewrite rules as part of the source program
(in a pragma).  GHC applies these rewrite rules wherever it can.
</para>

<para>
Here is an example:

<programlisting>
  {-# RULES
        "map/map"       forall f g xs. map f (map g xs) = map (f.g) xs
  #-}
</programlisting>

</para>

<sect2>
<title>Syntax</title>

<para>
From a syntactic point of view:

<itemizedlist>
<listitem>

<para>
 Each rule has a name, enclosed in double quotes.  The name itself has
no significance at all.  It is only used when reporting how many times the rule fired.
</para>
</listitem>
<listitem>

<para>
 There may be zero or more rules in a <literal>RULES</literal> pragma.
</para>
</listitem>
<listitem>

<para>
 Layout applies in a <literal>RULES</literal> pragma.  Currently no new indentation level
is set, so you must lay out your rules starting in the same column as the
enclosing definitions.
</para>
</listitem>
<listitem>

<para>
 Each variable mentioned in a rule must either be in scope (e.g. <function>map</function>),
or bound by the <literal>forall</literal> (e.g. <function>f</function>, <function>g</function>, <function>xs</function>).  The variables bound by
the <literal>forall</literal> are called the <emphasis>pattern</emphasis> variables.  They are separated
by spaces, just like in a type <literal>forall</literal>.
</para>
</listitem>
<listitem>

<para>
 A pattern variable may optionally have a type signature.
If the type of the pattern variable is polymorphic, it <emphasis>must</emphasis> have a type signature.
For example, here is the <literal>foldr/build</literal> rule:

<programlisting>
"fold/build"  forall k z (g::forall b. (a->b->b) -> b -> b) .
              foldr k z (build g) = g k z
</programlisting>

Since <function>g</function> has a polymorphic type, it must have a type signature.

</para>
</listitem>
<listitem>

<para>
The left hand side of a rule must consist of a top-level variable applied
to arbitrary expressions.  For example, this is <emphasis>not</emphasis> OK:

<programlisting>
"wrong1"   forall e1 e2.  case True of { True -> e1; False -> e2 } = e1
"wrong2"   forall f.      f True = True
</programlisting>

In <literal>"wrong1"</literal>, the LHS is not an application; in <literal>"wrong2"</literal>, the LHS has a pattern variable
in the head.
</para>
</listitem>
<listitem>

<para>
 A rule does not need to be in the same module as (any of) the
variables it mentions, though of course they need to be in scope.
</para>
</listitem>
<listitem>

<para>
 Rules are automatically exported from a module, just as instance declarations are.
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2>
<title>Semantics</title>

<para>
From a semantic point of view:

<itemizedlist>
<listitem>

<para>
Rules are only applied if you use the <option>-O</option> flag.
</para>
</listitem>

<listitem>
<para>
 Rules are regarded as left-to-right rewrite rules.
When GHC finds an expression that is a substitution instance of the LHS
of a rule, it replaces the expression by the (appropriately-substituted) RHS.
By "a substitution instance" we mean that the LHS can be made equal to the
expression by substituting for the pattern variables.

</para>
</listitem>
<listitem>

<para>
 The LHS and RHS of a rule are typechecked, and must have the
same type.

</para>
</listitem>
<listitem>

<para>
 GHC makes absolutely no attempt to verify that the LHS and RHS
of a rule have the same meaning.  That is undecideable in general, and
infeasible in most interesting cases.  The responsibility is entirely the programmer's!

</para>
</listitem>
<listitem>

<para>
 GHC makes no attempt to make sure that the rules are confluent or
terminating.  For example:

<programlisting>
  "loop"        forall x,y.  f x y = f y x
</programlisting>

This rule will cause the compiler to go into an infinite loop.

</para>
</listitem>
<listitem>

<para>
 If more than one rule matches a call, GHC will choose one arbitrarily to apply.

</para>
</listitem>
<listitem>
<para>
 GHC currently uses a very simple, syntactic, matching algorithm
for matching a rule LHS with an expression.  It seeks a substitution
which makes the LHS and expression syntactically equal modulo alpha
conversion.  The pattern (rule), but not the expression, is eta-expanded if
necessary.  (Eta-expanding the epression can lead to laziness bugs.)
But not beta conversion (that's called higher-order matching).
</para>

<para>
Matching is carried out on GHC's intermediate language, which includes
type abstractions and applications.  So a rule only matches if the
types match too.  See <xref LinkEnd="rule-spec"> below.
</para>
</listitem>
<listitem>

<para>
 GHC keeps trying to apply the rules as it optimises the program.
For example, consider:

<programlisting>
  let s = map f
      t = map g
  in
  s (t xs)
</programlisting>

The expression <literal>s (t xs)</literal> does not match the rule <literal>"map/map"</literal>, but GHC
will substitute for <VarName>s</VarName> and <VarName>t</VarName>, giving an expression which does match.
If <VarName>s</VarName> or <VarName>t</VarName> was (a) used more than once, and (b) large or a redex, then it would
not be substituted, and the rule would not fire.

</para>
</listitem>
<listitem>

<para>
 In the earlier phases of compilation, GHC inlines <emphasis>nothing
that appears on the LHS of a rule</emphasis>, because once you have substituted
for something you can't match against it (given the simple minded
matching).  So if you write the rule

<programlisting>
        "map/map"       forall f,g.  map f . map g = map (f.g)
</programlisting>

this <emphasis>won't</emphasis> match the expression <literal>map f (map g xs)</literal>.
It will only match something written with explicit use of ".".
Well, not quite.  It <emphasis>will</emphasis> match the expression

<programlisting>
wibble f g xs
</programlisting>

where <function>wibble</function> is defined:

<programlisting>
wibble f g = map f . map g
</programlisting>

because <function>wibble</function> will be inlined (it's small).

Later on in compilation, GHC starts inlining even things on the
LHS of rules, but still leaves the rules enabled.  This inlining
policy is controlled by the per-simplification-pass flag <option>-finline-phase</option><emphasis>n</emphasis>.

</para>
</listitem>
<listitem>

<para>
 All rules are implicitly exported from the module, and are therefore
in force in any module that imports the module that defined the rule, directly
or indirectly.  (That is, if A imports B, which imports C, then C's rules are
in force when compiling A.)  The situation is very similar to that for instance
declarations.
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2>
<title>List fusion</title>

<para>
The RULES mechanism is used to implement fusion (deforestation) of common list functions.
If a "good consumer" consumes an intermediate list constructed by a "good producer", the
intermediate list should be eliminated entirely.
</para>

<para>
The following are good producers:

<itemizedlist>
<listitem>

<para>
 List comprehensions
</para>
</listitem>
<listitem>

<para>
 Enumerations of <literal>Int</literal> and <literal>Char</literal> (e.g. <literal>['a'..'z']</literal>).
</para>
</listitem>
<listitem>

<para>
 Explicit lists (e.g. <literal>[True, False]</literal>)
</para>
</listitem>
<listitem>

<para>
 The cons constructor (e.g <literal>3:4:[]</literal>)
</para>
</listitem>
<listitem>

<para>
 <function>++</function>
</para>
</listitem>

<listitem>
<para>
 <function>map</function>
</para>
</listitem>

<listitem>
<para>
 <function>filter</function>
</para>
</listitem>
<listitem>

<para>
 <function>iterate</function>, <function>repeat</function>
</para>
</listitem>
<listitem>

<para>
 <function>zip</function>, <function>zipWith</function>
</para>
</listitem>

</itemizedlist>

</para>

<para>
The following are good consumers:

<itemizedlist>
<listitem>

<para>
 List comprehensions
</para>
</listitem>
<listitem>

<para>
 <function>array</function> (on its second argument)
</para>
</listitem>
<listitem>

<para>
 <function>length</function>
</para>
</listitem>
<listitem>

<para>
 <function>++</function> (on its first argument)
</para>
</listitem>

<listitem>
<para>
 <function>foldr</function>
</para>
</listitem>

<listitem>
<para>
 <function>map</function>
</para>
</listitem>
<listitem>

<para>
 <function>filter</function>
</para>
</listitem>
<listitem>

<para>
 <function>concat</function>
</para>
</listitem>
<listitem>

<para>
 <function>unzip</function>, <function>unzip2</function>, <function>unzip3</function>, <function>unzip4</function>
</para>
</listitem>
<listitem>

<para>
 <function>zip</function>, <function>zipWith</function> (but on one argument only; if both are good producers, <function>zip</function>
will fuse with one but not the other)
</para>
</listitem>
<listitem>

<para>
 <function>partition</function>
</para>
</listitem>
<listitem>

<para>
 <function>head</function>
</para>
</listitem>
<listitem>

<para>
 <function>and</function>, <function>or</function>, <function>any</function>, <function>all</function>
</para>
</listitem>
<listitem>

<para>
 <function>sequence&lowbar;</function>
</para>
</listitem>
<listitem>

<para>
 <function>msum</function>
</para>
</listitem>
<listitem>

<para>
 <function>sortBy</function>
</para>
</listitem>

</itemizedlist>

</para>

<para>
So, for example, the following should generate no intermediate lists:

<programlisting>
array (1,10) [(i,i*i) | i &#60;- map (+ 1) [0..9]]
</programlisting>

</para>

<para>
This list could readily be extended; if there are Prelude functions that you use
a lot which are not included, please tell us.
</para>

<para>
If you want to write your own good consumers or producers, look at the
Prelude definitions of the above functions to see how to do so.
</para>

</sect2>

<sect2 id="rule-spec">
<title>Specialisation
</title>

<para>
Rewrite rules can be used to get the same effect as a feature
present in earlier version of GHC:

<programlisting>
  {-# SPECIALIZE fromIntegral :: Int8 -> Int16 = int8ToInt16 #-}
</programlisting>

This told GHC to use <function>int8ToInt16</function> instead of <function>fromIntegral</function> whenever
the latter was called with type <literal>Int8 -&gt; Int16</literal>.  That is, rather than
specialising the original definition of <function>fromIntegral</function> the programmer is
promising that it is safe to use <function>int8ToInt16</function> instead.
</para>

<para>
This feature is no longer in GHC.  But rewrite rules let you do the
same thing:

<programlisting>
{-# RULES
  "fromIntegral/Int8/Int16" fromIntegral = int8ToInt16
#-}
</programlisting>

This slightly odd-looking rule instructs GHC to replace <function>fromIntegral</function>
by <function>int8ToInt16</function> <emphasis>whenever the types match</emphasis>.  Speaking more operationally,
GHC adds the type and dictionary applications to get the typed rule

<programlisting>
forall (d1::Integral Int8) (d2::Num Int16) .
        fromIntegral Int8 Int16 d1 d2 = int8ToInt16
</programlisting>

What is more,
this rule does not need to be in the same file as fromIntegral,
unlike the <literal>SPECIALISE</literal> pragmas which currently do (so that they
have an original definition available to specialise).
</para>

</sect2>

<sect2>
<title>Controlling what's going on</title>

<para>

<itemizedlist>
<listitem>

<para>
 Use <option>-ddump-rules</option> to see what transformation rules GHC is using.
</para>
</listitem>
<listitem>

<para>
 Use <option>-ddump-simpl-stats</option> to see what rules are being fired.
If you add <option>-dppr-debug</option> you get a more detailed listing.
</para>
</listitem>
<listitem>

<para>
 The defintion of (say) <function>build</function> in <FileName>PrelBase.lhs</FileName> looks llike this:

<programlisting>
        build   :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
        {-# INLINE build #-}
        build g = g (:) []
</programlisting>

Notice the <literal>INLINE</literal>!  That prevents <literal>(:)</literal> from being inlined when compiling
<literal>PrelBase</literal>, so that an importing module will &ldquo;see&rdquo; the <literal>(:)</literal>, and can
match it on the LHS of a rule.  <literal>INLINE</literal> prevents any inlining happening
in the RHS of the <literal>INLINE</literal> thing.  I regret the delicacy of this.

</para>
</listitem>
<listitem>

<para>
 In <filename>ghc/lib/std/PrelBase.lhs</filename> look at the rules for <function>map</function> to
see how to write rules that will do fusion and yet give an efficient
program even if fusion doesn't happen.  More rules in <filename>PrelList.lhs</filename>.
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

</sect1>

<sect1 id="generic-classes">
<title>Generic classes</title>

    <para>(Note: support for generic classes is currently broken in
    GHC 5.02).</para>

<para>
The ideas behind this extension are described in detail in "Derivable type classes",
Ralf Hinze and Simon Peyton Jones, Haskell Workshop, Montreal Sept 2000, pp94-105.
An example will give the idea:
</para>

<programlisting>
  import Generics

  class Bin a where
    toBin   :: a -> [Int]
    fromBin :: [Int] -> (a, [Int])
  
    toBin {| Unit |}    Unit	  = []
    toBin {| a :+: b |} (Inl x)   = 0 : toBin x
    toBin {| a :+: b |} (Inr y)   = 1 : toBin y
    toBin {| a :*: b |} (x :*: y) = toBin x ++ toBin y
  
    fromBin {| Unit |}    bs      = (Unit, bs)
    fromBin {| a :+: b |} (0:bs)  = (Inl x, bs')    where (x,bs') = fromBin bs
    fromBin {| a :+: b |} (1:bs)  = (Inr y, bs')    where (y,bs') = fromBin bs
    fromBin {| a :*: b |} bs	  = (x :*: y, bs'') where (x,bs' ) = fromBin bs
							  (y,bs'') = fromBin bs'
</programlisting>
<para>
This class declaration explains how <literal>toBin</literal> and <literal>fromBin</literal>
work for arbitrary data types.  They do so by giving cases for unit, product, and sum,
which are defined thus in the library module <literal>Generics</literal>:
</para>
<programlisting>
  data Unit    = Unit
  data a :+: b = Inl a | Inr b
  data a :*: b = a :*: b
</programlisting>
<para>
Now you can make a data type into an instance of Bin like this:
<programlisting>
  instance (Bin a, Bin b) => Bin (a,b)
  instance Bin a => Bin [a]
</programlisting>
That is, just leave off the "where" clasuse.  Of course, you can put in the
where clause and over-ride whichever methods you please.
</para>

    <sect2>
      <title> Using generics </title>
      <para>To use generics you need to</para>
      <itemizedlist>
	<listitem>
	  <para>Use the flags <option>-fglasgow-exts</option> (to enable the extra syntax), 
                <option>-fgenerics</option> (to generate extra per-data-type code),
                and <option>-package lang</option> (to make the <literal>Generics</literal> library
                available.  </para>
	</listitem>
	<listitem>
	  <para>Import the module <literal>Generics</literal> from the
          <literal>lang</literal> package.  This import brings into
          scope the data types <literal>Unit</literal>,
          <literal>:*:</literal>, and <literal>:+:</literal>.  (You
          don't need this import if you don't mention these types
          explicitly; for example, if you are simply giving instance
          declarations.)</para>
	</listitem>
      </itemizedlist>
    </sect2>

<sect2> <title> Changes wrt the paper </title>
<para>
Note that the type constructors <literal>:+:</literal> and <literal>:*:</literal> 
can be written infix (indeed, you can now use
any operator starting in a colon as an infix type constructor).  Also note that
the type constructors are not exactly as in the paper (Unit instead of 1, etc).
Finally, note that the syntax of the type patterns in the class declaration
uses "<literal>{|</literal>" and "<literal>|}</literal>" brackets; curly braces
alone would ambiguous when they appear on right hand sides (an extension we 
anticipate wanting).
</para>
</sect2>

<sect2> <title>Terminology and restrictions</title>
<para>
Terminology.  A "generic default method" in a class declaration
is one that is defined using type patterns as above.
A "polymorphic default method" is a default method defined as in Haskell 98.
A "generic class declaration" is a class declaration with at least one
generic default method.
</para>

<para>
Restrictions:
<itemizedlist>
<listitem>
<para>
Alas, we do not yet implement the stuff about constructor names and 
field labels.
</para>
</listitem>

<listitem>
<para>
A generic class can have only one parameter; you can't have a generic
multi-parameter class.
</para>
</listitem>

<listitem>
<para>
A default method must be defined entirely using type patterns, or entirely
without.  So this is illegal:
<programlisting>
  class Foo a where
    op :: a -> (a, Bool)
    op {| Unit |} Unit = (Unit, True)
    op x               = (x,    False)
</programlisting>
However it is perfectly OK for some methods of a generic class to have 
generic default methods and others to have polymorphic default methods.
</para>
</listitem>

<listitem>
<para>
The type variable(s) in the type pattern for a generic method declaration
scope over the right hand side.  So this is legal (note the use of the type variable ``p'' in a type signature on the right hand side:
<programlisting>
  class Foo a where
    op :: a -> Bool
    op {| p :*: q |} (x :*: y) = op (x :: p)
    ...
</programlisting>
</para>
</listitem>

<listitem>
<para>
The type patterns in a generic default method must take one of the forms:
<programlisting>
       a :+: b
       a :*: b
       Unit
</programlisting>
where "a" and "b" are type variables.  Furthermore, all the type patterns for
a single type constructor (<literal>:*:</literal>, say) must be identical; they
must use the same type variables.  So this is illegal:
<programlisting>
  class Foo a where
    op :: a -> Bool
    op {| a :+: b |} (Inl x) = True
    op {| p :+: q |} (Inr y) = False
</programlisting>
The type patterns must be identical, even in equations for different methods of the class.
So this too is illegal:
<programlisting>
  class Foo a where
    op1 :: a -> Bool
    op1 {| a :*: b |} (x :*: y) = True

    op2 :: a -> Bool
    op2 {| p :*: q |} (x :*: y) = False
</programlisting>
(The reason for this restriction is that we gather all the equations for a particular type consructor
into a single generic instance declaration.)
</para>
</listitem>

<listitem>
<para>
A generic method declaration must give a case for each of the three type constructors.
</para>
</listitem>

<listitem>
<para>
The type for a generic method can be built only from:
  <itemizedlist>
  <listitem> <para> Function arrows </para> </listitem>
  <listitem> <para> Type variables </para> </listitem>
  <listitem> <para> Tuples </para> </listitem>
  <listitem> <para> Arbitrary types not involving type variables </para> </listitem>
  </itemizedlist>
Here are some example type signatures for generic methods:
<programlisting>
    op1 :: a -> Bool
    op2 :: Bool -> (a,Bool)
    op3 :: [Int] -> a -> a
    op4 :: [a] -> Bool
</programlisting>
Here, op1, op2, op3 are OK, but op4 is rejected, because it has a type variable
inside a list.  
</para>
<para>
This restriction is an implementation restriction: we just havn't got around to
implementing the necessary bidirectional maps over arbitrary type constructors.
It would be relatively easy to add specific type constructors, such as Maybe and list,
to the ones that are allowed.</para>
</listitem>

<listitem>
<para>
In an instance declaration for a generic class, the idea is that the compiler
will fill in the methods for you, based on the generic templates.  However it can only
do so if
  <itemizedlist>
  <listitem>
  <para>
  The instance type is simple (a type constructor applied to type variables, as in Haskell 98).
  </para>
  </listitem>
  <listitem>
  <para>
  No constructor of the instance type has unboxed fields.
  </para>
  </listitem>
  </itemizedlist>
(Of course, these things can only arise if you are already using GHC extensions.)
However, you can still give an instance declarations for types which break these rules,
provided you give explicit code to override any generic default methods.
</para>
</listitem>

</itemizedlist>
</para>

<para>
The option <option>-ddump-deriv</option> dumps incomprehensible stuff giving details of 
what the compiler does with generic declarations.
</para>

</sect2>

<sect2> <title> Another example </title>
<para>
Just to finish with, here's another example I rather like:
<programlisting>
  class Tag a where
    nCons :: a -> Int
    nCons {| Unit |}    _ = 1
    nCons {| a :*: b |} _ = 1
    nCons {| a :+: b |} _ = nCons (bot::a) + nCons (bot::b)
  
    tag :: a -> Int
    tag {| Unit |}    _       = 1
    tag {| a :*: b |} _       = 1   
    tag {| a :+: b |} (Inl x) = tag x
    tag {| a :+: b |} (Inr y) = nCons (bot::a) + tag y
</programlisting>
</para>
</sect2>
</sect1>

<sect1 id="newtype-deriving">
<title>Generalised derived instances for newtypes</title>

<para>
When you define an abstract type using <literal>newtype</literal>, you may want
the new type to inherit some instances from its representation. In
Haskell 98, you can inherit instances of <literal>Eq</literal>, <literal>Ord</literal>,
<literal>Enum</literal> and <literal>Bounded</literal> by deriving them, but for any
other classes you have to write an explicit instance declaration. For
example, if you define

<programlisting> 
  newtype Dollars = Dollars Int 
</programlisting> 

and you want to use arithmetic on <literal>Dollars</literal>, you have to
explicitly define an instance of <literal>Num</literal>:

<programlisting> 
  instance Num Dollars where
    Dollars a + Dollars b = Dollars (a+b)
    ...
</programlisting>
All the instance does is apply and remove the <literal>newtype</literal>
constructor. It is particularly galling that, since the constructor
doesn't appear at run-time, this instance declaration defines a
dictionary which is <emphasis>wholly equivalent</emphasis> to the <literal>Int</literal>
dictionary, only slower!
</para>

<sect2> <title> Generalising the deriving clause </title>
<para>
GHC now permits such instances to be derived instead, so one can write 
<programlisting> 
  newtype Dollars = Dollars Int deriving (Eq,Show,Num)
</programlisting> 

and the implementation uses the <emphasis>same</emphasis> <literal>Num</literal> dictionary
for <literal>Dollars</literal> as for <literal>Int</literal>. Notionally, the compiler
derives an instance declaration of the form

<programlisting> 
  instance Num Int => Num Dollars
</programlisting> 

which just adds or removes the <literal>newtype</literal> constructor according to the type.
</para>
<para>

We can also derive instances of constructor classes in a similar
way. For example, suppose we have implemented state and failure monad
transformers, such that

<programlisting> 
  instance Monad m => Monad (State s m) 
  instance Monad m => Monad (Failure m)
</programlisting> 
In Haskell 98, we can define a parsing monad by 
<programlisting> 
  type Parser tok m a = State [tok] (Failure m) a
</programlisting> 

which is automatically a monad thanks to the instance declarations
above. With the extension, we can make the parser type abstract,
without needing to write an instance of class <literal>Monad</literal>, via

<programlisting> 
  newtype Parser tok m a = Parser (State [tok] (Failure m) a)
                         deriving Monad
</programlisting>
In this case the derived instance declaration is of the form 
<programlisting> 
  instance Monad (State [tok] (Failure m)) => Monad (Parser tok m) 
</programlisting> 

Notice that, since <literal>Monad</literal> is a constructor class, the
instance is a <emphasis>partial application</emphasis> of the new type, not the
entire left hand side. We can imagine that the type declaration is
``eta-converted'' to generate the context of the instance
declaration.
</para>
<para>

We can even derive instances of multi-parameter classes, provided the
newtype is the last class parameter. In this case, a ``partial
application'' of the class appears in the <literal>deriving</literal>
clause. For example, given the class

<programlisting> 
  class StateMonad s m | m -> s where ... 
  instance Monad m => StateMonad s (State s m) where ... 
</programlisting> 
then we can derive an instance of <literal>StateMonad</literal> for <literal>Parser</literal>s by 
<programlisting> 
  newtype Parser tok m a = Parser (State [tok] (Failure m) a)
                         deriving (Monad, StateMonad [tok])
</programlisting>

The derived instance is obtained by completing the application of the
class to the new type:

<programlisting> 
  instance StateMonad [tok] (State [tok] (Failure m)) =>
           StateMonad [tok] (Parser tok m)
</programlisting>
</para>
<para>

As a result of this extension, all derived instances in newtype
declarations are treated uniformly (and implemented just by reusing
the dictionary for the representation type), <emphasis>except</emphasis>
<literal>Show</literal> and <literal>Read</literal>, which really behave differently for
the newtype and its representation.
</para>
</sect2>

<sect2> <title> A more precise specification </title>
<para>
Derived instance declarations are constructed as follows. Consider the
declaration (after expansion of any type synonyms)

<programlisting> 
  newtype T v1...vn = T' (S t1...tk vk+1...vn) deriving (c1...cm) 
</programlisting> 

where <literal>S</literal> is a type constructor, <literal>t1...tk</literal> are 
types,
<literal>vk+1...vn</literal> are type variables which do not occur in any of
the <literal>ti</literal>, and the <literal>ci</literal> are partial applications of
classes of the form <literal>C t1'...tj'</literal>.  The derived instance
declarations are, for each <literal>ci</literal>,

<programlisting> 
  instance ci (S t1...tk vk+1...v) => ci (T v1...vp)
</programlisting>
where <literal>p</literal> is chosen so that <literal>T v1...vp</literal> is of the 
right <emphasis>kind</emphasis> for the last parameter of class <literal>Ci</literal>.
</para>
<para>

As an example which does <emphasis>not</emphasis> work, consider 
<programlisting> 
  newtype NonMonad m s = NonMonad (State s m s) deriving Monad 
</programlisting> 
Here we cannot derive the instance 
<programlisting> 
  instance Monad (State s m) => Monad (NonMonad m) 
</programlisting> 

because the type variable <literal>s</literal> occurs in <literal>State s m</literal>,
and so cannot be "eta-converted" away. It is a good thing that this
<literal>deriving</literal> clause is rejected, because <literal>NonMonad m</literal> is
not, in fact, a monad --- for the same reason. Try defining
<literal>>>=</literal> with the correct type: you won't be able to.
</para>
<para>

Notice also that the <emphasis>order</emphasis> of class parameters becomes
important, since we can only derive instances for the last one. If the
<literal>StateMonad</literal> class above were instead defined as

<programlisting> 
  class StateMonad m s | m -> s where ... 
</programlisting>

then we would not have been able to derive an instance for the
<literal>Parser</literal> type above. We hypothesise that multi-parameter
classes usually have one "main" parameter for which deriving new
instances is most interesting.
</para>
</sect2>
</sect1>



<!-- Emacs stuff:
     ;;; Local Variables: ***
     ;;; mode: sgml ***
     ;;; sgml-parent-document: ("users_guide.sgml" "book" "chapter" "sect1") ***
     ;;; End: ***
 -->
