{-# GHC_PRAGMA INTERFACE VERSION 6 #-}
interface Prelude where
import PreludeArray((!), (//), Array, Assoc, _ByteArray, _arrEleBottom, accum, accumArray, amap, array, assocs, bounds, elems, indices, ixmap, listArray)
import PreludeBuiltin(Bin, Char(..), Int(..), Integer(..), List(..), Tuple0, Tuple2, Tuple3, Tuple4, Tuple5, Tuple6, Tuple7, _Addr(..), _RealWorld(..), _State(..))
import PreludeComplex(Complex, cis, conjugate, imagPart, magnitude, mkPolar, phase, polar, realPart)
import PreludeCore(Bool(..), Eq(..), Fractional(..), Integral(..), Ix(..), Num(..), Ord(..), Real(..), RealFloat(..), RealFrac(..), Text(..), _rangeComplaint_Ix_Int, _readList, _showList, _showRational)
import PreludeGlaST(_MutableArray, _freezeArray, _newArray)
import PreludeIO(interact13) renaming (interact13 to interact)
import PreludeIOError(IOError13)
import PreludeList((!!), (++), (\\), all, and, any, break, concat, cycle, drop, dropWhile, elem, filter, foldl1, foldr1, genericLength, head, init, iterate, last, length, lines, map, maximum, minimum, notElem, nub, null, or, partition, product, products, repeat, reverse, scanl, scanl1, scanr, scanr1, span, splitAt, sum, sums, tail, take, takeWhile, transpose, unlines, unwords, unzip, unzip3, unzip4, unzip5, unzip6, unzip7, words, zip, zip3, zip4, zip5, zip6, zip7, zipWith, zipWith3, zipWith4, zipWith5, zipWith6, zipWith7)
import PreludeMonadicIO((>>), (>>=), Either, accumulate, either, fail, failWith, handle, return, sequence, try)
import PreludePS(_PackedString, _appendPS, _breakPS, _byteArrayToPS, _concatPS, _consPS, _dropPS, _dropWhilePS, _filterPS, _foldlPS, _foldrPS, _headPS, _indexPS, _lengthPS, _linesPS, _mapPS, _nilPS, _nullPS, _packCBytes, _packCString, _packString, _psToByteArray, _putPS, _reversePS, _spanPS, _splitAtPS, _substrPS, _tailPS, _takePS, _takeWhilePS, _unpackPS, _wordsPS)
import PreludePrimIO(_MVar)
import PreludeRatio((%), Ratio(..), approxRational, denominator, numerator)
import PreludeReadTextIO(getChar, hGetChar, hGetContents, hLookAhead, hReady, readFile13) renaming (readFile13 to readFile)
import PreludeStdIO(BufferMode, IOMode, Maybe, SeekMode, _Handle, hClose, hFileSize, hFlush, hGetPosn, hIsBlockBuffered, hIsClosed, hIsEOF, hIsLineBuffered, hIsNotBuffered, hIsOpen, hIsReadable, hIsSeekable, hIsWritable, hSeek, hSetBuffering, hSetPosn, isEOF, openFile, stderr13, stdin13, stdout13) renaming (stderr13 to stderr, stdin13 to stdin, stdout13 to stdout)
import PreludeText(_readRational, _showDigit, _showHex, _showRadix, lex, read, readDec, readFloat, readLitChar, readParen, readSigned, reads, show, showChar, showFloat, showInt, showLitChar, showParen, showSigned, showSpace__, showString, shows)
import PreludeWriteTextIO(appendFile13, hPutChar, hPutStr, hPutText, print13, putChar, putStr, putText, writeFile13) renaming (appendFile13 to appendFile, print13 to print, writeFile13 to writeFile)
import Stdio(_FILE)
infixr 1 >>
infixr 1 >>=
($) :: (a -> b) -> a -> b
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "SL" _F_ _IF_ARGS_ 2 2 XX 2 _/\_ u0 u1 -> \ (u2 :: u0 -> u1) (u3 :: u0) -> _APP_  u2 [ u3 ] _N_ #-}
(&&) :: Bool -> Bool -> Bool
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "EL" _F_ _ALWAYS_ \ (u0 :: Bool) (u1 :: Bool) -> case u0 of { _ALG_ True  -> u1; False  -> _!_ False [] []; _NO_DEFLT_ } _N_ #-}
(.) :: (a -> c) -> (b -> a) -> b -> c
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "SLL" _F_ _ALWAYS_ _/\_ u0 u1 u2 -> \ (u3 :: u0 -> u2) (u4 :: u1 -> u0) (u5 :: u1) -> let {(u6 :: u0) = _APP_  u4 [ u5 ]} in _APP_  u3 [ u6 ] _N_ #-}
(^) :: (Num b, Integral a) => b -> a -> b
	{-# GHC_PRAGMA _A_ 2 _U_ 2222 _N_ _S_ "LU(U(LU(U(U(SL)LLLLLLL)LLLL)L)LLLLLLLLLLL)" _N_ _SPECIALISE_ [ Int, Double ] 2 { _A_ 2 _U_ 21 _N_ _S_ "LU(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Int, Int ] 2 { _A_ 2 _U_ 21 _N_ _S_ "LU(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Int, Integer ] 2 { _A_ 2 _U_ 21 _N_ _S_ "LU(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Int, (Ratio Integer) ] 2 { _A_ 2 _U_ 21 _N_ _S_ "LU(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Int, (Complex Double) ] 2 { _A_ 2 _U_ 21 _N_ _S_ "LU(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer, Integer ] 2 { _A_ 2 _U_ 21 _N_ _S_ "LU(PPP)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
(^^) :: (Fractional b, Integral a) => b -> a -> b
	{-# GHC_PRAGMA _A_ 2 _U_ 2222 _N_ _S_ "LU(LU(U(LLLSLLLL)LLL)LLLLLLLLLL)" _N_ _SPECIALISE_ [ Int, Double ] 2 { _A_ 2 _U_ 21 _N_ _S_ "LU(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Int, (Ratio Integer) ] 2 { _A_ 2 _U_ 21 _N_ _S_ "LU(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Int, (Complex Double) ] 2 { _A_ 2 _U_ 21 _N_ _S_ "LU(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
appendBin :: Bin -> Bin -> Bin
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ _!_ _N_ _N_ #-}
asTypeOf :: a -> a -> a
	{-# GHC_PRAGMA _A_ 2 _U_ 10 _N_ _N_ _F_ _IF_ARGS_ 1 0 X 1 _/\_ u0 -> _TYAPP_  _TYAPP_  _ORIG_ Prelude const { u0 } { u0 } _N_ #-}
atan2 :: RealFloat a => a -> a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(U(U(AU(U(ALAASAAA)AAAA)A)AAAAAA)U(U(SLAA)LAAAAAAAAAALAAAAAA)AAAAAAAA)" {_A_ 5 _U_ 2212222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Double ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
chr :: Int -> Char
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Int#) -> case _#_ chr# [] [u0] of { _PRIM_ (u1 :: Char#) -> _!_ C# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Int) -> case u0 of { _ALG_ I# (u1 :: Int#) -> case _#_ chr# [] [u1] of { _PRIM_ (u2 :: Char#) -> _!_ C# [] [u2] }; _NO_DEFLT_ } _N_ #-}
const :: b -> a -> b
	{-# GHC_PRAGMA _A_ 2 _U_ 10 _N_ _S_ "SA" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 2 1 X 1 _/\_ u0 u1 -> \ (u2 :: u1) -> u2 _N_} _F_ _IF_ARGS_ 2 2 XX 1 _/\_ u0 u1 -> \ (u2 :: u1) (u3 :: u0) -> u2 _N_ #-}
curry :: ((a, b) -> c) -> a -> b -> c
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _S_ "SLL" _F_ _IF_ARGS_ 3 3 XXX 6 _/\_ u0 u1 u2 -> \ (u3 :: (u0, u1) -> u2) (u4 :: u0) (u5 :: u1) -> let {(u6 :: (u0, u1)) = _!_ _TUP_2 [u0, u1] [u4, u5]} in _APP_  u3 [ u6 ] _N_ #-}
flip :: (b -> a -> c) -> a -> b -> c
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _S_ "SLL" _F_ _IF_ARGS_ 3 3 XXX 3 _/\_ u0 u1 u2 -> \ (u3 :: u1 -> u0 -> u2) (u4 :: u0) (u5 :: u1) -> _APP_  u3 [ u5, u4 ] _N_ #-}
fromIntegral :: (Integral a, Num b) => a -> b
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "LU(AAAAAAAASA)L" {_A_ 3 _U_ 112 _N_ _N_ _F_ _IF_ARGS_ 2 3 CXX 6 _/\_ u0 u1 -> \ (u2 :: {{Integral u0}}) (u3 :: Integer -> u1) (u4 :: u0) -> let {(uh :: Integer) = case u2 of { _ALG_ _TUP_12 (u5 :: {{Real u0}}) (u6 :: {{Ix u0}}) (u7 :: u0 -> u0 -> u0) (u8 :: u0 -> u0 -> u0) (u9 :: u0 -> u0 -> u0) (ua :: u0 -> u0 -> u0) (ub :: u0 -> u0 -> (u0, u0)) (uc :: u0 -> u0 -> (u0, u0)) (ud :: u0 -> Bool) (ue :: u0 -> Bool) (uf :: u0 -> Integer) (ug :: u0 -> Int) -> _APP_  uf [ u4 ]; _NO_DEFLT_ }} in _APP_  u3 [ uh ] _N_} _F_ _IF_ARGS_ 2 3 CCX 7 _/\_ u0 u1 -> \ (u2 :: {{Integral u0}}) (u3 :: {{Num u1}}) (u4 :: u0) -> let {(uh :: Integer) = case u2 of { _ALG_ _TUP_12 (u5 :: {{Real u0}}) (u6 :: {{Ix u0}}) (u7 :: u0 -> u0 -> u0) (u8 :: u0 -> u0 -> u0) (u9 :: u0 -> u0 -> u0) (ua :: u0 -> u0 -> u0) (ub :: u0 -> u0 -> (u0, u0)) (uc :: u0 -> u0 -> (u0, u0)) (ud :: u0 -> Bool) (ue :: u0 -> Bool) (uf :: u0 -> Integer) (ug :: u0 -> Int) -> _APP_  uf [ u4 ]; _NO_DEFLT_ }} in case u3 of { _ALG_ _TUP_10 (ui :: {{Eq u1}}) (uj :: {{Text u1}}) (uk :: u1 -> u1 -> u1) (ul :: u1 -> u1 -> u1) (um :: u1 -> u1 -> u1) (un :: u1 -> u1) (uo :: u1 -> u1) (up :: u1 -> u1) (uq :: Integer -> u1) (ur :: Int -> u1) -> _APP_  uq [ uh ]; _NO_DEFLT_ } _SPECIALISE_ [ Int, Double ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Int#) -> case _#_ int2Double# [] [u0] of { _PRIM_ (u1 :: Double#) -> _!_ D# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Int) -> case u0 of { _ALG_ I# (u1 :: Int#) -> case _#_ int2Double# [] [u1] of { _PRIM_ (u2 :: Double#) -> _!_ D# [] [u2] }; _NO_DEFLT_ } _N_ }, [ Int, Float ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Int#) -> case _#_ int2Float# [] [u0] of { _PRIM_ (u1 :: Float#) -> _!_ F# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Int) -> case u0 of { _ALG_ I# (u1 :: Int#) -> case _#_ int2Float# [] [u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] }; _NO_DEFLT_ } _N_ }, [ Int, Int ] 2 { _A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _TYAPP_  _ORIG_ Prelude id { Int } _N_ }, [ Int, Integer ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 1 \ (u0 :: Int#) -> _#_ int2Integer# [] [u0] _N_} _F_ _IF_ARGS_ 0 1 C 2 \ (u0 :: Int) -> case u0 of { _ALG_ I# (u1 :: Int#) -> _#_ int2Integer# [] [u1]; _NO_DEFLT_ } _N_ }, [ Int, (Ratio Integer) ] 2 { _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ }, [ Integer, Double ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(PPP)" {_A_ 3 _U_ 222 _N_ _N_ _F_ _IF_ARGS_ 0 3 XXX 3 \ (u0 :: Int#) (u1 :: Int#) (u2 :: ByteArray#) -> case _#_ encodeDouble# [] [u0, u1, u2, 0#] of { _PRIM_ (u3 :: Double#) -> _!_ D# [] [u3] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Integer) -> case u0 of { _ALG_ J# (u1 :: Int#) (u2 :: Int#) (u3 :: ByteArray#) -> case _#_ encodeDouble# [] [u1, u2, u3, 0#] of { _PRIM_ (u4 :: Double#) -> _!_ D# [] [u4] }; _NO_DEFLT_ } _N_ }, [ Integer, Float ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(PPP)" {_A_ 3 _U_ 222 _N_ _N_ _F_ _IF_ARGS_ 0 3 XXX 3 \ (u0 :: Int#) (u1 :: Int#) (u2 :: ByteArray#) -> case _#_ encodeFloat# [] [u0, u1, u2, 0#] of { _PRIM_ (u3 :: Float#) -> _!_ F# [] [u3] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Integer) -> case u0 of { _ALG_ J# (u1 :: Int#) (u2 :: Int#) (u3 :: ByteArray#) -> case _#_ encodeFloat# [] [u1, u2, u3, 0#] of { _PRIM_ (u4 :: Float#) -> _!_ F# [] [u4] }; _NO_DEFLT_ } _N_ }, [ Integer, Int ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(PPP)" {_A_ 3 _U_ 222 _N_ _N_ _F_ _IF_ARGS_ 0 3 XXX 3 \ (u0 :: Int#) (u1 :: Int#) (u2 :: ByteArray#) -> case _#_ integer2Int# [] [u0, u1, u2] of { _PRIM_ (u3 :: Int#) -> _!_ I# [] [u3] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Integer) -> case u0 of { _ALG_ J# (u1 :: Int#) (u2 :: Int#) (u3 :: ByteArray#) -> case _#_ integer2Int# [] [u1, u2, u3] of { _PRIM_ (u4 :: Int#) -> _!_ I# [] [u4] }; _NO_DEFLT_ } _N_ }, [ Integer, Integer ] 2 { _A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _TYAPP_  _ORIG_ Prelude id { Integer } _N_ }, [ Integer, (Ratio Integer) ] 2 { _A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Integer) -> _!_ (:%) [Integer] [u0, _SPEC_ _ORIG_ PreludeCore __i1 [ (Integer) ]] _N_ } #-}
fromRealFrac :: (RealFrac a, Fractional b) => a -> b
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "LU(AAAS)L" {_A_ 3 _U_ 112 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Double, Double ] 2 { _A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _TYAPP_  _ORIG_ Prelude id { Double } _N_ }, [ Double, Float ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Double#) -> case _#_ double2Float# [] [u0] of { _PRIM_ (u1 :: Float#) -> _!_ F# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Double) -> case u0 of { _ALG_ D# (u1 :: Double#) -> case _#_ double2Float# [] [u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] }; _NO_DEFLT_ } _N_ }, [ Double, (Ratio Integer) ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Float, Double ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Float#) -> case _#_ float2Double# [] [u0] of { _PRIM_ (u1 :: Double#) -> _!_ D# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Float) -> case u0 of { _ALG_ F# (u1 :: Float#) -> case _#_ float2Double# [] [u1] of { _PRIM_ (u2 :: Double#) -> _!_ D# [] [u2] }; _NO_DEFLT_ } _N_ }, [ Float, Float ] 2 { _A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _TYAPP_  _ORIG_ Prelude id { Float } _N_ }, [ Float, (Ratio Integer) ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Ratio Integer), Double ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(U(PPP)U(PPP))" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Ratio Integer), Float ] 2 { _A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Fractional fromRational (Float) _N_ }, [ (Ratio Integer), (Ratio Integer) ] 2 { _A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _TYAPP_  _ORIG_ Prelude id { (Ratio Integer) } _N_ } #-}
fst :: (b, a) -> b
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(SA)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 2 1 X 1 _/\_ u0 u1 -> \ (u2 :: u1) -> u2 _N_} _F_ _IF_ARGS_ 2 1 C 2 _/\_ u0 u1 -> \ (u2 :: (u1, u0)) -> case u2 of { _ALG_ _TUP_2 (u3 :: u1) (u4 :: u0) -> u3; _NO_DEFLT_ } _N_ #-}
gcd :: Integral a => a -> a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(U(U(U(SA)AAAAALAAL)AA)AALAAAAAAAA)" {_A_ 4 _U_ 222222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(PPP)U(PPP)" {_A_ 4 _U_ 2221 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
id :: a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0) -> u1 _N_ #-}
ioToPrimIO :: (_State _RealWorld -> (Either IOError13 a, _State _RealWorld)) -> _State _RealWorld -> (a, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "SL" _N_ _N_ #-}
isAlpha :: Char -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
isAlphanum :: Char -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
isAscii :: Char -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 2 \ (u0 :: Char#) -> case _#_ ord# [] [u0] of { _PRIM_ (u1 :: Int#) -> _#_ ltInt# [] [u1, 128#] } _N_} _F_ _IF_ARGS_ 0 1 C 3 \ (u0 :: Char) -> case u0 of { _ALG_ C# (u1 :: Char#) -> case _#_ ord# [] [u1] of { _PRIM_ (u2 :: Int#) -> _#_ ltInt# [] [u2, 128#] }; _NO_DEFLT_ } _N_ #-}
isControl :: Char -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
isDigit :: Char -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
isLower :: Char -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
isNullBin :: Bin -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ _!_ _N_ _N_ #-}
isPrint :: Char -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
isSpace :: Char -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 1 _N_ _N_ _N_ _N_} _N_ _N_ #-}
isUpper :: Char -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
lcm :: Integral a => a -> a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(U(U(U(SA)AAALALAAL)AA)ALLAAAAAAAA)" {_A_ 3 _U_ 12222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int ] 1 { _A_ 2 _U_ 11 _N_ _S_ "LU(P)" {_A_ 2 _U_ 12 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer ] 1 { _A_ 2 _U_ 11 _N_ _S_ "LU(PPP)" {_A_ 4 _U_ 1222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
maxChar :: Char
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 2 _!_ C# [] ['\o377'#] _N_ #-}
maxInt :: Int
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 2 _!_ I# [] [2147483647#] _N_ #-}
minChar :: Char
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 2 _!_ C# [] ['\o0'#] _N_ #-}
minInt :: Int
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 2 _!_ I# [] [-2147483647#] _N_ #-}
not :: Bool -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "E" _F_ _ALWAYS_ \ (u0 :: Bool) -> case u0 of { _ALG_ True  -> _!_ False [] []; False  -> _!_ True [] []; _NO_DEFLT_ } _N_ #-}
nullBin :: Bin
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _S_ _!_ _N_ _N_ #-}
ord :: Char -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Char#) -> case _#_ ord# [] [u0] of { _PRIM_ (u1 :: Int#) -> _!_ I# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Char) -> case u0 of { _ALG_ C# (u1 :: Char#) -> case _#_ ord# [] [u1] of { _PRIM_ (u2 :: Int#) -> _!_ I# [] [u2] }; _NO_DEFLT_ } _N_ #-}
otherwise :: Bool
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _ALWAYS_ _!_ True [] [] _N_ #-}
primIOToIO :: (_State _RealWorld -> (a, _State _RealWorld)) -> _State _RealWorld -> (Either IOError13 a, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "SL" _N_ _N_ #-}
snd :: (a, b) -> b
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(AS)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 2 1 X 1 _/\_ u0 u1 -> \ (u2 :: u1) -> u2 _N_} _F_ _IF_ARGS_ 2 1 C 2 _/\_ u0 u1 -> \ (u2 :: (u0, u1)) -> case u2 of { _ALG_ _TUP_2 (u3 :: u0) (u4 :: u1) -> u4; _NO_DEFLT_ } _N_ #-}
subtract :: Num a => a -> a -> a
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _S_ "U(AAASAAAAAA)LL" {_A_ 3 _U_ 122 _N_ _N_ _F_ _IF_ARGS_ 1 3 XXX 3 _/\_ u0 -> \ (u1 :: u0 -> u0 -> u0) (u2 :: u0) (u3 :: u0) -> _APP_  u1 [ u3, u2 ] _N_} _F_ _IF_ARGS_ 1 3 CXX 4 _/\_ u0 -> \ (u1 :: {{Num u0}}) (u2 :: u0) (u3 :: u0) -> case u1 of { _ALG_ _TUP_10 (u4 :: {{Eq u0}}) (u5 :: {{Text u0}}) (u6 :: u0 -> u0 -> u0) (u7 :: u0 -> u0 -> u0) (u8 :: u0 -> u0 -> u0) (u9 :: u0 -> u0) (ua :: u0 -> u0) (ub :: u0 -> u0) (uc :: Integer -> u0) (ud :: Int -> u0) -> _APP_  u7 [ u3, u2 ]; _NO_DEFLT_ } _SPECIALISE_ [ Double ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Double#) (u1 :: Double#) -> case _#_ minusDouble# [] [u1, u0] of { _PRIM_ (u2 :: Double#) -> _!_ D# [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Double) (u1 :: Double) -> case u1 of { _ALG_ D# (u2 :: Double#) -> case u0 of { _ALG_ D# (u3 :: Double#) -> case _#_ minusDouble# [] [u2, u3] of { _PRIM_ (u4 :: Double#) -> _!_ D# [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ }, [ Int ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Int#) (u1 :: Int#) -> case _#_ minusInt# [] [u1, u0] of { _PRIM_ (u2 :: Int#) -> _!_ I# [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Int) (u1 :: Int) -> case u1 of { _ALG_ I# (u2 :: Int#) -> case u0 of { _ALG_ I# (u3 :: Int#) -> case _#_ minusInt# [] [u2, u3] of { _PRIM_ (u4 :: Int#) -> _!_ I# [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ }, [ (Complex Double) ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(LL)U(LL)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
thenMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "SL" _F_ _IF_ARGS_ 2 2 CX 5 _/\_ u0 u1 -> \ (u2 :: Maybe u0) (u3 :: u0 -> Maybe u1) -> case u2 of { _ALG_ Nothing  -> _!_ Nothing [u1] []; Just (u4 :: u0) -> _APP_  u3 [ u4 ]; _NO_DEFLT_ } _N_ #-}
toLower :: Char -> Char
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
toUpper :: Char -> Char
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
uncurry :: (a -> b -> c) -> (a, b) -> c
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "SU(LL)" {_A_ 3 _U_ 122 _N_ _N_ _F_ _IF_ARGS_ 3 3 XXX 3 _/\_ u0 u1 u2 -> \ (u3 :: u0 -> u1 -> u2) (u4 :: u0) (u5 :: u1) -> _APP_  u3 [ u4, u5 ] _N_} _F_ _IF_ARGS_ 3 2 XC 4 _/\_ u0 u1 u2 -> \ (u3 :: u0 -> u1 -> u2) (u4 :: (u0, u1)) -> case u4 of { _ALG_ _TUP_2 (u5 :: u0) (u6 :: u1) -> _APP_  u3 [ u5, u6 ]; _NO_DEFLT_ } _N_ #-}
until :: (a -> Bool) -> (a -> a) -> a -> a
	{-# GHC_PRAGMA _A_ 3 _U_ 222 _N_ _S_ "SLL" _N_ _N_ #-}
(||) :: Bool -> Bool -> Bool
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "EL" _F_ _ALWAYS_ \ (u0 :: Bool) (u1 :: Bool) -> case u0 of { _ALG_ True  -> _!_ True [] []; False  -> u1; _NO_DEFLT_ } _N_ #-}
(!) :: Ix a => Array a b -> a -> b
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "U(AASA)U(LP)L" {_A_ 4 _U_ 1222 _N_ _N_ _F_ _IF_ARGS_ 2 4 XXXX 7 _/\_ u0 u1 -> \ (u2 :: (u0, u0) -> u0 -> Int) (u3 :: (u0, u0)) (u4 :: Array# u1) (u5 :: u0) -> case _APP_  u2 [ u3, u5 ] of { _ALG_ I# (u6 :: Int#) -> case _#_ indexArray# [u1] [u4, u6] of { _ALG_ _Lift (u7 :: u1) -> u7; _NO_DEFLT_ }; _NO_DEFLT_ } _N_} _F_ _ALWAYS_ _/\_ u0 u1 -> \ (u2 :: {{Ix u0}}) (u3 :: Array u0 u1) (u4 :: u0) -> case u2 of { _ALG_ _TUP_4 (u5 :: {{Ord u0}}) (u6 :: (u0, u0) -> [u0]) (u7 :: (u0, u0) -> u0 -> Int) (u8 :: (u0, u0) -> u0 -> Bool) -> case u3 of { _ALG_ _Array (u9 :: (u0, u0)) (ua :: Array# u1) -> case _APP_  u7 [ u9, u4 ] of { _ALG_ I# (ub :: Int#) -> case _#_ indexArray# [u1] [ua, ub] of { _ALG_ _Lift (uc :: u1) -> uc; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(U(U(P)U(P))P)U(P)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Int, Int), _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(U(SS)P)U(U(P)U(P))" {_A_ 5 _U_ 11222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
(//) :: Ix a => Array a b -> [Assoc a b] -> Array a b
	{-# GHC_PRAGMA _A_ 3 _U_ 222 _N_ _S_ "U(LSLL)LS" _N_ _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ }, [ (Int, Int), _N_ ] 1 { _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ } #-}
_arrEleBottom :: a
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _S_ _!_ _N_ _N_ #-}
accum :: Ix b => (c -> a -> c) -> Array b c -> [Assoc b a] -> Array b c
	{-# GHC_PRAGMA _A_ 1 _U_ 1222 _N_ _S_ "U(ASLA)" {_A_ 5 _U_ 22222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ _N_, Int, _N_ ] 1 { _A_ 3 _U_ 222 _N_ _N_ _N_ _N_ }, [ _N_, (Int, Int), _N_ ] 1 { _A_ 3 _U_ 222 _N_ _N_ _N_ _N_ } #-}
accumArray :: Ix b => (c -> a -> c) -> c -> (b, b) -> [Assoc b a] -> Array b c
	{-# GHC_PRAGMA _A_ 5 _U_ 22222 _N_ _S_ "U(ASLA)LLLL" _N_ _SPECIALISE_ [ _N_, Int, _N_ ] 1 { _A_ 4 _U_ 2222 _N_ _N_ _N_ _N_ }, [ _N_, (Int, Int), _N_ ] 1 { _A_ 4 _U_ 2222 _N_ _N_ _N_ _N_ } #-}
amap :: Ix b => (a -> c) -> Array b a -> Array b c
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(ASLA)" {_A_ 4 _U_ 2221 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ _N_, Int, _N_ ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LU(U(U(P)U(P))P)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ _N_, (Int, Int), _N_ ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LU(U(SS)P)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
array :: Ix a => (a, a) -> [Assoc a b] -> Array a b
	{-# GHC_PRAGMA _A_ 3 _U_ 222 _N_ _S_ "SSS" _F_ _ALWAYS_ _/\_ u0 u1 -> \ (u2 :: {{Ix u0}}) (u3 :: (u0, u0)) (u4 :: [Assoc u0 u1]) -> let {(u9 :: (u0, u0) -> u0 -> Int) = case u2 of { _ALG_ _TUP_4 (u5 :: {{Ord u0}}) (u6 :: (u0, u0) -> [u0]) (u7 :: (u0, u0) -> u0 -> Int) (u8 :: (u0, u0) -> u0 -> Bool) -> u7; _NO_DEFLT_ }} in case u3 of { _ALG_ _TUP_2 (ua :: u0) (ub :: u0) -> let {(ux :: _forall_ a$z1 =>_State a$z1 -> (Array u0 u1, _State a$z1)) = _/\_ u12 -> \ (ud :: _State u12) -> let {(ue :: u1) = _TYAPP_  _ORIG_ PreludeArray _arrEleBottom { u1 }} in case u2 of { _ALG_ _TUP_4 (uf :: {{Ord u0}}) (ug :: (u0, u0) -> [u0]) (uh :: (u0, u0) -> u0 -> Int) (ui :: (u0, u0) -> u0 -> Bool) -> case ud of { _ALG_ S# (uj :: State# u12) -> case _APP_  _TYAPP_  _TYAPP_  _TYAPP_  _WRKR_ _ORIG_ PreludeGlaST _newArray { u12 } { u0 } { u1 } [ ug, uh, u3, ue, uj ] of { _ALG_ _TUP_2 (uk :: _MutableArray u12 u0 u1) (ul :: _State u12) -> case uk of { _ALG_ _MutableArray (um :: (u0, u0)) (un :: MutableArray# u12 u1) -> let {(uv :: _State u12 -> Assoc u0 u1 -> _State u12) = \ (uo :: _State u12) (up :: Assoc u0 u1) -> case uo of { _ALG_ S# (uq :: State# u12) -> case up of { _ALG_ (:=) (ur :: u0) (us :: u1) -> case _APP_  u9 [ u3, ur ] of { _ALG_ I# (ut :: Int#) -> case _#_ writeArray# [u12, u1] [un, ut, us, uq] of { _PRIM_ (uu :: State# u12) -> _!_ S# [u12] [uu] }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }} in case _APP_  _TYAPP_  _TYAPP_  foldl { (_State u12) } { (Assoc u0 u1) } [ uv, ul, u4 ] of { _ALG_ S# (uw :: State# u12) -> _APP_  _TYAPP_  _TYAPP_  _TYAPP_  _WRKR_ _ORIG_ PreludeGlaST _freezeArray { u12 } { u0 } { u1 } [ ug, uh, um, un, uw ]; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  _TYAPP_  _runST { (Array u0 u1) } [ ux ]; _NO_DEFLT_ } _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 12 _N_ _S_ "SS" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: (Int, Int)) (u2 :: [Assoc Int u0]) -> case u1 of { _ALG_ _TUP_2 (u3 :: Int) (u4 :: Int) -> let {(ut :: _forall_ a$z1 =>_State a$z1 -> (Array Int u0, _State a$z1)) = _/\_ u5 -> \ (u6 :: _State u5) -> let {(u7 :: u0) = _TYAPP_  _ORIG_ PreludeArray _arrEleBottom { u0 }} in case u3 of { _ALG_ I# (u8 :: Int#) -> case u4 of { _ALG_ I# (u9 :: Int#) -> case u6 of { _ALG_ S# (ua :: State# u5) -> case _APP_  _TYAPP_  _TYAPP_  _WRKR_ _SPEC_ _ORIG_ PreludeGlaST _newArray [ _N_, (Int), _N_ ] { u5 } { u0 } [ u8, u9, u7, ua ] of { _ALG_ _TUP_2 (ub :: _MutableArray u5 Int u0) (uc :: _State u5) -> case ub of { _ALG_ _MutableArray (ud :: (Int, Int)) (ue :: MutableArray# u5 u0) -> let {(un :: _State u5 -> Assoc Int u0 -> _State u5) = \ (uf :: _State u5) (ug :: Assoc Int u0) -> case uf of { _ALG_ S# (uh :: State# u5) -> case ug of { _ALG_ (:=) (ui :: Int) (uj :: u0) -> case ui of { _ALG_ I# (uk :: Int#) -> case _#_ leInt# [] [u8, uk] of { _ALG_ True  -> case _#_ leInt# [] [uk, u9] of { _ALG_ True  -> case _#_ minusInt# [] [uk, u8] of { _PRIM_ (ul :: Int#) -> case _#_ writeArray# [u5, u0] [ue, ul, uj, uh] of { _PRIM_ (um :: State# u5) -> _!_ S# [u5] [um] } }; False  -> _APP_  _TYAPP_  _ORIG_ PreludeCore _rangeComplaint_Ix_Int { (_State u5) } [ uk, u8, u9 ]; _NO_DEFLT_ }; False  -> _APP_  _TYAPP_  _ORIG_ PreludeCore _rangeComplaint_Ix_Int { (_State u5) } [ uk, u8, u9 ]; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }} in case _APP_  _TYAPP_  _TYAPP_  foldl { (_State u5) } { (Assoc Int u0) } [ un, uc, u2 ] of { _ALG_ S# (uo :: State# u5) -> case ud of { _ALG_ _TUP_2 (up :: Int) (uq :: Int) -> case up of { _ALG_ I# (ur :: Int#) -> case uq of { _ALG_ I# (us :: Int#) -> _APP_  _TYAPP_  _TYAPP_  _WRKR_ _SPEC_ _ORIG_ PreludeGlaST _freezeArray [ _N_, (Int), _N_ ] { u5 } { u0 } [ ur, us, ue, uo ]; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  _TYAPP_  _runST { (Array Int u0) } [ ut ]; _NO_DEFLT_ } _N_ }, [ (Int, Int), _N_ ] 1 { _A_ 2 _U_ 12 _N_ _S_ "SS" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: ((Int, Int), (Int, Int))) (u2 :: [Assoc (Int, Int) u0]) -> case u1 of { _ALG_ _TUP_2 (u3 :: (Int, Int)) (u4 :: (Int, Int)) -> let {(uF :: _forall_ a$z1 =>_State a$z1 -> (Array (Int, Int) u0, _State a$z1)) = _/\_ u5 -> \ (u6 :: _State u5) -> let {(u7 :: u0) = _TYAPP_  _ORIG_ PreludeArray _arrEleBottom { u0 }} in case u6 of { _ALG_ S# (u8 :: State# u5) -> case _APP_  _TYAPP_  _TYAPP_  _WRKR_ _SPEC_ _ORIG_ PreludeGlaST _newArray [ _N_, ((Int, Int)), _N_ ] { u5 } { u0 } [ u3, u4, u7, u8 ] of { _ALG_ _TUP_2 (u9 :: _MutableArray u5 (Int, Int) u0) (ua :: _State u5) -> case u9 of { _ALG_ _MutableArray (ub :: ((Int, Int), (Int, Int))) (uc :: MutableArray# u5 u0) -> let {(uB :: _State u5 -> Assoc (Int, Int) u0 -> _State u5) = \ (ud :: _State u5) (ue :: Assoc (Int, Int) u0) -> case ud of { _ALG_ S# (uf :: State# u5) -> case ue of { _ALG_ (:=) (ug :: (Int, Int)) (uh :: u0) -> case u3 of { _ALG_ _TUP_2 (ui :: Int) (uj :: Int) -> case u4 of { _ALG_ _TUP_2 (uk :: Int) (ul :: Int) -> case ug of { _ALG_ _TUP_2 (um :: Int) (un :: Int) -> case ui of { _ALG_ I# (uo :: Int#) -> case uk of { _ALG_ I# (up :: Int#) -> case um of { _ALG_ I# (uq :: Int#) -> case _#_ leInt# [] [uo, uq] of { _ALG_ True  -> case _#_ leInt# [] [uq, up] of { _ALG_ True  -> case _#_ minusInt# [] [uq, uo] of { _PRIM_ (ur :: Int#) -> case uj of { _ALG_ I# (us :: Int#) -> case ul of { _ALG_ I# (ut :: Int#) -> case _#_ leInt# [] [us, ut] of { _ALG_ True  -> case _#_ leInt# [] [ut, ut] of { _ALG_ True  -> case _#_ minusInt# [] [ut, us] of { _PRIM_ (uu :: Int#) -> case _#_ plusInt# [] [uu, 1#] of { _PRIM_ (uv :: Int#) -> case _#_ timesInt# [] [ur, uv] of { _PRIM_ (uw :: Int#) -> case un of { _ALG_ I# (ux :: Int#) -> case _#_ leInt# [] [us, ux] of { _ALG_ True  -> case _#_ leInt# [] [ux, ut] of { _ALG_ True  -> case _#_ minusInt# [] [ux, us] of { _PRIM_ (uy :: Int#) -> case _#_ plusInt# [] [uw, uy] of { _PRIM_ (uz :: Int#) -> case _#_ writeArray# [u5, u0] [uc, uz, uh, uf] of { _PRIM_ (uA :: State# u5) -> _!_ S# [u5] [uA] } } }; False  -> _APP_  _TYAPP_  _ORIG_ PreludeCore _rangeComplaint_Ix_Int { (_State u5) } [ ux, us, ut ]; _NO_DEFLT_ }; False  -> _APP_  _TYAPP_  _ORIG_ PreludeCore _rangeComplaint_Ix_Int { (_State u5) } [ ux, us, ut ]; _NO_DEFLT_ }; _NO_DEFLT_ } } } }; False  -> _APP_  _TYAPP_  _ORIG_ PreludeCore _rangeComplaint_Ix_Int { (_State u5) } [ ut, us, ut ]; _NO_DEFLT_ }; False  -> _APP_  _TYAPP_  _ORIG_ PreludeCore _rangeComplaint_Ix_Int { (_State u5) } [ ut, us, ut ]; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } }; False  -> _APP_  _TYAPP_  _ORIG_ PreludeCore _rangeComplaint_Ix_Int { (_State u5) } [ uq, uo, up ]; _NO_DEFLT_ }; False  -> _APP_  _TYAPP_  _ORIG_ PreludeCore _rangeComplaint_Ix_Int { (_State u5) } [ uq, uo, up ]; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }} in case _APP_  _TYAPP_  _TYAPP_  foldl { (_State u5) } { (Assoc (Int, Int) u0) } [ uB, ua, u2 ] of { _ALG_ S# (uC :: State# u5) -> case ub of { _ALG_ _TUP_2 (uD :: (Int, Int)) (uE :: (Int, Int)) -> _APP_  _TYAPP_  _TYAPP_  _WRKR_ _SPEC_ _ORIG_ PreludeGlaST _freezeArray [ _N_, ((Int, Int)), _N_ ] { u5 } { u0 } [ uD, uE, uc, uC ]; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  _TYAPP_  _runST { (Array (Int, Int) u0) } [ uF ]; _NO_DEFLT_ } _N_ } #-}
assocs :: Ix a => Array a b -> [Assoc a b]
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 u1 -> \ (u2 :: {{Ix u0}}) -> let {(u4 :: _forall_ a$z1 =>Array u0 a$z1 -> [u0]) = _/\_ u3 -> _APP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeArray indices { u3 } { u0 } [ u2 ]} in let {(u6 :: _forall_ a$z1 =>Array u0 a$z1 -> u0 -> a$z1) = _/\_ u5 -> _APP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeArray (!) { u0 } { u5 } [ u2 ]} in \ (u7 :: Array u0 u1) -> let {(uh :: _forall_ a$z1 =>(Assoc u0 u1 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u8 -> \ (u9 :: Assoc u0 u1 -> u8 -> u8) (ua :: u8) -> let {(uf :: u0 -> u8 -> u8) = \ (ub :: u0) (uc :: u8) -> let {(ud :: u1) = _APP_  _TYAPP_  u6 { u1 } [ u7, ub ]} in let {(ue :: Assoc u0 u1) = _!_ (:=) [u0, u1] [ub, ud]} in _APP_  u9 [ ue, uc ]} in let {(ug :: [u0]) = _APP_  _TYAPP_  u4 { u1 } [ u7 ]} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { u8 } [ uf, ua, ug ]} in _APP_  _TYAPP_  _build { (Assoc u0 u1) } [ uh ] _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 1 _U_ 2 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: Array Int u0) -> let {(ub :: _forall_ a$z1 =>(Assoc Int u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u2 -> \ (u3 :: Assoc Int u0 -> u2 -> u2) (u4 :: u2) -> let {(u9 :: Int -> u2 -> u2) = \ (u5 :: Int) (u6 :: u2) -> let {(u7 :: u0) = _APP_  _TYAPP_  _SPEC_ _ORIG_ PreludeArray (!) [ (Int), _N_ ] { u0 } [ u1, u5 ]} in let {(u8 :: Assoc Int u0) = _!_ (:=) [Int, u0] [u5, u7]} in _APP_  u3 [ u8, u6 ]} in let {(ua :: [Int]) = _APP_  _TYAPP_  _SPEC_ _ORIG_ PreludeArray indices [ _N_, (Int) ] { u0 } [ u1 ]} in _APP_  _TYAPP_  _TYAPP_  foldr { Int } { u2 } [ u9, u4, ua ]} in _APP_  _TYAPP_  _build { (Assoc Int u0) } [ ub ] _N_ }, [ (Int, Int), _N_ ] 1 { _A_ 1 _U_ 2 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: Array (Int, Int) u0) -> let {(ub :: _forall_ a$z1 =>(Assoc (Int, Int) u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u2 -> \ (u3 :: Assoc (Int, Int) u0 -> u2 -> u2) (u4 :: u2) -> let {(u9 :: (Int, Int) -> u2 -> u2) = \ (u5 :: (Int, Int)) (u6 :: u2) -> let {(u7 :: u0) = _APP_  _TYAPP_  _SPEC_ _ORIG_ PreludeArray (!) [ ((Int, Int)), _N_ ] { u0 } [ u1, u5 ]} in let {(u8 :: Assoc (Int, Int) u0) = _!_ (:=) [(Int, Int), u0] [u5, u7]} in _APP_  u3 [ u8, u6 ]} in let {(ua :: [(Int, Int)]) = _APP_  _TYAPP_  _SPEC_ _ORIG_ PreludeArray indices [ _N_, ((Int, Int)) ] { u0 } [ u1 ]} in _APP_  _TYAPP_  _TYAPP_  foldr { (Int, Int) } { u2 } [ u9, u4, ua ]} in _APP_  _TYAPP_  _build { (Assoc (Int, Int) u0) } [ ub ] _N_ } #-}
bounds :: Array b a -> (b, b)
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(U(LL)P)" {_A_ 3 _U_ 220 _N_ _N_ _F_ _IF_ARGS_ 2 3 XXX 3 _/\_ u0 u1 -> \ (u2 :: u1) (u3 :: u1) (u4 :: Array# u0) -> _!_ _TUP_2 [u1, u1] [u2, u3] _N_} _F_ _IF_ARGS_ 2 1 C 2 _/\_ u0 u1 -> \ (u2 :: Array u1 u0) -> case u2 of { _ALG_ _Array (u3 :: (u1, u1)) (u4 :: Array# u0) -> u3; _NO_DEFLT_ } _N_ #-}
elems :: Ix a => Array a b -> [b]
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 u1 -> \ (u2 :: {{Ix u0}}) -> let {(u4 :: _forall_ a$z1 =>Array u0 a$z1 -> [u0]) = _/\_ u3 -> _APP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeArray indices { u3 } { u0 } [ u2 ]} in let {(u6 :: _forall_ a$z1 =>Array u0 a$z1 -> u0 -> a$z1) = _/\_ u5 -> _APP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeArray (!) { u0 } { u5 } [ u2 ]} in \ (u7 :: Array u0 u1) -> let {(ug :: _forall_ a$z1 =>(u1 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u8 -> \ (u9 :: u1 -> u8 -> u8) (ua :: u8) -> let {(ue :: u0 -> u8 -> u8) = \ (ub :: u0) (uc :: u8) -> let {(ud :: u1) = _APP_  _TYAPP_  u6 { u1 } [ u7, ub ]} in _APP_  u9 [ ud, uc ]} in let {(uf :: [u0]) = _APP_  _TYAPP_  u4 { u1 } [ u7 ]} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { u8 } [ ue, ua, uf ]} in _APP_  _TYAPP_  _build { u1 } [ ug ] _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 1 _U_ 2 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: Array Int u0) -> let {(ua :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u2 -> \ (u3 :: u0 -> u2 -> u2) (u4 :: u2) -> let {(u8 :: Int -> u2 -> u2) = \ (u5 :: Int) (u6 :: u2) -> let {(u7 :: u0) = _APP_  _TYAPP_  _SPEC_ _ORIG_ PreludeArray (!) [ (Int), _N_ ] { u0 } [ u1, u5 ]} in _APP_  u3 [ u7, u6 ]} in let {(u9 :: [Int]) = _APP_  _TYAPP_  _SPEC_ _ORIG_ PreludeArray indices [ _N_, (Int) ] { u0 } [ u1 ]} in _APP_  _TYAPP_  _TYAPP_  foldr { Int } { u2 } [ u8, u4, u9 ]} in _APP_  _TYAPP_  _build { u0 } [ ua ] _N_ }, [ (Int, Int), _N_ ] 1 { _A_ 1 _U_ 2 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: Array (Int, Int) u0) -> let {(ua :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u2 -> \ (u3 :: u0 -> u2 -> u2) (u4 :: u2) -> let {(u8 :: (Int, Int) -> u2 -> u2) = \ (u5 :: (Int, Int)) (u6 :: u2) -> let {(u7 :: u0) = _APP_  _TYAPP_  _SPEC_ _ORIG_ PreludeArray (!) [ ((Int, Int)), _N_ ] { u0 } [ u1, u5 ]} in _APP_  u3 [ u7, u6 ]} in let {(u9 :: [(Int, Int)]) = _APP_  _TYAPP_  _SPEC_ _ORIG_ PreludeArray indices [ _N_, ((Int, Int)) ] { u0 } [ u1 ]} in _APP_  _TYAPP_  _TYAPP_  foldr { (Int, Int) } { u2 } [ u8, u4, u9 ]} in _APP_  _TYAPP_  _build { u0 } [ ua ] _N_ } #-}
indices :: Ix b => Array b a -> [b]
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "SL" _F_ _ALWAYS_ _/\_ u0 u1 -> \ (u2 :: {{Ix u1}}) (u3 :: Array u1 u0) -> let {(u4 :: (u1, u1)) = _APP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeArray bounds { u0 } { u1 } [ u3 ]} in case u2 of { _ALG_ _TUP_4 (u5 :: {{Ord u1}}) (u6 :: (u1, u1) -> [u1]) (u7 :: (u1, u1) -> u1 -> Int) (u8 :: (u1, u1) -> u1 -> Bool) -> _APP_  u6 [ u4 ]; _NO_DEFLT_ } _SPECIALISE_ [ _N_, Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: Array Int u0) -> case _APP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeArray bounds { u0 } { Int } [ u1 ] of { _ALG_ _TUP_2 (u2 :: Int) (u3 :: Int) -> case u2 of { _ALG_ I# (u4 :: Int#) -> _LETREC_ {(u5 :: Int# -> [Int]) = \ (u6 :: Int#) -> case u3 of { _ALG_ I# (u7 :: Int#) -> case _#_ leInt# [] [u6, u7] of { _ALG_ True  -> let {(u9 :: [Int]) = case _#_ plusInt# [] [u6, 1#] of { _PRIM_ (u8 :: Int#) -> _APP_  u5 [ u8 ] }} in let {(ua :: Int) = _!_ I# [] [u6]} in _!_ (:) [Int] [ua, u9]; False  -> _!_ _NIL_ [Int] []; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  u5 [ u4 ]; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ }, [ _N_, (Int, Int) ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: Array (Int, Int) u0) -> case _APP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeArray bounds { u0 } { (Int, Int) } [ u1 ] of { _ALG_ _TUP_2 (u2 :: (Int, Int)) (u3 :: (Int, Int)) -> case u2 of { _ALG_ _TUP_2 (u4 :: Int) (u5 :: Int) -> case u3 of { _ALG_ _TUP_2 (u6 :: Int) (u7 :: Int) -> let {(uy :: _forall_ a$z1 =>((Int, Int) -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u8 -> \ (u9 :: (Int, Int) -> u8 -> u8) (ua :: u8) -> let {(up :: Int -> u8 -> u8) = \ (ub :: Int) (uc :: u8) -> let {(ug :: Int -> u8 -> u8) = \ (ud :: Int) (ue :: u8) -> let {(uf :: (Int, Int)) = _!_ _TUP_2 [Int, Int] [ub, ud]} in _APP_  u9 [ uf, ue ]} in let {(uo :: [Int]) = case u5 of { _ALG_ I# (uh :: Int#) -> _LETREC_ {(ui :: Int# -> [Int]) = \ (uj :: Int#) -> case u7 of { _ALG_ I# (uk :: Int#) -> case _#_ leInt# [] [uj, uk] of { _ALG_ True  -> let {(um :: [Int]) = case _#_ plusInt# [] [uj, 1#] of { _PRIM_ (ul :: Int#) -> _APP_  ui [ ul ] }} in let {(un :: Int) = _!_ I# [] [uj]} in _!_ (:) [Int] [un, um]; False  -> _!_ _NIL_ [Int] []; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  ui [ uh ]; _NO_DEFLT_ }} in _APP_  _TYAPP_  _TYAPP_  foldr { Int } { u8 } [ ug, uc, uo ]} in let {(ux :: [Int]) = case u4 of { _ALG_ I# (uq :: Int#) -> _LETREC_ {(ur :: Int# -> [Int]) = \ (us :: Int#) -> case u6 of { _ALG_ I# (ut :: Int#) -> case _#_ leInt# [] [us, ut] of { _ALG_ True  -> let {(uv :: [Int]) = case _#_ plusInt# [] [us, 1#] of { _PRIM_ (uu :: Int#) -> _APP_  ur [ uu ] }} in let {(uw :: Int) = _!_ I# [] [us]} in _!_ (:) [Int] [uw, uv]; False  -> _!_ _NIL_ [Int] []; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  ur [ uq ]; _NO_DEFLT_ }} in _APP_  _TYAPP_  _TYAPP_  foldr { Int } { u8 } [ up, ua, ux ]} in _APP_  _TYAPP_  _build { (Int, Int) } [ uy ]; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ } #-}
ixmap :: (Ix b, Ix a) => (b, b) -> (b -> a) -> Array a c -> Array b c
	{-# GHC_PRAGMA _A_ 2 _U_ 12222 _N_ _S_ "U(ASLA)L" {_A_ 6 _U_ 222222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
listArray :: Ix a => (a, a) -> [b] -> Array a b
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "U(ASLA)U(LL)L" {_A_ 5 _U_ 22222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(U(P)U(P))L" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Int, Int), _N_ ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(SS)L" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
cis :: RealFloat a => a -> Complex a
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _N_ _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ } #-}
conjugate :: RealFloat a => Complex a -> Complex a
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "LU(LL)" {_A_ 3 _U_ 122 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(LL)" {_A_ 2 _U_ 21 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
imagPart :: Complex a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(AS)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: Complex u0) -> case u1 of { _ALG_ (:+) (u2 :: u0) (u3 :: u0) -> u3; _NO_DEFLT_ } _N_ #-}
magnitude :: RealFloat a => Complex a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "U(ALAAAAALAS)" {_A_ 3 _U_ 2221 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(U(P)U(P))" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
mkPolar :: RealFloat a => a -> a -> Complex a
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _N_ _N_ _SPECIALISE_ [ Double ] 1 { _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ } #-}
phase :: RealFloat a => Complex a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "U(U(U(AU(U(ALAASAAA)AAAA)A)AAAAAA)U(U(SLAA)LAAAAAAAAAALAAAAAA)AAAAAAAA)" {_A_ 5 _U_ 222221 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(U(P)U(P))" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
polar :: RealFloat a => Complex a -> (a, a)
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _N_ _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ } #-}
realPart :: Complex a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(SA)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: Complex u0) -> case u1 of { _ALG_ (:+) (u2 :: u0) (u3 :: u0) -> u2; _NO_DEFLT_ } _N_ #-}
_rangeComplaint_Ix_Int :: Int# -> Int# -> Int# -> a
	{-# GHC_PRAGMA _A_ 3 _U_ 222 _N_ _S_ _!_ _N_ _N_ #-}
_readList :: ([Char] -> [(a, [Char])]) -> [Char] -> [([a], [Char])]
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _N_ _N_ _N_ #-}
_showList :: (a -> [Char] -> [Char]) -> [a] -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 212 _N_ _S_ "LS" _N_ _N_ #-}
_showRational :: Int -> Ratio Integer -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LU(U(PPP)L)" {_A_ 5 _U_ 22222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
_freezeArray :: Ix b => _MutableArray a b c -> _State a -> (Array b c, _State a)
	{-# GHC_PRAGMA _A_ 3 _U_ 111 _N_ _S_ "U(ASLA)U(U(LL)P)U(P)" {_A_ 5 _U_ 11222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ _N_, Int, _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(U(U(P)U(P))P)U(P)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ _N_, (Int, Int), _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(U(SS)P)U(P)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
_newArray :: Ix b => (b, b) -> c -> _State a -> (_MutableArray a b c, _State a)
	{-# GHC_PRAGMA _A_ 4 _U_ 1221 _N_ _S_ "U(ASLA)U(LL)LU(P)" {_A_ 5 _U_ 11222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ _N_, Int, _N_ ] 1 { _A_ 3 _U_ 121 _N_ _S_ "U(U(P)U(P))LU(P)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ _N_, (Int, Int), _N_ ] 1 { _A_ 3 _U_ 121 _N_ _S_ "U(SS)LU(P)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
interact :: ([Char] -> [Char]) -> _State _RealWorld -> (Either IOError13 (), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "LU(P)" {_A_ 2 _U_ 12 _N_ _N_ _N_ _N_} _N_ _N_ #-}
(!!) :: Integral a => [b] -> a -> b
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(LU(U(ASAAAAAA)AAA)AAAAAAAAAS)" {_A_ 3 _U_ 11112 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "SU(P)" {_A_ 2 _U_ 12 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer, _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "SU(PPP)" {_A_ 4 _U_ 1222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
(++) :: [a] -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "SL" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: [u0]) (u2 :: [u0]) -> let {(u6 :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u3 -> \ (u4 :: u0 -> u3 -> u3) (u5 :: u3) -> _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { u3 } [ u4, u5, u1 ]} in _APP_  _TYAPP_  _augment { u0 } [ u6, u2 ] _N_ #-}
(\\) :: Eq a => [a] -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _S_ "LLS" _N_ _SPECIALISE_ [ Int ] 1 { _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ }, [ [Char] ] 1 { _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ } #-}
all :: (a -> Bool) -> [a] -> Bool
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: u0 -> Bool) (u2 :: [u0]) -> let {(u3 :: Bool) = _!_ True [] []} in let {(u6 :: u0 -> Bool -> Bool) = \ (u4 :: u0) (u5 :: Bool) -> case _APP_  u1 [ u4 ] of { _ALG_ True  -> u5; False  -> _!_ False [] []; _NO_DEFLT_ }} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { Bool } [ u6, u3, u2 ] _N_ #-}
and :: [Bool] -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [Bool]) -> let {(u1 :: Bool) = _!_ True [] []} in _APP_  _TYAPP_  _TYAPP_  foldr { Bool } { Bool } [ _ORIG_ Prelude (&&), u1, u0 ] _N_ #-}
any :: (a -> Bool) -> [a] -> Bool
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: u0 -> Bool) (u2 :: [u0]) -> let {(u3 :: Bool) = _!_ False [] []} in let {(u6 :: u0 -> Bool -> Bool) = \ (u4 :: u0) (u5 :: Bool) -> case _APP_  u1 [ u4 ] of { _ALG_ True  -> _!_ True [] []; False  -> u5; _NO_DEFLT_ }} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { Bool } [ u6, u3, u2 ] _N_ #-}
break :: (a -> Bool) -> [a] -> ([a], [a])
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ #-}
concat :: [[a]] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: [[u0]]) -> let {(u8 :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u2 -> \ (u3 :: u0 -> u2 -> u2) (u4 :: u2) -> let {(u7 :: [u0] -> u2 -> u2) = \ (u5 :: [u0]) (u6 :: u2) -> _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { u2 } [ u3, u6, u5 ]} in _APP_  _TYAPP_  _TYAPP_  foldr { [u0] } { u2 } [ u7, u4, u1 ]} in _APP_  _TYAPP_  _build { u0 } [ u8 ] _N_ #-}
cycle :: [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: [u0]) -> let {(u6 :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u2 -> \ (u3 :: u0 -> u2 -> u2) (u4 :: u2) -> _LETREC_ {(u5 :: u2) = _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { u2 } [ u3, u5, u1 ]} in u5} in _APP_  _TYAPP_  _build { u0 } [ u6 ] _N_ #-}
drop :: Integral a => a -> [b] -> [b]
	{-# GHC_PRAGMA _A_ 3 _U_ 121 _N_ _S_ "U(AAAAAAAAAAAS)LS" {_A_ 3 _U_ 121 _N_ _N_ _N_ _N_} _F_ _IF_ARGS_ 2 3 CXX 7 _/\_ u0 u1 -> \ (u2 :: {{Integral u0}}) (u3 :: u0) (u4 :: [u1]) -> let {(uh :: Int) = case u2 of { _ALG_ _TUP_12 (u5 :: {{Real u0}}) (u6 :: {{Ix u0}}) (u7 :: u0 -> u0 -> u0) (u8 :: u0 -> u0 -> u0) (u9 :: u0 -> u0 -> u0) (ua :: u0 -> u0 -> u0) (ub :: u0 -> u0 -> (u0, u0)) (uc :: u0 -> u0 -> (u0, u0)) (ud :: u0 -> Bool) (ue :: u0 -> Bool) (uf :: u0 -> Integer) (ug :: u0 -> Int) -> _APP_  ug [ u3 ]; _NO_DEFLT_ }} in _APP_  _TYAPP_  _SPEC_ _ORIG_ PreludeList drop [ (Int), _N_ ] { u1 } [ uh, u4 ] _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(P)S" {_A_ 2 _U_ 21 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer, _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(PPP)S" {_A_ 4 _U_ 2221 _N_ _N_ _F_ _IF_ARGS_ 1 4 XXXX 4 _/\_ u0 -> \ (u1 :: Int#) (u2 :: Int#) (u3 :: ByteArray#) (u4 :: [u0]) -> case _#_ integer2Int# [] [u1, u2, u3] of { _PRIM_ (u5 :: Int#) -> _APP_  _TYAPP_  _WRKR_ _SPEC_ _ORIG_ PreludeList drop [ (Int), _N_ ] { u0 } [ u5, u4 ] } _N_} _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: Integer) (u2 :: [u0]) -> case u1 of { _ALG_ J# (u3 :: Int#) (u4 :: Int#) (u5 :: ByteArray#) -> case _#_ integer2Int# [] [u3, u4, u5] of { _PRIM_ (u6 :: Int#) -> _APP_  _TYAPP_  _WRKR_ _SPEC_ _ORIG_ PreludeList drop [ (Int), _N_ ] { u0 } [ u6, u2 ] }; _NO_DEFLT_ } _N_ } #-}
dropWhile :: (a -> Bool) -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
elem :: Eq a => a -> [a] -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 121 _N_ _N_ _N_ _SPECIALISE_ [ Char ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ }, [ Int ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ }, [ Integer ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ }, [ [Char] ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ }, [ [Int] ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ }, [ (Int, Int) ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ } #-}
filter :: (a -> Bool) -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: u0 -> Bool) (u2 :: [u0]) -> let {(u9 :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u3 -> \ (u4 :: u0 -> u3 -> u3) (u5 :: u3) -> let {(u8 :: u0 -> u3 -> u3) = \ (u6 :: u0) (u7 :: u3) -> case _APP_  u1 [ u6 ] of { _ALG_ True  -> _APP_  u4 [ u6, u7 ]; False  -> u7; _NO_DEFLT_ }} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { u3 } [ u8, u5, u2 ]} in _APP_  _TYAPP_  _build { u0 } [ u9 ] _N_ #-}
foldl1 :: (a -> a -> a) -> [a] -> a
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
foldr1 :: (a -> a -> a) -> [a] -> a
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
genericLength :: Num b => [a] -> b
	{-# GHC_PRAGMA _A_ 1 _U_ 21 _N_ _N_ _N_ _SPECIALISE_ [ _N_, Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ }, [ _N_, Integer ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ } #-}
head :: [a] -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: [u0]) -> let {(u2 :: u0) = _APP_  _TYAPP_  error { u0 } [ _NOREP_S_ "head{PreludeList}: head []\n" ]} in let {(u5 :: u0 -> u0 -> u0) = \ (u3 :: u0) (u4 :: u0) -> u3} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { u0 } [ u5, u2, u1 ] _N_ #-}
init :: [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
iterate :: (a -> a) -> a -> [a]
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: u0 -> u0) (u2 :: u0) -> let {(ua :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u3 -> \ (u4 :: u0 -> u3 -> u3) (u5 :: u3) -> _LETREC_ {(u6 :: u0 -> u3) = \ (u7 :: u0) -> let {(u9 :: u3) = let {(u8 :: u0) = _APP_  u1 [ u7 ]} in _APP_  u6 [ u8 ]} in _APP_  u4 [ u7, u9 ]} in _APP_  u6 [ u2 ]} in _APP_  _TYAPP_  _build { u0 } [ ua ] _N_ #-}
last :: [a] -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
length :: [a] -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: [u0]) -> let {(u2 :: Int) = _!_ I# [] [0#]} in let {(u7 :: Int -> u0 -> Int) = \ (u3 :: Int) (u4 :: u0) -> case u3 of { _ALG_ I# (u5 :: Int#) -> case _#_ plusInt# [] [u5, 1#] of { _PRIM_ (u6 :: Int#) -> _!_ I# [] [u6] }; _NO_DEFLT_ }} in _APP_  _TYAPP_  _TYAPP_  foldl { Int } { u0 } [ u7, u2, u1 ] _N_ #-}
lines :: [Char] -> [[Char]]
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
map :: (a -> b) -> [a] -> [b]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ _/\_ u0 u1 -> \ (u2 :: u0 -> u1) (u3 :: [u0]) -> let {(ub :: _forall_ a$z1 =>(u1 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u4 -> \ (u5 :: u1 -> u4 -> u4) (u6 :: u4) -> let {(ua :: u0 -> u4 -> u4) = \ (u7 :: u0) (u8 :: u4) -> let {(u9 :: u1) = _APP_  u2 [ u7 ]} in _APP_  u5 [ u9, u8 ]} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { u4 } [ ua, u6, u3 ]} in _APP_  _TYAPP_  _build { u1 } [ ub ] _N_ #-}
maximum :: Ord a => [a] -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 11 _N_ _N_ _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ }, [ Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ } #-}
minimum :: Ord a => [a] -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 11 _N_ _N_ _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ }, [ Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ } #-}
notElem :: Eq a => a -> [a] -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 121 _N_ _N_ _N_ _SPECIALISE_ [ Char ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ }, [ Int ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ }, [ Integer ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ }, [ [Char] ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ }, [ (Int, Int) ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ } #-}
nub :: Eq a => [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 11 _N_ _N_ _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: {{Eq u0}}) -> let {(u2 :: u0 -> [u0] -> Bool) = _APP_  _TYAPP_  _ORIG_ PreludeList elem { u0 } [ u1 ]} in \ (u3 :: [u0]) -> let {(uf :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u4 -> \ (u5 :: u0 -> u4 -> u4) (u6 :: u4) -> _LETREC_ {(u7 :: [u0] -> [u0] -> u4) = \ (u8 :: [u0]) (u9 :: [u0]) -> case u8 of { _ALG_ _NIL_  -> u6; (:) (ua :: u0) (ub :: [u0]) -> case _APP_  u2 [ ua, u9 ] of { _ALG_ True  -> _APP_  u7 [ ub, u9 ]; False  -> let {(ud :: u4) = let {(uc :: [u0]) = _!_ (:) [u0] [ua, u9]} in _APP_  u7 [ ub, uc ]} in _APP_  u5 [ ua, ud ]; _NO_DEFLT_ }; _NO_DEFLT_ }} in let {(ue :: [u0]) = _!_ _NIL_ [u0] []} in _APP_  u7 [ u3, ue ]} in _APP_  _TYAPP_  _build { u0 } [ uf ] _SPECIALISE_ [ Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [Int]) -> let {(uc :: _forall_ a$z1 =>(Int -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u1 -> \ (u2 :: Int -> u1 -> u1) (u3 :: u1) -> _LETREC_ {(u4 :: [Int] -> [Int] -> u1) = \ (u5 :: [Int]) (u6 :: [Int]) -> case u5 of { _ALG_ _NIL_  -> u3; (:) (u7 :: Int) (u8 :: [Int]) -> case _APP_  _SPEC_ _ORIG_ PreludeList elem [ (Int) ] [ u7, u6 ] of { _ALG_ True  -> _APP_  u4 [ u8, u6 ]; False  -> let {(ua :: u1) = let {(u9 :: [Int]) = _!_ (:) [Int] [u7, u6]} in _APP_  u4 [ u8, u9 ]} in _APP_  u2 [ u7, ua ]; _NO_DEFLT_ }; _NO_DEFLT_ }} in let {(ub :: [Int]) = _!_ _NIL_ [Int] []} in _APP_  u4 [ u0, ub ]} in _APP_  _TYAPP_  _build { Int } [ uc ] _N_ }, [ [Char] ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [[Char]]) -> let {(uc :: _forall_ a$z1 =>([Char] -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u1 -> \ (u2 :: [Char] -> u1 -> u1) (u3 :: u1) -> _LETREC_ {(u4 :: [[Char]] -> [[Char]] -> u1) = \ (u5 :: [[Char]]) (u6 :: [[Char]]) -> case u5 of { _ALG_ _NIL_  -> u3; (:) (u7 :: [Char]) (u8 :: [[Char]]) -> case _APP_  _SPEC_ _ORIG_ PreludeList elem [ ([Char]) ] [ u7, u6 ] of { _ALG_ True  -> _APP_  u4 [ u8, u6 ]; False  -> let {(ua :: u1) = let {(u9 :: [[Char]]) = _!_ (:) [[Char]] [u7, u6]} in _APP_  u4 [ u8, u9 ]} in _APP_  u2 [ u7, ua ]; _NO_DEFLT_ }; _NO_DEFLT_ }} in let {(ub :: [[Char]]) = _!_ _NIL_ [[Char]] []} in _APP_  u4 [ u0, ub ]} in _APP_  _TYAPP_  _build { [Char] } [ uc ] _N_ }, [ [Int] ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [[Int]]) -> let {(uc :: _forall_ a$z1 =>([Int] -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u1 -> \ (u2 :: [Int] -> u1 -> u1) (u3 :: u1) -> _LETREC_ {(u4 :: [[Int]] -> [[Int]] -> u1) = \ (u5 :: [[Int]]) (u6 :: [[Int]]) -> case u5 of { _ALG_ _NIL_  -> u3; (:) (u7 :: [Int]) (u8 :: [[Int]]) -> case _APP_  _SPEC_ _ORIG_ PreludeList elem [ ([Int]) ] [ u7, u6 ] of { _ALG_ True  -> _APP_  u4 [ u8, u6 ]; False  -> let {(ua :: u1) = let {(u9 :: [[Int]]) = _!_ (:) [[Int]] [u7, u6]} in _APP_  u4 [ u8, u9 ]} in _APP_  u2 [ u7, ua ]; _NO_DEFLT_ }; _NO_DEFLT_ }} in let {(ub :: [[Int]]) = _!_ _NIL_ [[Int]] []} in _APP_  u4 [ u0, ub ]} in _APP_  _TYAPP_  _build { [Int] } [ uc ] _N_ } #-}
null :: [a] -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: [u0]) -> let {(u2 :: Bool) = _!_ True [] []} in let {(u5 :: u0 -> Bool -> Bool) = \ (u3 :: u0) (u4 :: Bool) -> _!_ False [] []} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { Bool } [ u5, u2, u1 ] _N_ #-}
or :: [Bool] -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [Bool]) -> let {(u1 :: Bool) = _!_ False [] []} in _APP_  _TYAPP_  _TYAPP_  foldr { Bool } { Bool } [ _ORIG_ Prelude (||), u1, u0 ] _N_ #-}
partition :: (a -> Bool) -> [a] -> ([a], [a])
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: u0 -> Bool) (u2 :: [u0]) -> let {(u9 :: u0 -> ([u0], [u0]) -> ([u0], [u0])) = \ (u3 :: u0) (u4 :: ([u0], [u0])) -> case u4 of { _ALG_ _TUP_2 (u5 :: [u0]) (u6 :: [u0]) -> case _APP_  u1 [ u3 ] of { _ALG_ True  -> let {(u7 :: [u0]) = _!_ (:) [u0] [u3, u5]} in _!_ _TUP_2 [[u0], [u0]] [u7, u6]; False  -> let {(u8 :: [u0]) = _!_ (:) [u0] [u3, u6]} in _!_ _TUP_2 [[u0], [u0]] [u5, u8]; _NO_DEFLT_ }; _NO_DEFLT_ }} in let {(ua :: [u0]) = _!_ _NIL_ [u0] []} in let {(ub :: ([u0], [u0])) = _!_ _TUP_2 [[u0], [u0]] [ua, ua]} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { ([u0], [u0]) } [ u9, ub, u2 ] _N_ #-}
product :: Num a => [a] -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _N_ _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: {{Num u0}}) -> let {(uc :: u0 -> u0 -> u0) = case u1 of { _ALG_ _TUP_10 (u2 :: {{Eq u0}}) (u3 :: {{Text u0}}) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0 -> u0) (u6 :: u0 -> u0 -> u0) (u7 :: u0 -> u0) (u8 :: u0 -> u0) (u9 :: u0 -> u0) (ua :: Integer -> u0) (ub :: Int -> u0) -> u6; _NO_DEFLT_ }} in let {(uo :: u0) = let {(ud :: Int) = _!_ I# [] [1#]} in case u1 of { _ALG_ _TUP_10 (ue :: {{Eq u0}}) (uf :: {{Text u0}}) (ug :: u0 -> u0 -> u0) (uh :: u0 -> u0 -> u0) (ui :: u0 -> u0 -> u0) (uj :: u0 -> u0) (uk :: u0 -> u0) (ul :: u0 -> u0) (um :: Integer -> u0) (un :: Int -> u0) -> _APP_  un [ ud ]; _NO_DEFLT_ }} in \ (up :: [u0]) -> _APP_  _TYAPP_  _TYAPP_  foldl { u0 } { u0 } [ uc, uo, up ] _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [Double]) -> let {(u1 :: Double) = _!_ D# [] [1.0000000000000000##]} in _APP_  _TYAPP_  _TYAPP_  foldl { Double } { Double } [ _CONSTM_ Num (*) (Double), u1, u0 ] _N_ }, [ Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [Int]) -> let {(u1 :: Int) = _!_ I# [] [1#]} in _APP_  _TYAPP_  _TYAPP_  foldl { Int } { Int } [ _CONSTM_ Num (*) (Int), u1, u0 ] _N_ }, [ Integer ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [Integer]) -> let {(u1 :: Integer) = _#_ int2Integer# [] [1#]} in _APP_  _TYAPP_  _TYAPP_  foldl { Integer } { Integer } [ _CONSTM_ Num (*) (Integer), u1, u0 ] _N_ }, [ (Complex Double) ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ let {(u6 :: Complex Double -> Complex Double -> Complex Double) = \ (u0 :: Complex Double) (u1 :: Complex Double) -> case u0 of { _ALG_ (:+) (u2 :: Double) (u3 :: Double) -> case u1 of { _ALG_ (:+) (u4 :: Double) (u5 :: Double) -> _APP_  _WRKR_ _CONSTM_ Num (*) (Complex Double) [ u2, u3, u4, u5 ]; _NO_DEFLT_ }; _NO_DEFLT_ }} in let {(u8 :: Complex Double) = let {(u7 :: Int) = _!_ I# [] [1#]} in _APP_  _CONSTM_ Num fromInt (Complex Double) [ u7 ]} in \ (u9 :: [Complex Double]) -> _APP_  _TYAPP_  _TYAPP_  foldl { (Complex Double) } { (Complex Double) } [ u6, u8, u9 ] _N_ } #-}
products :: Num a => [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 21 _N_ _N_ _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ }, [ Int ] 1 { _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 4 \ (u0 :: [Integer]) -> _APP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeList scanl { Integer } { Integer } [ _CONSTM_ Num (*) (Integer), _SPEC_ _ORIG_ PreludeCore __i1 [ (Integer) ], u0 ] _N_ }, [ (Complex Double) ] 1 { _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ } #-}
repeat :: a -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _N_ _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: u0) -> let {(u6 :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u2 -> \ (u3 :: u0 -> u2 -> u2) (u4 :: u2) -> _LETREC_ {(u5 :: u2) = _APP_  u3 [ u1, u5 ]} in u5} in _APP_  _TYAPP_  _build { u0 } [ u6 ] _N_ #-}
reverse :: [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: [u0]) -> let {(u8 :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u2 -> \ (u3 :: u0 -> u2 -> u2) (u4 :: u2) -> let {(u7 :: u2 -> u0 -> u2) = \ (u5 :: u2) (u6 :: u0) -> _APP_  u3 [ u6, u5 ]} in _APP_  _TYAPP_  _TYAPP_  foldl { u2 } { u0 } [ u7, u4, u1 ]} in _APP_  _TYAPP_  _build { u0 } [ u8 ] _N_ #-}
scanl :: (b -> a -> b) -> b -> [a] -> [b]
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _N_ _N_ _N_ #-}
scanl1 :: (a -> a -> a) -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
scanr :: (a -> b -> b) -> b -> [a] -> [b]
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _S_ "LLS" _N_ _N_ #-}
scanr1 :: (a -> a -> a) -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
span :: (a -> Bool) -> [a] -> ([a], [a])
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ #-}
splitAt :: Integral a => a -> [b] -> ([b], [b])
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(LU(U(AAASAAAA)AAA)AAAAAAAAAS)" {_A_ 3 _U_ 11122 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(P)L" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer, _N_ ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(PPP)L" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
sum :: Num a => [a] -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _N_ _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: {{Num u0}}) -> let {(uc :: u0 -> u0 -> u0) = case u1 of { _ALG_ _TUP_10 (u2 :: {{Eq u0}}) (u3 :: {{Text u0}}) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0 -> u0) (u6 :: u0 -> u0 -> u0) (u7 :: u0 -> u0) (u8 :: u0 -> u0) (u9 :: u0 -> u0) (ua :: Integer -> u0) (ub :: Int -> u0) -> u4; _NO_DEFLT_ }} in let {(uo :: u0) = let {(ud :: Int) = _!_ I# [] [0#]} in case u1 of { _ALG_ _TUP_10 (ue :: {{Eq u0}}) (uf :: {{Text u0}}) (ug :: u0 -> u0 -> u0) (uh :: u0 -> u0 -> u0) (ui :: u0 -> u0 -> u0) (uj :: u0 -> u0) (uk :: u0 -> u0) (ul :: u0 -> u0) (um :: Integer -> u0) (un :: Int -> u0) -> _APP_  un [ ud ]; _NO_DEFLT_ }} in \ (up :: [u0]) -> _APP_  _TYAPP_  _TYAPP_  foldl { u0 } { u0 } [ uc, uo, up ] _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [Double]) -> let {(u1 :: Double) = _!_ D# [] [0.0000000000000000##]} in _APP_  _TYAPP_  _TYAPP_  foldl { Double } { Double } [ _CONSTM_ Num (+) (Double), u1, u0 ] _N_ }, [ Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [Int]) -> let {(u1 :: Int) = _!_ I# [] [0#]} in _APP_  _TYAPP_  _TYAPP_  foldl { Int } { Int } [ _CONSTM_ Num (+) (Int), u1, u0 ] _N_ }, [ Integer ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [Integer]) -> let {(u1 :: Integer) = _#_ int2Integer# [] [0#]} in _APP_  _TYAPP_  _TYAPP_  foldl { Integer } { Integer } [ _CONSTM_ Num (+) (Integer), u1, u0 ] _N_ }, [ (Complex Double) ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ let {(u6 :: Complex Double -> Complex Double -> Complex Double) = \ (u0 :: Complex Double) (u1 :: Complex Double) -> case u0 of { _ALG_ (:+) (u2 :: Double) (u3 :: Double) -> case u1 of { _ALG_ (:+) (u4 :: Double) (u5 :: Double) -> _APP_  _WRKR_ _CONSTM_ Num (+) (Complex Double) [ u2, u3, u4, u5 ]; _NO_DEFLT_ }; _NO_DEFLT_ }} in let {(u8 :: Complex Double) = let {(u7 :: Int) = _!_ I# [] [0#]} in _APP_  _CONSTM_ Num fromInt (Complex Double) [ u7 ]} in \ (u9 :: [Complex Double]) -> _APP_  _TYAPP_  _TYAPP_  foldl { (Complex Double) } { (Complex Double) } [ u6, u8, u9 ] _N_ } #-}
sums :: Num a => [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 21 _N_ _N_ _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ }, [ Int ] 1 { _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 4 \ (u0 :: [Integer]) -> _APP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeList scanl { Integer } { Integer } [ _CONSTM_ Num (+) (Integer), _SPEC_ _ORIG_ PreludeCore __i0 [ (Integer) ], u0 ] _N_ }, [ (Complex Double) ] 1 { _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ } #-}
tail :: [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _IF_ARGS_ 1 1 C 5 _/\_ u0 -> \ (u1 :: [u0]) -> case u1 of { _ALG_ (:) (u2 :: u0) (u3 :: [u0]) -> u3; _NIL_  -> _APP_  _TYAPP_  error { [u0] } [ _NOREP_S_ "tail{PreludeList}: tail []\n" ]; _NO_DEFLT_ } _N_ #-}
take :: Integral a => a -> [b] -> [b]
	{-# GHC_PRAGMA _A_ 3 _U_ 121 _N_ _S_ "SLL" _N_ _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "SL" _N_ _N_ }, [ Integer, _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "SL" _N_ _N_ } #-}
takeWhile :: (a -> Bool) -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: u0 -> Bool) (u2 :: [u0]) -> let {(u9 :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u3 -> \ (u4 :: u0 -> u3 -> u3) (u5 :: u3) -> let {(u8 :: u0 -> u3 -> u3) = \ (u6 :: u0) (u7 :: u3) -> case _APP_  u1 [ u6 ] of { _ALG_ True  -> _APP_  u4 [ u6, u7 ]; False  -> u5; _NO_DEFLT_ }} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { u3 } [ u8, u5, u2 ]} in _APP_  _TYAPP_  _build { u0 } [ u9 ] _N_ #-}
transpose :: [[a]] -> [[a]]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
unlines :: [[Char]] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [[Char]]) -> let {(u9 :: _forall_ a$z1 =>(Char -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u1 -> \ (u2 :: Char -> u1 -> u1) (u3 :: u1) -> let {(u8 :: [Char] -> u1 -> u1) = \ (u4 :: [Char]) (u5 :: u1) -> let {(u7 :: u1) = let {(u6 :: Char) = _!_ C# [] ['\o12'#]} in _APP_  u2 [ u6, u5 ]} in _APP_  _TYAPP_  _TYAPP_  foldr { Char } { u1 } [ u2, u7, u4 ]} in _APP_  _TYAPP_  _TYAPP_  foldr { [Char] } { u1 } [ u8, u3, u0 ]} in _APP_  _TYAPP_  _build { Char } [ u9 ] _N_ #-}
unwords :: [[Char]] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
unzip :: [(a, b)] -> ([a], [b])
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 u1 -> \ (u2 :: [(u0, u1)]) -> let {(u3 :: [u0]) = _!_ _NIL_ [u0] []} in let {(u4 :: [u1]) = _!_ _NIL_ [u1] []} in let {(u5 :: ([u0], [u1])) = _!_ _TUP_2 [[u0], [u1]] [u3, u4]} in let {(ui :: (u0, u1) -> ([u0], [u1]) -> ([u0], [u1])) = \ (u6 :: (u0, u1)) (u7 :: ([u0], [u1])) -> case u6 of { _ALG_ _TUP_2 (u8 :: u0) (u9 :: u1) -> let {(uc :: [u0]) = case u7 of { _ALG_ _TUP_2 (ua :: [u0]) (ub :: [u1]) -> ua; _NO_DEFLT_ }} in let {(uf :: [u1]) = case u7 of { _ALG_ _TUP_2 (ud :: [u0]) (ue :: [u1]) -> ue; _NO_DEFLT_ }} in let {(ug :: [u0]) = _!_ (:) [u0] [u8, uc]} in let {(uh :: [u1]) = _!_ (:) [u1] [u9, uf]} in _!_ _TUP_2 [[u0], [u1]] [ug, uh]; _NO_DEFLT_ }} in _APP_  _TYAPP_  _TYAPP_  foldr { (u0, u1) } { ([u0], [u1]) } [ ui, u5, u2 ] _N_ #-}
unzip3 :: [(a, b, c)] -> ([a], [b], [c])
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
words :: [Char] -> [[Char]]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [Char]) -> let {(ug :: _forall_ a$z1 =>([Char] -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u1 -> \ (u2 :: [Char] -> u1 -> u1) (u3 :: u1) -> _LETREC_ {(u4 :: [Char] -> u1) = \ (u5 :: [Char]) -> let {(u6 :: [Char]) = _APP_  _TYAPP_  _ORIG_ PreludeList dropWhile { Char } [ _ORIG_ Prelude isSpace, u5 ]} in let {(u7 :: [Char]) = _!_ _NIL_ [Char] []} in case _APP_  _CONSTM_ Eq (==) ([Char]) [ u7, u6 ] of { _ALG_ True  -> u3; False  -> let {(u8 :: ([Char], [Char])) = _APP_  _TYAPP_  _ORIG_ PreludeList break { Char } [ _ORIG_ Prelude isSpace, u6 ]} in let {(ub :: [Char]) = case u8 of { _ALG_ _TUP_2 (u9 :: [Char]) (ua :: [Char]) -> u9; _NO_DEFLT_ }} in let {(ue :: [Char]) = case u8 of { _ALG_ _TUP_2 (uc :: [Char]) (ud :: [Char]) -> ud; _NO_DEFLT_ }} in let {(uf :: u1) = _APP_  u4 [ ue ]} in _APP_  u2 [ ub, uf ]; _NO_DEFLT_ }} in _APP_  u4 [ u0 ]} in _APP_  _TYAPP_  _build { [Char] } [ ug ] _N_ #-}
zip :: [a] -> [b] -> [(a, b)]
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "SL" _F_ _ALWAYS_ _/\_ u0 u1 -> \ (u2 :: [u0]) (u3 :: [u1]) -> let {(u6 :: u0 -> u1 -> (u0, u1)) = \ (u4 :: u0) (u5 :: u1) -> _!_ _TUP_2 [u0, u1] [u4, u5]} in _APP_  _TYAPP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeList zipWith { u0 } { u1 } { (u0, u1) } [ u6, u2, u3 ] _N_ #-}
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
	{-# GHC_PRAGMA _A_ 3 _U_ 111 _N_ _S_ "SLL" _N_ _N_ #-}
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
	{-# GHC_PRAGMA _A_ 4 _U_ 1111 _N_ _S_ "SLLL" _N_ _N_ #-}
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
	{-# GHC_PRAGMA _A_ 5 _U_ 11111 _N_ _S_ "SLLLL" _N_ _N_ #-}
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]
	{-# GHC_PRAGMA _A_ 6 _U_ 111111 _N_ _S_ "SLLLLL" _N_ _N_ #-}
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]
	{-# GHC_PRAGMA _A_ 7 _U_ 1111111 _N_ _S_ "SLLLLLL" _N_ _N_ #-}
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
	{-# GHC_PRAGMA _A_ 3 _U_ 211 _N_ _S_ "LSL" _F_ _ALWAYS_ _/\_ u0 u1 u2 -> \ (u3 :: u0 -> u1 -> u2) (u4 :: [u0]) (u5 :: [u1]) -> let {(ui :: _forall_ a$z1 =>(u2 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u6 -> \ (u7 :: u2 -> u6 -> u6) (u8 :: u6) -> _LETREC_ {(u9 :: [u0] -> [u1] -> u6) = \ (ua :: [u0]) (ub :: [u1]) -> case ua of { _ALG_ _NIL_  -> u8; (:) (uc :: u0) (ud :: [u0]) -> case ub of { _ALG_ _NIL_  -> u8; (:) (ue :: u1) (uf :: [u1]) -> let {(ug :: u6) = _APP_  u9 [ ud, uf ]} in let {(uh :: u2) = _APP_  u3 [ uc, ue ]} in _APP_  u7 [ uh, ug ]; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  u9 [ u4, u5 ]} in _APP_  _TYAPP_  _build { u2 } [ ui ] _N_ #-}
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
	{-# GHC_PRAGMA _A_ 4 _U_ 2111 _N_ _S_ "LSLL" _N_ _N_ #-}
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
	{-# GHC_PRAGMA _A_ 5 _U_ 21111 _N_ _S_ "LSLLL" _N_ _N_ #-}
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
	{-# GHC_PRAGMA _A_ 6 _U_ 211111 _N_ _S_ "LSLLLL" _N_ _N_ #-}
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]
	{-# GHC_PRAGMA _A_ 7 _U_ 2111111 _N_ _S_ "LSLLLLL" _N_ _N_ #-}
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
	{-# GHC_PRAGMA _A_ 8 _U_ 21111111 _N_ _S_ "LSLLLLLL" _N_ _N_ #-}
(>>) :: (_State _RealWorld -> (Either IOError13 a, _State _RealWorld)) -> (_State _RealWorld -> (Either IOError13 b, _State _RealWorld)) -> _State _RealWorld -> (Either IOError13 b, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "SLL" _F_ _ALWAYS_ _/\_ u0 u1 -> \ (u2 :: _State _RealWorld -> (Either IOError13 u0, _State _RealWorld)) (u3 :: _State _RealWorld -> (Either IOError13 u1, _State _RealWorld)) (u4 :: _State _RealWorld) -> let {(u7 :: u0 -> _State _RealWorld -> (Either IOError13 u1, _State _RealWorld)) = \ (u5 :: u0) (u6 :: _State _RealWorld) -> _APP_  u3 [ u6 ]} in _APP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeMonadicIO (>>=) { u0 } { u1 } [ u2, u7, u4 ] _N_ #-}
(>>=) :: (_State _RealWorld -> (Either IOError13 a, _State _RealWorld)) -> (a -> _State _RealWorld -> (Either IOError13 b, _State _RealWorld)) -> _State _RealWorld -> (Either IOError13 b, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "SLL" _F_ _ALWAYS_ _/\_ u0 u1 -> \ (u2 :: _State _RealWorld -> (Either IOError13 u0, _State _RealWorld)) (u3 :: u0 -> _State _RealWorld -> (Either IOError13 u1, _State _RealWorld)) (u4 :: _State _RealWorld) -> case _APP_  u2 [ u4 ] of { _ALG_ _TUP_2 (u5 :: Either IOError13 u0) (u6 :: _State _RealWorld) -> case u5 of { _ALG_ Right (u7 :: u0) -> _APP_  u3 [ u7, u6 ]; Left (u8 :: IOError13) -> let {(u9 :: Either IOError13 u1) = _!_ Left [IOError13, u1] [u8]} in case u6 of { _ALG_ S# (ua :: State# _RealWorld) -> _!_ _TUP_2 [(Either IOError13 u1), (_State _RealWorld)] [u9, u6]; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ #-}
accumulate :: [_State _RealWorld -> (Either IOError13 a, _State _RealWorld)] -> _State _RealWorld -> (Either IOError13 [a], _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "SL" _N_ _N_ #-}
either :: (a -> c) -> (b -> c) -> Either a b -> c
	{-# GHC_PRAGMA _A_ 3 _U_ 111 _N_ _S_ "LLS" _F_ _IF_ARGS_ 3 3 XXC 6 _/\_ u0 u1 u2 -> \ (u3 :: u0 -> u2) (u4 :: u1 -> u2) (u5 :: Either u0 u1) -> case u5 of { _ALG_ Left (u6 :: u0) -> _APP_  u3 [ u6 ]; Right (u7 :: u1) -> _APP_  u4 [ u7 ]; _NO_DEFLT_ } _N_ #-}
fail :: [Char] -> _State _RealWorld -> (Either IOError13 a, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LU(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
failWith :: IOError13 -> _State _RealWorld -> (Either IOError13 a, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "LS" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: IOError13) (u2 :: _State _RealWorld) -> let {(u3 :: Either IOError13 u0) = _!_ Left [IOError13, u0] [u1]} in case u2 of { _ALG_ S# (u4 :: State# _RealWorld) -> _!_ _TUP_2 [(Either IOError13 u0), (_State _RealWorld)] [u3, u2]; _NO_DEFLT_ } _N_ #-}
handle :: (_State _RealWorld -> (Either IOError13 a, _State _RealWorld)) -> (IOError13 -> _State _RealWorld -> (Either IOError13 a, _State _RealWorld)) -> _State _RealWorld -> (Either IOError13 a, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "SLL" _N_ _N_ #-}
return :: a -> _State _RealWorld -> (Either IOError13 a, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "LS" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: u0) (u2 :: _State _RealWorld) -> let {(u3 :: Either IOError13 u0) = _!_ Right [IOError13, u0] [u1]} in case u2 of { _ALG_ S# (u4 :: State# _RealWorld) -> _!_ _TUP_2 [(Either IOError13 u0), (_State _RealWorld)] [u3, u2]; _NO_DEFLT_ } _N_ #-}
sequence :: [_State _RealWorld -> (Either IOError13 a, _State _RealWorld)] -> _State _RealWorld -> (Either IOError13 (), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "SL" _N_ _N_ #-}
try :: (_State _RealWorld -> (Either IOError13 a, _State _RealWorld)) -> _State _RealWorld -> (Either IOError13 (Either IOError13 a), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "SL" _N_ _N_ #-}
_appendPS :: _PackedString -> _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "SS" _N_ _N_ #-}
_breakPS :: (Char -> Bool) -> _PackedString -> (_PackedString, _PackedString)
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
_byteArrayToPS :: _ByteArray Int -> _PackedString
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(U(U(P)U(P))P)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
_concatPS :: [_PackedString] -> _PackedString
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
_consPS :: Char -> _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _N_ _N_ _N_ #-}
_dropPS :: Int -> _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "U(P)S" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
_dropWhilePS :: (Char -> Bool) -> _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ #-}
_filterPS :: (Char -> Bool) -> _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
_foldlPS :: (a -> Char -> a) -> a -> _PackedString -> a
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _S_ "LLS" _N_ _N_ #-}
_foldrPS :: (Char -> a -> a) -> a -> _PackedString -> a
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _S_ "LLS" _N_ _N_ #-}
_headPS :: _PackedString -> Char
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
_indexPS :: _PackedString -> Int -> Char
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "SU(P)" {_A_ 2 _U_ 12 _N_ _N_ _N_ _N_} _N_ _N_ #-}
_lengthPS :: _PackedString -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _IF_ARGS_ 0 1 C 6 \ (u0 :: _PackedString) -> case u0 of { _ALG_ _PS (u1 :: ByteArray#) (u2 :: Int#) (u3 :: Bool) -> _!_ I# [] [u2]; _CPS (u4 :: Addr#) (u5 :: Int#) -> _!_ I# [] [u5]; _NO_DEFLT_ } _N_ #-}
_linesPS :: _PackedString -> [_PackedString]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
_mapPS :: (Char -> Char) -> _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
_nilPS :: _PackedString
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _CPS [] [""#, 0#] _N_ #-}
_nullPS :: _PackedString -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _IF_ARGS_ 0 1 C 6 \ (u0 :: _PackedString) -> case u0 of { _ALG_ _PS (u1 :: ByteArray#) (u2 :: Int#) (u3 :: Bool) -> case u2 of { _PRIM_ 0# -> _!_ True [] []; (u4 :: Int#) -> _!_ False [] [] }; _CPS (u5 :: Addr#) (u6 :: Int#) -> case u6 of { _PRIM_ 0# -> _!_ True [] []; (u7 :: Int#) -> _!_ False [] [] }; _NO_DEFLT_ } _N_ #-}
_packCBytes :: Int -> _Addr -> _PackedString
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
_packCString :: _Addr -> _PackedString
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
_packString :: [Char] -> _PackedString
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
_psToByteArray :: _PackedString -> _ByteArray Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
_putPS :: _FILE -> _PackedString -> _State _RealWorld -> ((), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 3 _U_ 111 _N_ _S_ "LSU(P)" {_A_ 3 _U_ 112 _N_ _N_ _N_ _N_} _N_ _N_ #-}
_reversePS :: _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
_spanPS :: (Char -> Bool) -> _PackedString -> (_PackedString, _PackedString)
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
_splitAtPS :: Int -> _PackedString -> (_PackedString, _PackedString)
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
_substrPS :: _PackedString -> Int -> Int -> _PackedString
	{-# GHC_PRAGMA _A_ 3 _U_ 211 _N_ _S_ "SU(P)U(P)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
_tailPS :: _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
_takePS :: Int -> _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "U(P)S" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 5 \ (u0 :: Int#) (u1 :: _PackedString) -> case _#_ minusInt# [] [u0, 1#] of { _PRIM_ (u2 :: Int#) -> _APP_  _WRKR_ _ORIG_ PreludePS _substrPS [ u1, 0#, u2 ] } _N_} _F_ _ALWAYS_ \ (u0 :: Int) (u1 :: _PackedString) -> case u0 of { _ALG_ I# (u2 :: Int#) -> case _#_ minusInt# [] [u2, 1#] of { _PRIM_ (u3 :: Int#) -> _APP_  _WRKR_ _ORIG_ PreludePS _substrPS [ u1, 0#, u3 ] }; _NO_DEFLT_ } _N_ #-}
_takeWhilePS :: (Char -> Bool) -> _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ #-}
_unpackPS :: _PackedString -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
_wordsPS :: _PackedString -> [_PackedString]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
(%) :: Integral a => a -> a -> Ratio a
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(U(U(U(SA)AAALALLAL)AA)ALLAAAAAAAA)" {_A_ 3 _U_ 12222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Integer ] 1 { _A_ 2 _U_ 11 _N_ _S_ "LU(PPP)" {_A_ 4 _U_ 1222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
approxRational :: RealFrac a => a -> a -> Ratio Integer
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _S_ "U(U(LU(U(ASAALAAA)AAAA)L)AAAAAA)LL" {_A_ 5 _U_ 21222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Double ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
denominator :: Ratio a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(AS)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: Ratio u0) -> case u1 of { _ALG_ (:%) (u2 :: u0) (u3 :: u0) -> u3; _NO_DEFLT_ } _N_ #-}
numerator :: Ratio a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(SA)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: Ratio u0) -> case u1 of { _ALG_ (:%) (u2 :: u0) (u3 :: u0) -> u2; _NO_DEFLT_ } _N_ #-}
getChar :: _State _RealWorld -> (Either IOError13 Char, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 4 \ (u0 :: State# _RealWorld) -> case _ORIG_ PreludeStdIO stdin13 of { _ALG_ _MVar (u1 :: SynchVar# _RealWorld _Handle) -> _APP_  _WRKR_ _ORIG_ PreludeReadTextIO hGetChar [ u1, u0 ]; _NO_DEFLT_ } _N_} _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: _State _RealWorld) -> _APP_  _ORIG_ PreludeReadTextIO hGetChar [ _ORIG_ PreludeStdIO stdin13, u0 ] _N_ #-}
hGetChar :: _MVar _Handle -> _State _RealWorld -> (Either IOError13 Char, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hGetContents :: _MVar _Handle -> _State _RealWorld -> (Either IOError13 [Char], _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hLookAhead :: _MVar _Handle -> _State _RealWorld -> (Either IOError13 Char, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hReady :: _MVar _Handle -> _State _RealWorld -> (Either IOError13 Bool, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
readFile :: [Char] -> _State _RealWorld -> (Either IOError13 [Char], _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LU(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hClose :: _MVar _Handle -> _State _RealWorld -> (Either IOError13 (), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hFileSize :: _MVar _Handle -> _State _RealWorld -> (Either IOError13 Integer, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hFlush :: _MVar _Handle -> _State _RealWorld -> (Either IOError13 (), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hGetPosn :: _MVar _Handle -> _State _RealWorld -> (Either IOError13 (_MVar _Handle, Int), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hIsBlockBuffered :: _MVar _Handle -> _State _RealWorld -> (Either IOError13 (Bool, Maybe Int), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hIsClosed :: _MVar _Handle -> _State _RealWorld -> (Either IOError13 Bool, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hIsEOF :: _MVar _Handle -> _State _RealWorld -> (Either IOError13 Bool, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hIsLineBuffered :: _MVar _Handle -> _State _RealWorld -> (Either IOError13 Bool, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hIsNotBuffered :: _MVar _Handle -> _State _RealWorld -> (Either IOError13 Bool, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hIsOpen :: _MVar _Handle -> _State _RealWorld -> (Either IOError13 Bool, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hIsReadable :: _MVar _Handle -> _State _RealWorld -> (Either IOError13 Bool, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hIsSeekable :: _MVar _Handle -> _State _RealWorld -> (Either IOError13 Bool, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hIsWritable :: _MVar _Handle -> _State _RealWorld -> (Either IOError13 Bool, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hSeek :: _MVar _Handle -> SeekMode -> Integer -> _State _RealWorld -> (Either IOError13 (), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 4 _U_ 1111 _N_ _S_ "U(P)LU(PPP)U(P)" {_A_ 4 _U_ 2112 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hSetBuffering :: _MVar _Handle -> BufferMode -> _State _RealWorld -> (Either IOError13 (), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 3 _U_ 121 _N_ _S_ "LSU(P)" {_A_ 3 _U_ 122 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hSetPosn :: (_MVar _Handle, Int) -> _State _RealWorld -> (Either IOError13 (), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(U(P)L)U(P)" {_A_ 3 _U_ 212 _N_ _N_ _N_ _N_} _N_ _N_ #-}
isEOF :: _State _RealWorld -> (Either IOError13 Bool, _State _RealWorld)
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 4 \ (u0 :: State# _RealWorld) -> case _ORIG_ PreludeStdIO stdin13 of { _ALG_ _MVar (u1 :: SynchVar# _RealWorld _Handle) -> _APP_  _WRKR_ _ORIG_ PreludeStdIO hIsEOF [ u1, u0 ]; _NO_DEFLT_ } _N_} _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: _State _RealWorld) -> _APP_  _ORIG_ PreludeStdIO hIsEOF [ _ORIG_ PreludeStdIO stdin13, u0 ] _N_ #-}
openFile :: [Char] -> IOMode -> _State _RealWorld -> (Either IOError13 (_MVar _Handle), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _S_ "LLU(P)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
stderr :: _MVar _Handle
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _N_ _N_ #-}
stdin :: _MVar _Handle
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _N_ _N_ #-}
stdout :: _MVar _Handle
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _N_ _N_ #-}
_readRational :: [Char] -> Ratio Integer
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
_showDigit :: Int -> Char
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
_showHex :: Int -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _N_ _N_ _N_ #-}
_showRadix :: Int -> Int -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "U(P)U(P)L" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
lex :: [Char] -> [([Char], [Char])]
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
read :: Text a => [Char] -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "U(SAAA)" {_A_ 1 _U_ 12 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Bool ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ Char ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ Double ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ Int ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Bool] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Char] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Double] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Float] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Int] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Integer] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [[Char]] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [[Int]] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Complex Double] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Ratio Integer) ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Array Int Double) ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Array (Int, Int) Double) ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ _PackedString ] 1 { _A_ 1 _U_ 2 _N_ _S_ _!_ _N_ _N_ }, [ (Complex Double) ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ () ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Int, Int) ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Integer, Integer) ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Int, Int, Int) ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ } #-}
readDec :: Integral a => [Char] -> [(a, [Char])]
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _N_ _N_ _SPECIALISE_ [ Int ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ }, [ Integer ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ } #-}
readFloat :: RealFloat a => [Char] -> [(a, [Char])]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "LS" _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ } #-}
readLitChar :: [Char] -> [(Char, [Char])]
	{-# GHC_PRAGMA _A_ 0 _U_ 1 _N_ _N_ _N_ _N_ #-}
readParen :: Bool -> ([Char] -> [(a, [Char])]) -> [Char] -> [(a, [Char])]
	{-# GHC_PRAGMA _A_ 2 _U_ 122 _N_ _S_ "EL" _N_ _N_ #-}
readSigned :: Real a => ([Char] -> [(a, [Char])]) -> [Char] -> [(a, [Char])]
	{-# GHC_PRAGMA _A_ 2 _U_ 122 _N_ _N_ _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 22 _N_ _N_ _N_ _N_ }, [ Int ] 1 { _A_ 1 _U_ 22 _N_ _N_ _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 22 _N_ _N_ _N_ _N_ } #-}
reads :: Text a => [Char] -> [(a, [Char])]
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "U(SAAA)" {_A_ 1 _U_ 12 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Bool ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ Char ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ }, [ Double ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ Int ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Bool] ] 1 { _A_ 0 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text readList (Bool) _N_ }, [ [Char] ] 1 { _A_ 0 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text readList (Char) _N_ }, [ [Double] ] 1 { _A_ 0 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text readList (Double) _N_ }, [ [Float] ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Int] ] 1 { _A_ 0 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text readList (Int) _N_ }, [ [Integer] ] 1 { _A_ 0 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text readList (Integer) _N_ }, [ [[Char]] ] 1 { _A_ 0 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text readList ([Char]) _N_ }, [ [[Int]] ] 1 { _A_ 0 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text readList ([Int]) _N_ }, [ [Complex Double] ] 1 { _A_ 0 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text readList (Complex Double) _N_ }, [ (Ratio Integer) ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Array Int Double) ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Array (Int, Int) Double) ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ }, [ _PackedString ] 1 { _A_ 1 _U_ 2 _N_ _S_ _!_ _N_ _N_ }, [ (Complex Double) ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ }, [ () ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Int, Int) ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Integer, Integer) ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Int, Int, Int) ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ } #-}
show :: Text a => a -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "U(ASAA)" {_A_ 1 _U_ 12 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Bool ] 1 { _A_ 1 _U_ 2 _N_ _S_ "E" _N_ _N_ }, [ Char ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Double ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(PPP)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ [Bool] ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ }, [ [Char] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Double] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Int] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Integer] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [[Char]] ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ }, [ [[Int]] ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ }, [ [Complex Double] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Ratio Integer) ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(LL)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Array Int Double) ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Array (Int, Int) Double) ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ _PackedString ] 1 { _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ }, [ (Complex Double) ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(LL)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ () ] 1 { _A_ 1 _U_ 1 _N_ _S_ "E" _F_ _IF_ARGS_ 0 1 C 5 \ (u0 :: ()) -> case u0 of { _ALG_ _TUP_0  -> _NOREP_S_ "()"; _NO_DEFLT_ } _N_ }, [ (Int, Int) ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(LL)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Integer, Integer) ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(LL)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Int, Int, Int) ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(LLL)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
showChar :: Char -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Char) (u1 :: [Char]) -> _!_ (:) [Char] [u0, u1] _N_ #-}
showFloat :: RealFloat a => a -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(U(AU(SAAA)AAAAL)LLLALAAAA)" {_A_ 5 _U_ 1122222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 12 _N_ _S_ "U(P)" {_A_ 1 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
showInt :: Integral a => a -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 222 _N_ _S_ "U(U(U(U(SL)LLLLLLLLL)LL)LLLLLSLLLLL)" _N_ _SPECIALISE_ [ Int ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(P)L" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(PPP)L" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
showLitChar :: Char -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 0 _U_ 22 _N_ _N_ _N_ _N_ #-}
showParen :: Bool -> ([Char] -> [Char]) -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 0 _U_ 122 _N_ _N_ _N_ _N_ #-}
showSigned :: Real a => (a -> [Char] -> [Char]) -> Int -> a -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 12222 _N_ _S_ "U(LU(U(ASAAAAAA)AAAA)A)" {_A_ 2 _U_ 212122 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Double ] 1 { _A_ 3 _U_ 2112 _N_ _S_ "LLU(P)" {_A_ 3 _U_ 2122 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Int ] 1 { _A_ 4 _U_ 0112 _N_ _S_ "ALU(P)L" {_A_ 3 _U_ 122 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer ] 1 { _A_ 4 _U_ 0112 _N_ _S_ "ALU(PPP)L" {_A_ 5 _U_ 12222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
showSpace__ :: [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ #-}
showString :: [Char] -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _TYAPP_  _ORIG_ PreludeList (++) { Char } _N_ #-}
shows :: Text a => a -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(ASAA)" {_A_ 1 _U_ 122 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Bool ] 1 { _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ }, [ Char ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(P)L" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Double ] 1 { _A_ 1 _U_ 12 _N_ _S_ "U(P)" {_A_ 1 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Int ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(P)L" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(PPP)L" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ [Bool] ] 1 { _A_ 1 _U_ 12 _N_ _S_ "S" _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: [Bool]) -> _APP_  _TYAPP_  _ORIG_ PreludeCore _showList { Bool } [ _WRKR_ _CONSTM_ Text showsPrec (Bool), u0 ] _N_ }, [ [Char] ] 1 { _A_ 1 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text showList (Char) _N_ }, [ [Double] ] 1 { _A_ 1 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text showList (Double) _N_ }, [ [Int] ] 1 { _A_ 1 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text showList (Int) _N_ }, [ [Integer] ] 1 { _A_ 1 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text showList (Integer) _N_ }, [ [[Char]] ] 1 { _A_ 1 _U_ 12 _N_ _S_ "S" _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: [[Char]]) -> _APP_  _TYAPP_  _ORIG_ PreludeCore _showList { [Char] } [ _CONSTM_ Text showList (Char), u0 ] _N_ }, [ [[Int]] ] 1 { _A_ 1 _U_ 12 _N_ _S_ "S" _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: [[Int]]) -> _APP_  _TYAPP_  _ORIG_ PreludeCore _showList { [Int] } [ _CONSTM_ Text showList (Int), u0 ] _N_ }, [ [Complex Double] ] 1 { _A_ 1 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text showList (Complex Double) _N_ }, [ (Ratio Integer) ] 1 { _A_ 1 _U_ 12 _N_ _S_ "U(LL)" {_A_ 2 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Array Int Double) ] 1 { _A_ 1 _U_ 22 _N_ _N_ _N_ _N_ }, [ (Array (Int, Int) Double) ] 1 { _A_ 1 _U_ 22 _N_ _N_ _N_ _N_ }, [ _PackedString ] 1 { _A_ 2 _U_ 12 _N_ _N_ _N_ _N_ }, [ (Complex Double) ] 1 { _A_ 1 _U_ 12 _N_ _S_ "U(LL)" {_A_ 2 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ () ] 1 { _A_ 2 _U_ 12 _N_ _S_ "EL" _F_ _IF_ARGS_ 0 2 CX 4 \ (u0 :: ()) (u1 :: [Char]) -> case u0 of { _ALG_ _TUP_0  -> _APP_  unpackAppendPS# [ "()"#, u1 ]; _NO_DEFLT_ } _N_ }, [ (Int, Int) ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(LL)L" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Integer, Integer) ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(LL)L" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Int, Int, Int) ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(LLL)L" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
appendFile :: [Char] -> [Char] -> _State _RealWorld -> (Either IOError13 (), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _S_ "LLU(P)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hPutChar :: _MVar _Handle -> Char -> _State _RealWorld -> (Either IOError13 (), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 3 _U_ 111 _N_ _S_ "U(P)LU(P)" {_A_ 3 _U_ 212 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hPutStr :: _MVar _Handle -> [Char] -> _State _RealWorld -> (Either IOError13 (), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 3 _U_ 121 _N_ _S_ "U(P)LU(P)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
hPutText :: Text a => _MVar _Handle -> a -> _State _RealWorld -> (Either IOError13 (), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 1 _U_ 1121 _N_ _N_ _N_ _N_ #-}
print :: Text a => a -> _State _RealWorld -> (Either IOError13 (), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 1 _U_ 121 _N_ _N_ _N_ _N_ #-}
putChar :: Char -> _State _RealWorld -> (Either IOError13 (), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _N_ _F_ _IF_ARGS_ 0 2 XC 6 \ (u0 :: Char) (u1 :: _State _RealWorld) -> case _ORIG_ PreludeStdIO stdout13 of { _ALG_ _MVar (u2 :: SynchVar# _RealWorld _Handle) -> case u1 of { _ALG_ S# (u3 :: State# _RealWorld) -> _APP_  _WRKR_ _ORIG_ PreludeWriteTextIO hPutChar [ u2, u0, u3 ]; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ #-}
putStr :: [Char] -> _State _RealWorld -> (Either IOError13 (), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _N_ _F_ _IF_ARGS_ 0 2 XC 6 \ (u0 :: [Char]) (u1 :: _State _RealWorld) -> case _ORIG_ PreludeStdIO stdout13 of { _ALG_ _MVar (u2 :: SynchVar# _RealWorld _Handle) -> case u1 of { _ALG_ S# (u3 :: State# _RealWorld) -> _APP_  _WRKR_ _ORIG_ PreludeWriteTextIO hPutStr [ u2, u0, u3 ]; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ #-}
putText :: Text a => a -> _State _RealWorld -> (Either IOError13 (), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 1 _U_ 121 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 3 _/\_ u0 -> \ (u1 :: {{Text u0}}) -> _APP_  _TYAPP_  _ORIG_ PreludeWriteTextIO hPutText { u0 } [ u1, _ORIG_ PreludeStdIO stdout13 ] _N_ #-}
writeFile :: [Char] -> [Char] -> _State _RealWorld -> (Either IOError13 (), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _S_ "LLU(P)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}

