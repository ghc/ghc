/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2004
 *
 * Entry code for various built-in closure types.
 *
 * This file is written in a subset of C--, extended with various
 * features specific to GHC.  It is compiled by GHC directly.  For the
 * syntax of .cmm files, see the parser in ghc/compiler/GHC/Cmm/Parser.y.
 *
 * --------------------------------------------------------------------------*/

#include "Cmm.h"

import pthread_mutex_lock;
import AcquireSRWLockExclusive;
import ReleaseSRWLockExclusive;

#if defined(PROF_SPIN)
import whitehole_lockClosure_spin;
import whitehole_lockClosure_yield;
#endif

#if !defined(UnregisterisedCompiler)
import CLOSURE CCS_SYSTEM;
import CLOSURE ENT_DYN_IND_ctr;
import CLOSURE ENT_STATIC_IND_ctr;
import CLOSURE ENT_VIA_NODE_ctr;
import CLOSURE RtsFlags;
import CLOSURE stg_BLOCKING_QUEUE_CLEAN_info;
import CLOSURE stg_BLOCKING_QUEUE_DIRTY_info;
import CLOSURE stg_END_TSO_QUEUE_closure;
import CLOSURE stg_IND_info;
import CLOSURE stg_MSG_BLACKHOLE_info;
import CLOSURE stg_TSO_info;
import CLOSURE stg_apply_interp_info;
import CLOSURE stg_enter_info;
import CLOSURE stg_ret_d_info;
import CLOSURE stg_ret_f_info;
import CLOSURE stg_ret_l_info;
import CLOSURE stg_ret_n_info;
import CLOSURE stg_ret_p_info;
import CLOSURE stg_ret_t_info;
import CLOSURE stg_ret_v_info;
#endif

/* See Note [Original thunk info table frames] in GHC.StgToCmm.Bind. */
INFO_TABLE_RET (stg_orig_thunk_info_frame, RET_SMALL,
                W_ info_ptr,
                W_ thunk_info_ptr)
    /* no args => explicit stack */
{

    /*
    !!!!!!!!!!!!!!!!!
    !!! IMPORTANT !!!
    !!!!!!!!!!!!!!!!!

    The body of this function MUST NOT use any floating-point
    or vector registers. See Note [Frames intercepting frames].
    */

    unwind Sp = W_[Sp + SIZEOF_StgOrigThunkInfoFrame];
    Sp = Sp + SIZEOF_StgOrigThunkInfoFrame;
    jump %ENTRY_CODE(Sp(0)) GP_ARG_REGS; // NB. all GP arg regs live!
}

/*
Note [Frames intercepting frames]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
A frame which "intercepts" the following frame (to do additional work or
manipulate the stack, such as `stg_orig_thunk_info_frame`) must take care to
passthrough all the registers and arguments when it returns to the next frame.
This is done by jumping with GP_ARG_REGS as in:

    jump %ENTRY_CODE(Sp(0)) GP_ARG_REGS; // NB. all GP arg regs live!

However, special care must be taken when these arguments are propagated:

The body of such a function MUST NOT use any floating-point
or vector registers. DO NOT add any e.g. debug printing logic that
has any chance whatsoever of using floating-point or vector registers.
If you DO want to edit the function in such a way that it may use
vector registers, you will need to define multiple different copies
of the function, as we do e.g. for stg_stack_underflow_frame
(see Jumps.h).

See Note [realArgRegsCover] in GHC.Cmm.CallConv for more details.
*/

/* ----------------------------------------------------------------------------
   Restore a saved cost centre
   ------------------------------------------------------------------------- */

INFO_TABLE_RET (stg_restore_cccs_eval, RET_SMALL, W_ info_ptr, W_ cccs)
    return (P_ ret)
{
    unwind Sp = Sp + WDS(2);
#if defined(PROFILING)
    CCCS = cccs;
#endif
    jump stg_ap_0_fast(ret);
}

/* ----------------------------------------------------------------------------
   Support for the bytecode interpreter.
   ------------------------------------------------------------------------- */

/* 7 bits of return code for constructors created by the interpreter. */
stg_interp_constr1_entry (P_ ret) { return (ret + 1); }
stg_interp_constr2_entry (P_ ret) { return (ret + 2); }
stg_interp_constr3_entry (P_ ret) { return (ret + 3); }
stg_interp_constr4_entry (P_ ret) { return (ret + 4); }
stg_interp_constr5_entry (P_ ret) { return (ret + 5); }
stg_interp_constr6_entry (P_ ret) { return (ret + 6); }
stg_interp_constr7_entry (P_ ret) { return (ret + 7); }

/* Some info tables to be used when compiled code returns a value to
   the interpreter, i.e. the interpreter pushes one of these onto the
   stack before entering a value.  What the code does is to
   impedance-match the compiled return convention (in R1p/R1n/F1/D1 etc) to
   the interpreter's convention (returned value is on top of stack),
   and then cause the scheduler to enter the interpreter.

   On entry, the stack (growing down) looks like this:

      ptr to BCO holding return continuation
      ptr to one of these info tables.

   The info table code, both direct and vectored, must:
      * push R1/F1/D1 on the stack, and its tag if necessary
      * push the BCO (so it's now on the stack twice)
      * Yield, ie, go to the scheduler.

   Scheduler examines the t.o.s, discovers it is a BCO, and proceeds
   directly to the bytecode interpreter.  That pops the top element
   (the BCO, containing the return continuation), and interprets it.
   Net result: return continuation gets interpreted, with the
   following stack:

      ptr to this BCO
      ptr to the info table just jumped thru
      return value

   which is just what we want -- the "standard" return layout for the
   interpreter.  Hurrah!
*/

INFO_TABLE_RET( stg_ctoi_R1p, RET_BCO)
    /* explicit stack */
{
    Sp_adj(-2);
    Sp(1) = R1;
    Sp(0) = stg_ret_p_info;
    jump stg_yield_to_interpreter [];
}

/*
 * When the returned value is a non-pointer in R1 ...
 */
INFO_TABLE_RET( stg_ctoi_R1n, RET_BCO )
    /* explicit stack */
{
    Sp_adj(-2);
    Sp(1) = R1;
    Sp(0) = stg_ret_n_info;
    jump stg_yield_to_interpreter [];
}

/*
 * When the returned value is in F1
 */
INFO_TABLE_RET( stg_ctoi_F1, RET_BCO )
    /* explicit stack */
{
    Sp_adj(-2);
    F_[Sp + WDS(1)] = F1;
    Sp(0) = stg_ret_f_info;
    jump stg_yield_to_interpreter [];
}

/*
 * When the returned value is in D1
 */
INFO_TABLE_RET( stg_ctoi_D1, RET_BCO )
    /* explicit stack */
{
    Sp_adj(-1) - SIZEOF_DOUBLE;
    D_[Sp + WDS(1)] = D1;
    Sp(0) = stg_ret_d_info;
    jump stg_yield_to_interpreter [];
}

/*
 * When the returned value is in L1
 */
INFO_TABLE_RET( stg_ctoi_L1, RET_BCO )
    /* explicit stack */
{
    Sp_adj(-1) - 8;
    L_[Sp + WDS(1)] = L1;
    Sp(0) = stg_ret_l_info;
    jump stg_yield_to_interpreter [];
}

/*
 * When the returned value is a void
 */
INFO_TABLE_RET( stg_ctoi_V, RET_BCO )
    /* explicit stack */
{
    Sp_adj(-1);
    Sp(0) = stg_ret_v_info;
    jump stg_yield_to_interpreter [];
}

/*   Note [GHCi unboxed tuples stack spills]
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   In the calling convention for compiled code, a tuple is returned
   in registers, with everything that doesn't fit spilled onto the STG
   stack.

   At the time the continuation is called, Sp points to the highest word
   used on the stack:

       ...
       stg_ctoi_t  (next stack frame, continuation)
       spilled_1
       spilled_2
       spilled_3   <- Sp

   This makes it difficult to write a procedure that can handle tuples of
   any size.

   To get around this, we use a Cmm procedure that adjusts the stack pointer
   to skip over the tuple:

       ...
       stg_ctoi_t3  (advances Sp by 3 words, then calls stg_ctoi_t)
       spilled_1
       spilled_2
       spilled_3    <- Sp

   When stg_ctoi_t is called, the stack looks like:

       ...
       tuple_BCO
       tuple_info
       cont_BCO     (continuation in bytecode)
       stg_ctoi_t3  <- Sp
       spilled_1
       spilled_2
       spilled_3

   stg_ctoi_t then reads the tuple_info word to determine the registers
   to save onto the stack and construct a call to tuple_BCO. Afterwards the
   stack looks as follows:

       ...
       tuple_BCO
       tuple_info
       cont_BCO
       stg_ctoi_t3
       spilled_1
       spilled_2
       spilled_3
       saved_R2
       saved_R1
       saved_D3
       ...
       tuple_BCO
       stg_apply_interp <- Sp


   tuple_BCO contains the bytecode instructions to return the tuple to
   cont_BCO. The bitmap in tuple_BCO describes the contents of
   the tuple to the storage manager.

   At this point we can safely jump to the interpreter.

 */

#define MK_STG_CTOI_T(N) INFO_TABLE_RET( \
  stg_ctoi_t ## N, RET_BCO ) \
  { Sp_adj(N); jump stg_ctoi_t SCALAR_ARG_REGS; }

MK_STG_CTOI_T(0)
MK_STG_CTOI_T(1)
MK_STG_CTOI_T(2)
MK_STG_CTOI_T(3)
MK_STG_CTOI_T(4)
MK_STG_CTOI_T(5)
MK_STG_CTOI_T(6)
MK_STG_CTOI_T(7)
MK_STG_CTOI_T(8)
MK_STG_CTOI_T(9)

MK_STG_CTOI_T(10)
MK_STG_CTOI_T(11)
MK_STG_CTOI_T(12)
MK_STG_CTOI_T(13)
MK_STG_CTOI_T(14)
MK_STG_CTOI_T(15)
MK_STG_CTOI_T(16)
MK_STG_CTOI_T(17)
MK_STG_CTOI_T(18)
MK_STG_CTOI_T(19)

MK_STG_CTOI_T(20)
MK_STG_CTOI_T(21)
MK_STG_CTOI_T(22)
MK_STG_CTOI_T(23)
MK_STG_CTOI_T(24)
MK_STG_CTOI_T(25)
MK_STG_CTOI_T(26)
MK_STG_CTOI_T(27)
MK_STG_CTOI_T(28)
MK_STG_CTOI_T(29)

MK_STG_CTOI_T(30)
MK_STG_CTOI_T(31)
MK_STG_CTOI_T(32)
MK_STG_CTOI_T(33)
MK_STG_CTOI_T(34)
MK_STG_CTOI_T(35)
MK_STG_CTOI_T(36)
MK_STG_CTOI_T(37)
MK_STG_CTOI_T(38)
MK_STG_CTOI_T(39)

MK_STG_CTOI_T(40)
MK_STG_CTOI_T(41)
MK_STG_CTOI_T(42)
MK_STG_CTOI_T(43)
MK_STG_CTOI_T(44)
MK_STG_CTOI_T(45)
MK_STG_CTOI_T(46)
MK_STG_CTOI_T(47)
MK_STG_CTOI_T(48)
MK_STG_CTOI_T(49)

MK_STG_CTOI_T(50)
MK_STG_CTOI_T(51)
MK_STG_CTOI_T(52)
MK_STG_CTOI_T(53)
MK_STG_CTOI_T(54)
MK_STG_CTOI_T(55)
MK_STG_CTOI_T(56)
MK_STG_CTOI_T(57)
MK_STG_CTOI_T(58)
MK_STG_CTOI_T(59)

MK_STG_CTOI_T(60)
MK_STG_CTOI_T(61)
MK_STG_CTOI_T(62)

/*
  Convert a tuple return value to be used in bytecode.

  See Note [GHCi and native call registers] for information on how
  values are moved between the stack and registers.
 */

stg_ctoi_t
    /* explicit stack */
{

    W_ tuple_info, tuple_stack;
    P_ tuple_BCO;

    tuple_info = Sp(2); /* tuple information word */
    tuple_BCO  = Sp(3); /* bytecode object that returns the tuple in
                           the interpreter */

#if defined(PROFILING)
    CCCS = Sp(4);
#endif

    /* number of words spilled on stack */
    tuple_stack  = (tuple_info >> 24) & 0xff;

    Sp = Sp - WDS(tuple_stack);

    PUSH_SCALAR_ARG_REGS(tuple_info);

    /* jump to the BCO that will finish the return of the tuple */
    Sp_adj(-3);
    Sp(2) = tuple_info;
    Sp(1) = tuple_BCO;
    Sp(0) = stg_ret_t_info;

    jump stg_yield_to_interpreter [];
}

INFO_TABLE_RET( stg_ret_t, RET_BCO )
{
    W_ tuple_info, tuple_stack;

    tuple_info = Sp(2);
    Sp_adj(3);

    /* number of words spilled on stack */
    tuple_stack  = (tuple_info >> 24) & 0xff;

    POP_SCALAR_ARG_REGS(tuple_info);

    /* Sp points to the topmost argument now */
    jump %ENTRY_CODE(Sp(tuple_stack)) SCALAR_ARG_REGS; // NB. all scalar registers live!
}


 /*

    The stg_primcall frame is used by the bytecode interpreter to call
    a Cmm function. The frame contains a call_info word that contains
    a bitmap describing the register arguments.

    When the target function is called, Sp points to the topmost stack
    argument.

       ...
       next_stack_frame
       arg_1
       arg_2
       ...
       arg_n
       target_funptr       (pointer to the function we're calling)
       call_info           (describes the registers containing the arguments)
       primcall_BCO        (contains bitmap describing pointers in args)
       stg_primcall_info   <- Sp

    See Note [GHCi and native call registers] for information on the call_info
    word and how registers are moved between the stack and registers.

 */

INFO_TABLE_RET ( stg_primcall, RET_BCO )
{
    W_ args_info, prim_fun;

    /* Sp(1) would be the BCO containing the stack description bitmap */
    args_info = Sp(2);
    prim_fun = Sp(3);

    Sp_adj(4);

    /* Sp points to the top of the register arguments now,
       load them into actual registers */
    POP_SCALAR_ARG_REGS(args_info);

    /* Sp points to the topmost stack argument now */

    jump prim_fun SCALAR_ARG_REGS; // NB. all scalar registers live!
}

/*
 * Dummy info table pushed on the top of the stack when the interpreter
 * should apply the BCO on the stack to its arguments, also on the
 * stack.
 */
INFO_TABLE_RET( stg_apply_interp, RET_BCO )
    /* explicit stack */
{
    /* Just in case we end up in here... (we shouldn't) */
    jump stg_yield_to_interpreter [];
}

/*
 * Dummy info table pushed on the top of the stack when the stack's
 * owning thread has finished.
 */
INFO_TABLE_RET( stg_dead_thread, RET_SMALL,
                W_ info_ptr,
                PROF_HDR_FIELDS(W_,p1,p2)
                P_ result )
{ foreign "C" barf("stg_dead_thread entered!", NULL) never returns; }

/* ----------------------------------------------------------------------------
   Entry code for a BCO
   ------------------------------------------------------------------------- */

INFO_TABLE_FUN( stg_BCO, 3, 0, BCO, "BCO", "BCO", 0, ARG_BCO )
    /* explicit stack */
{
  /* entering a BCO means "apply it", same as a function */
  Sp_adj(-2);
  // Skip the stack check; the interpreter will do one before using
  // the stack anyway.
  Sp(1) = R1;
  Sp(0) = stg_apply_interp_info;
  jump stg_yield_to_interpreter [];
}

/* ----------------------------------------------------------------------------
   Info tables for indirections.

   SPECIALISED INDIRECTIONS: we have a specialised indirection for direct returns,
   so that we can avoid entering
   the object when we know it points directly to a value.  The update
   code (Updates.cmm) updates objects with the appropriate kind of
   indirection.  We only do this for young-gen indirections.
   ------------------------------------------------------------------------- */

INFO_TABLE(stg_IND,1,0,IND,"IND","IND")
#if 0
/*
  This version in high-level cmm generates slightly less good code
  than the low-level version below it. (ToDo)
*/
    (P_ node)
{
    TICK_ENT_DYN_IND(); /* tick */
    ACQUIRE_FENCE_ON(node + OFFSET_StgHeader_info);
    node = %acquire StgInd_indirectee(node);
    node = UNTAG(node);
    TICK_ENT_VIA_NODE();
    jump %GET_ENTRY(node) (node);
}
#else
    /* explicit stack */
{
    TICK_ENT_DYN_IND(); /* tick */
    ACQUIRE_FENCE_ON(R1 + OFFSET_StgHeader_info);
    P_ p;
    p = %acquire StgInd_indirectee(R1);
    R1 = UNTAG(p);
    TICK_ENT_VIA_NODE();
    jump %GET_ENTRY(R1) [R1];
}
#endif

INFO_TABLE(stg_IND_STATIC,1,0,IND_STATIC,"IND_STATIC","IND_STATIC")
    /* explicit stack */
{
    TICK_ENT_STATIC_IND(); /* tick */
    ACQUIRE_FENCE_ON(R1 + OFFSET_StgHeader_info);
    P_ p;
    p = %acquire StgInd_indirectee(R1);
    R1 = UNTAG(p);
    TICK_ENT_VIA_NODE();
    jump %GET_ENTRY(R1) [R1];
}

/* ----------------------------------------------------------------------------
   Black holes.

   Entering a black hole normally causes a cyclic data dependency, but
   in the concurrent world, black holes are synchronization points,
   and they are turned into blocking queues when there are threads
   waiting for the evaluation of the closure to finish.
   ------------------------------------------------------------------------- */

INFO_TABLE(stg_BLACKHOLE,1,0,BLACKHOLE,"BLACKHOLE","BLACKHOLE")
    (P_ node)
{
    W_ r, info, owner, bd;
    P_ p, bq, msg;

    TICK_ENT_DYN_IND(); /* tick */

retry:
    // Synchronizes with the release-store in
    // updateWithIndirection.
    // See Note [Heap memory barriers] in SMP.h.
    ACQUIRE_FENCE_ON(node + OFFSET_StgHeader_info);
    p = %acquire StgInd_indirectee(node);
    if (GETTAG(p) != 0) {
        return (p);
    }

    // May race with OVERWRITE_INFO in wakeBlockingQueue()
    info = %relaxed GET_INFO(p);
    if (info == stg_IND_info) {
        // This could happen, if e.g. we got a BLOCKING_QUEUE that has
        // just been replaced with an IND by another thread in
        // wakeBlockingQueue().
        // See Note [BLACKHOLE pointing to IND] in sm/Evac.c
        goto retry;
    }

    if (info == stg_TSO_info ||
        info == stg_BLOCKING_QUEUE_CLEAN_info ||
        info == stg_BLOCKING_QUEUE_DIRTY_info)
    {
        ("ptr" msg) = ccall allocate(MyCapability() "ptr",
                                     BYTES_TO_WDS(SIZEOF_MessageBlackHole));

        MessageBlackHole_tso(msg) = CurrentTSO;
        MessageBlackHole_bh(msg) = node;
        // Ensure that the link field is a valid closure,
        // since we might turn this into an indirection in wakeBlockingQueue()
        MessageBlackHole_link(msg) = stg_END_TSO_QUEUE_closure;
        SET_HDR(msg, stg_MSG_BLACKHOLE_info, CCS_SYSTEM);
        // messageBlackHole has appropriate memory barriers when this object is exposed.
        // See Note [Heap memory barriers].

        (r) = ccall messageBlackHole(MyCapability() "ptr", msg "ptr");

        if (r == 0) {
            goto retry;
        } else {
            StgTSO_block_info(CurrentTSO) = msg;
            %release StgTSO_why_blocked(CurrentTSO) = BlockedOnBlackHole::I16;
            jump stg_block_blackhole(node);
        }
    }
    else
    {
        ENTER(p);
    }
}

// CAF_BLACKHOLE is allocated when entering a CAF.  The reason it is
// distinct from BLACKHOLE is so that we can tell the difference
// between an update frame on the stack that points to a CAF under
// evaluation, and one that points to a closure that is under
// evaluation by another thread (a BLACKHOLE).  see Note [suspend
// duplicate work] in ThreadPaused.c
//
INFO_TABLE(stg_CAF_BLACKHOLE,1,0,BLACKHOLE,"BLACKHOLE","BLACKHOLE")
    (P_ node)
{
    jump ENTRY_LBL(stg_BLACKHOLE) (node);
}

// EAGER_BLACKHOLE exists for the same reason as CAF_BLACKHOLE (see above).
INFO_TABLE(__stg_EAGER_BLACKHOLE,1,0,BLACKHOLE,"BLACKHOLE","BLACKHOLE")
    (P_ node)
{
    jump ENTRY_LBL(stg_BLACKHOLE) (node);
}

INFO_TABLE(stg_BLOCKING_QUEUE_CLEAN,4,0,BLOCKING_QUEUE,"BLOCKING_QUEUE","BLOCKING_QUEUE")
{ foreign "C" barf("BLOCKING_QUEUE_CLEAN object (%p) entered!", R1) never returns; }


INFO_TABLE(stg_BLOCKING_QUEUE_DIRTY,4,0,BLOCKING_QUEUE,"BLOCKING_QUEUE","BLOCKING_QUEUE")
{ foreign "C" barf("BLOCKING_QUEUE_DIRTY object (%p) entered!", R1) never returns; }


/* ----------------------------------------------------------------------------
   Whiteholes are used for the "locked" state of a closure (see lockClosure())
   ------------------------------------------------------------------------- */

INFO_TABLE(stg_WHITEHOLE, 0,0, WHITEHOLE, "WHITEHOLE", "WHITEHOLE")
    (P_ node)
{
#if defined(THREADED_RTS)
    W_ info, i;

    i = 0;
loop:
    // spin until the WHITEHOLE is updated
    info = %relaxed StgHeader_info(node);
    if (info == stg_WHITEHOLE_info) {
#if defined(PROF_SPIN)
        W_[whitehole_lockClosure_spin] =
            W_[whitehole_lockClosure_spin] + 1;
#endif
        i = i + 1;
        if (i == SPIN_COUNT) {
            i = 0;
#if defined(PROF_SPIN)
            W_[whitehole_lockClosure_yield] =
                W_[whitehole_lockClosure_yield] + 1;
#endif
            ccall yieldThread();
        }
        // TODO: We should busy_wait_nop() here, but that's not currently
        // defined in CMM.
        goto loop;
    }
    ACQUIRE_FENCE_ON(node + OFFSET_StgHeader_info);
    jump %ENTRY_CODE(info) (node);
#else
    ccall barf("WHITEHOLE object (%p) entered!", R1) never returns;
#endif
}

/* ----------------------------------------------------------------------------
   Some static info tables for things that don't get entered, and
   therefore don't need entry code (i.e. boxed but unpointed objects)
   NON_ENTERABLE_ENTRY_CODE now defined at the beginning of the file
   ------------------------------------------------------------------------- */

INFO_TABLE(stg_TSO, 0,0,TSO, "TSO", "TSO")
{ foreign "C" barf("TSO object (%p) entered!", R1) never returns; }

INFO_TABLE(stg_STACK, 0,0, STACK, "STACK", "STACK")
{ foreign "C" barf("STACK object (%p) entered!", R1) never returns; }

/* ----------------------------------------------------------------------------
   Weak pointers

   Live weak pointers have a special closure type.  Dead ones are just
   nullary constructors (although they live on the heap - we overwrite
   live weak pointers with dead ones).
   ------------------------------------------------------------------------- */

INFO_TABLE(stg_WEAK,1,4,WEAK,"WEAK","WEAK")
{ foreign "C" barf("WEAK object (%p) entered!", R1) never returns; }

/*
 * It's important when turning an existing WEAK into a DEAD_WEAK
 * (which is what finalizeWeak# does) that we don't lose the link
 * field and break the linked list of weak pointers.  Hence, we give
 * DEAD_WEAK 5 non-pointer fields.
 */
INFO_TABLE_CONSTR(stg_DEAD_WEAK,0,5,0,CONSTR,"DEAD_WEAK","DEAD_WEAK")
{ foreign "C" barf("DEAD_WEAK object (%p) entered!", R1) never returns; }

/* ----------------------------------------------------------------------------
   C finalizer lists

   Singly linked lists that chain multiple C finalizers on a weak pointer.
   ------------------------------------------------------------------------- */

INFO_TABLE_CONSTR(stg_C_FINALIZER_LIST,1,4,0,CONSTR,"C_FINALIZER_LIST","C_FINALIZER_LIST")
{ foreign "C" barf("C_FINALIZER_LIST object (%p) entered!", R1) never returns; }

/* ----------------------------------------------------------------------------
   NO_FINALIZER

   This is a static nullary constructor (like []) that we use to mark an empty
   finalizer in a weak pointer object.
   ------------------------------------------------------------------------- */

INFO_TABLE_CONSTR(stg_NO_FINALIZER,0,0,0,CONSTR_NOCAF,"NO_FINALIZER","NO_FINALIZER")
{ foreign "C" barf("NO_FINALIZER object (%p) entered!", R1) never returns; }

CLOSURE(stg_NO_FINALIZER_closure,stg_NO_FINALIZER);

/* ----------------------------------------------------------------------------
   Stable Names are unlifted too.
   ------------------------------------------------------------------------- */

INFO_TABLE(stg_STABLE_NAME,0,1,PRIM,"STABLE_NAME","STABLE_NAME")
{ foreign "C" barf("STABLE_NAME object (%p) entered!", R1) never returns; }

/* ----------------------------------------------------------------------------
   MVars

   There are two kinds of these: full and empty.  We need an info table
   and entry code for each type.
   ------------------------------------------------------------------------- */

INFO_TABLE(stg_MVAR_CLEAN,3,0,MVAR_CLEAN,"MVAR","MVAR")
{ foreign "C" barf("MVAR object (%p) entered!", R1) never returns; }

INFO_TABLE(stg_MVAR_DIRTY,3,0,MVAR_DIRTY,"MVAR","MVAR")
{ foreign "C" barf("MVAR object (%p) entered!", R1) never returns; }

/* -----------------------------------------------------------------------------
   STM
   -------------------------------------------------------------------------- */

INFO_TABLE(stg_TVAR_CLEAN, 2, 1, TVAR, "TVAR", "TVAR")
{ foreign "C" barf("TVAR_CLEAN object (%p) entered!", R1) never returns; }

INFO_TABLE(stg_TVAR_DIRTY, 2, 1, TVAR, "TVAR", "TVAR")
{ foreign "C" barf("TVAR_DIRTY object (%p) entered!", R1) never returns; }

INFO_TABLE(stg_TVAR_WATCH_QUEUE, 3, 0, MUT_PRIM, "TVAR_WATCH_QUEUE", "TVAR_WATCH_QUEUE")
{ foreign "C" barf("TVAR_WATCH_QUEUE object (%p) entered!", R1) never returns; }

INFO_TABLE(stg_TREC_CHUNK, 0, 0, TREC_CHUNK, "TREC_CHUNK", "TREC_CHUNK")
{ foreign "C" barf("TREC_CHUNK object (%p) entered!", R1) never returns; }

INFO_TABLE(stg_TREC_HEADER, 2, 1, MUT_PRIM, "TREC_HEADER", "TREC_HEADER")
{ foreign "C" barf("TREC_HEADER object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_END_STM_WATCH_QUEUE,0,0,0,CONSTR_NOCAF,"END_STM_WATCH_QUEUE","END_STM_WATCH_QUEUE")
{ foreign "C" barf("END_STM_WATCH_QUEUE object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_END_STM_CHUNK_LIST,0,0,0,CONSTR_NOCAF,"END_STM_CHUNK_LIST","END_STM_CHUNK_LIST")
{ foreign "C" barf("END_STM_CHUNK_LIST object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_NO_TREC,0,0,0,CONSTR_NOCAF,"NO_TREC","NO_TREC")
{ foreign "C" barf("NO_TREC object (%p) entered!", R1) never returns; }

CLOSURE(stg_END_STM_WATCH_QUEUE_closure,stg_END_STM_WATCH_QUEUE);

CLOSURE(stg_END_STM_CHUNK_LIST_closure,stg_END_STM_CHUNK_LIST);

CLOSURE(stg_NO_TREC_closure,stg_NO_TREC);

/* ----------------------------------------------------------------------------
   SRTs

   See Note [SRTs] in compiler/GHC/Cmm/Info/Build.hs
   ------------------------------------------------------------------------- */

INFO_TABLE_CONSTR(stg_SRT_1, 1, 0, 0, CONSTR_1_0, "SRT_1", "SRT_1")
{ foreign "C" barf("SRT_1 object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_SRT_2, 2, 0, 0, CONSTR_2_0, "SRT_2", "SRT_2")
{ foreign "C" barf("SRT_2 object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_SRT_3, 3, 0, 0, CONSTR, "SRT_3", "SRT_3")
{ foreign "C" barf("SRT_3 object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_SRT_4, 4, 0, 0, CONSTR, "SRT_4", "SRT_4")
{ foreign "C" barf("SRT_4 object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_SRT_5, 5, 0, 0, CONSTR, "SRT_5", "SRT_5")
{ foreign "C" barf("SRT_5 object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_SRT_6, 6, 0, 0, CONSTR, "SRT_6", "SRT_6")
{ foreign "C" barf("SRT_6 object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_SRT_7, 7, 0, 0, CONSTR, "SRT_7", "SRT_7")
{ foreign "C" barf("SRT_7 object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_SRT_8, 8, 0, 0, CONSTR, "SRT_8", "SRT_8")
{ foreign "C" barf("SRT_8 object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_SRT_9, 9, 0, 0, CONSTR, "SRT_9", "SRT_9")
{ foreign "C" barf("SRT_9 object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_SRT_10, 10, 0, 0, CONSTR, "SRT_10", "SRT_10")
{ foreign "C" barf("SRT_10 object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_SRT_11, 11, 0, 0, CONSTR, "SRT_11", "SRT_11")
{ foreign "C" barf("SRT_11 object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_SRT_12, 12, 0, 0, CONSTR, "SRT_12", "SRT_12")
{ foreign "C" barf("SRT_12 object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_SRT_13, 13, 0, 0, CONSTR, "SRT_13", "SRT_13")
{ foreign "C" barf("SRT_13 object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_SRT_14, 14, 0, 0, CONSTR, "SRT_14", "SRT_14")
{ foreign "C" barf("SRT_14 object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_SRT_15, 15, 0, 0, CONSTR, "SRT_15", "SRT_15")
{ foreign "C" barf("SRT_15 object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_SRT_16, 16, 0, 0, CONSTR, "SRT_16", "SRT_16")
{ foreign "C" barf("SRT_16 object (%p) entered!", R1) never returns; }

/* ---------------------------------------------------------------------------   Messages
   ------------------------------------------------------------------------- */

// PRIM rather than CONSTR, because PRIM objects cannot be duplicated by the GC.

INFO_TABLE_CONSTR(stg_MSG_TRY_WAKEUP,2,0,0,PRIM,"MSG_TRY_WAKEUP","MSG_TRY_WAKEUP")
{ foreign "C" barf("MSG_TRY_WAKEUP object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_MSG_THROWTO,4,0,0,PRIM,"MSG_THROWTO","MSG_THROWTO")
{ foreign "C" barf("MSG_THROWTO object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_MSG_BLACKHOLE,3,0,0,PRIM,"MSG_BLACKHOLE","MSG_BLACKHOLE")
{ foreign "C" barf("MSG_BLACKHOLE object (%p) entered!", R1) never returns; }

// used to overwrite a MSG_THROWTO when the message has been used/revoked
INFO_TABLE_CONSTR(stg_MSG_NULL,1,0,0,PRIM,"MSG_NULL","MSG_NULL")
{ foreign "C" barf("MSG_NULL object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_MSG_CLONE_STACK,3,0,0,PRIM,"MSG_CLONE_STACK","MSG_CLONE_STACK")
{ foreign "C" barf("stg_MSG_CLONE_STACK object (%p) entered!", R1) never returns; }

/* ----------------------------------------------------------------------------
   END_TSO_QUEUE

   This is a static nullary constructor (like []) that we use to mark the
   end of a linked TSO queue.
   ------------------------------------------------------------------------- */

INFO_TABLE_CONSTR(stg_END_TSO_QUEUE,0,0,0,CONSTR_NOCAF,"END_TSO_QUEUE","END_TSO_QUEUE")
{ foreign "C" barf("END_TSO_QUEUE object (%p) entered!", R1) never returns; }

CLOSURE(stg_END_TSO_QUEUE_closure,stg_END_TSO_QUEUE);

/* ----------------------------------------------------------------------------
   GCD_CAF
   ------------------------------------------------------------------------- */

INFO_TABLE_CONSTR(stg_GCD_CAF,0,0,0,CONSTR_NOCAF,"GCD_CAF","GCD_CAF")
{ foreign "C" barf("Evaluated a CAF (%p) that was GC'd!", R1) never returns; }

/* ----------------------------------------------------------------------------
   STM_AWOKEN

   This is a static nullary constructor (like []) that we use to mark a
   thread waiting on an STM wakeup
   ------------------------------------------------------------------------- */

INFO_TABLE_CONSTR(stg_STM_AWOKEN,0,0,0,CONSTR_NOCAF,"STM_AWOKEN","STM_AWOKEN")
{ foreign "C" barf("STM_AWOKEN object (%p) entered!", R1) never returns; }

CLOSURE(stg_STM_AWOKEN_closure,stg_STM_AWOKEN);

/* ----------------------------------------------------------------------------
   Arrays

   These come in two basic flavours: arrays of data (StgArrWords) and arrays of
   pointers (StgArrPtrs).  They all have a similar layout:

   ___________________________
   | Info | No. of | data....
   |  Ptr | Words  |
   ---------------------------

   These are *unpointed* objects: i.e. they cannot be entered.

   ------------------------------------------------------------------------- */

INFO_TABLE(stg_ARR_WORDS, 0, 0, ARR_WORDS, "ARR_WORDS", "ARR_WORDS")
{ foreign "C" barf("ARR_WORDS object (%p) entered!", R1) never returns; }

INFO_TABLE(stg_MUT_ARR_PTRS_CLEAN, 0, 0, MUT_ARR_PTRS_CLEAN, "MUT_ARR_PTRS_CLEAN", "MUT_ARR_PTRS_CLEAN")
{ foreign "C" barf("MUT_ARR_PTRS_CLEAN object (%p) entered!", R1) never returns; }

INFO_TABLE(stg_MUT_ARR_PTRS_DIRTY, 0, 0, MUT_ARR_PTRS_DIRTY, "MUT_ARR_PTRS_DIRTY", "MUT_ARR_PTRS_DIRTY")
{ foreign "C" barf("MUT_ARR_PTRS_DIRTY object (%p) entered!", R1) never returns; }

INFO_TABLE(stg_MUT_ARR_PTRS_FROZEN_CLEAN, 0, 0, MUT_ARR_PTRS_FROZEN_CLEAN, "MUT_ARR_PTRS_FROZEN_CLEAN", "MUT_ARR_PTRS_FROZEN_CLEAN")
{ foreign "C" barf("MUT_ARR_PTRS_FROZEN_CLEAN object (%p) entered!", R1) never returns; }

INFO_TABLE(stg_MUT_ARR_PTRS_FROZEN_DIRTY, 0, 0, MUT_ARR_PTRS_FROZEN_DIRTY, "MUT_ARR_PTRS_FROZEN_DIRTY", "MUT_ARR_PTRS_FROZEN_DIRTY")
{ foreign "C" barf("MUT_ARR_PTRS_FROZEN_DIRTY object (%p) entered!", R1) never returns; }

INFO_TABLE(stg_SMALL_MUT_ARR_PTRS_CLEAN, 0, 0, SMALL_MUT_ARR_PTRS_CLEAN, "SMALL_MUT_ARR_PTRS_CLEAN", "SMALL_MUT_ARR_PTRS_CLEAN")
{ foreign "C" barf("SMALL_MUT_ARR_PTRS_CLEAN object (%p) entered!", R1) never returns; }

INFO_TABLE(stg_SMALL_MUT_ARR_PTRS_DIRTY, 0, 0, SMALL_MUT_ARR_PTRS_DIRTY, "SMALL_MUT_ARR_PTRS_DIRTY", "SMALL_MUT_ARR_PTRS_DIRTY")
{ foreign "C" barf("SMALL_MUT_ARR_PTRS_DIRTY object (%p) entered!", R1) never returns; }

INFO_TABLE(stg_SMALL_MUT_ARR_PTRS_FROZEN_CLEAN, 0, 0, SMALL_MUT_ARR_PTRS_FROZEN_CLEAN, "SMALL_MUT_ARR_PTRS_FROZEN_CLEAN", "SMALL_MUT_ARR_PTRS_FROZEN_CLEAN")
{ foreign "C" barf("SMALL_MUT_ARR_PTRS_FROZEN_CLEAN object (%p) entered!", R1) never returns; }

INFO_TABLE(stg_SMALL_MUT_ARR_PTRS_FROZEN_DIRTY, 0, 0, SMALL_MUT_ARR_PTRS_FROZEN_DIRTY, "SMALL_MUT_ARR_PTRS_FROZEN_DIRTY", "SMALL_MUT_ARR_PTRS_FROZEN_DIRTY")
{ foreign "C" barf("SMALL_MUT_ARR_PTRS_FROZEN_DIRTY object (%p) entered!", R1) never returns; }

/* ----------------------------------------------------------------------------
   Mutable Variables
   ------------------------------------------------------------------------- */

INFO_TABLE(stg_MUT_VAR_CLEAN, 1, 0, MUT_VAR_CLEAN, "MUT_VAR_CLEAN", "MUT_VAR_CLEAN")
{ foreign "C" barf("MUT_VAR_CLEAN object (%p) entered!", R1) never returns; }
INFO_TABLE(stg_MUT_VAR_DIRTY, 1, 0, MUT_VAR_DIRTY, "MUT_VAR_DIRTY", "MUT_VAR_DIRTY")
{ foreign "C" barf("MUT_VAR_DIRTY object (%p) entered!", R1) never returns; }

/* ----------------------------------------------------------------------------
   Dummy return closure

   Entering this closure will just return to the address on the top of the
   stack.  Useful for getting a thread in a canonical form where we can
   just enter the top stack word to start the thread.  (see deleteThread)
 * ------------------------------------------------------------------------- */

INFO_TABLE( stg_dummy_ret, 0, 0, CONSTR_NOCAF, "DUMMY_RET", "DUMMY_RET")
    ()
{
    return ();
}
CLOSURE(stg_dummy_ret_closure,stg_dummy_ret);

/* ----------------------------------------------------------------------------
   MVAR_TSO_QUEUE
   ------------------------------------------------------------------------- */

INFO_TABLE_CONSTR(stg_MVAR_TSO_QUEUE,2,0,0,PRIM,"MVAR_TSO_QUEUE","MVAR_TSO_QUEUE")
{ foreign "C" barf("MVAR_TSO_QUEUE object (%p) entered!", R1) never returns; }

/* ----------------------------------------------------------------------------
   COMPACT_NFDATA (a blob of data in NF with no outgoing pointers)

   See Note [Compact Normal Forms] in sm/CNF.c

   CLEAN/DIRTY refer to the state of the "hash" field: DIRTY means that
   compaction is in progress and the hash table needs to be scanned by the GC.
   ------------------------------------------------------------------------- */

INFO_TABLE( stg_COMPACT_NFDATA_CLEAN, 0, 9, COMPACT_NFDATA, "COMPACT_NFDATA", "COMPACT_NFDATA")
    ()
{ foreign "C" barf("COMPACT_NFDATA_CLEAN object (%p) entered!", R1) never returns; }

INFO_TABLE( stg_COMPACT_NFDATA_DIRTY, 0, 9, COMPACT_NFDATA, "COMPACT_NFDATA", "COMPACT_NFDATA")
    ()
{ foreign "C" barf("COMPACT_NFDATA_DIRTY object (%p) entered!", R1) never returns; }

/* ----------------------------------------------------------------------------
   ClosureTable element null value

   The element null value is a static nullary constructor (like []) that we use
   for "empty" entries in a ClosureTable.
   ------------------------------------------------------------------------- */

INFO_TABLE_CONSTR(stg_CLOSURE_TABLE_NULL,0,0,0,CONSTR_NOCAF,"CLOSURE_TABLE_NULL","CLOSURE_TABLE_NULL")
{ foreign "C" barf("CLOSURE_TABLE_NULL object (%p) entered!", R1) never returns; }

CLOSURE(stg_CLOSURE_TABLE_NULL_closure,stg_CLOSURE_TABLE_NULL);

/* ----------------------------------------------------------------------------
   StgTimeoutQueue and StgTimeoutQueue empty value

   The empty value is a static nullary constructor (like []) that we use
   for empty leaf nodes in the tree.
   ------------------------------------------------------------------------- */

INFO_TABLE_CONSTR(stg_TIMEOUT_QUEUE,
                  stg_TIMEOUT_QUEUE_NUM_PTRS,
                  stg_TIMEOUT_QUEUE_NUM_NONPTRS,
                  0,MUT_PRIM,"TIMEOUT_QUEUE","TIMEOUT_QUEUE")
{ foreign "C" barf("TIMEOUT_QUEUE object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_TIMEOUT_QUEUE_EMPTY,0,0,0,CONSTR_NOCAF,"TIMEOUT_QUEUE_EMPTY","TIMEOUT_QUEUE_EMPTY")
{ foreign "C" barf("TIMEOUT_QUEUE_EMPTY object (%p) entered!", R1) never returns; }

CLOSURE(stg_TIMEOUT_QUEUE_EMPTY_closure,stg_TIMEOUT_QUEUE_EMPTY);

/* ----------------------------------------------------------------------------
   Async I/O operation closures: StgAsyncIOOp and two StgAsyncIOLive
   ------------------------------------------------------------------------- */

/* PRIM rather than CONSTR, because PRIM objects cannot be duplicated by the GC.
 * We need that here because while we do not mutate the pointer fields, we do
 * mutate the non-pointer fields: the operation result.
 */
INFO_TABLE_CONSTR(stg_ASYNCIOOP,
                  stg_ASYNCIOOP_NUM_PTRS,
                  stg_ASYNCIOOP_NUM_NONPTRS,
                  0,PRIM,"ASYNCIOOP","ASYNCIOOP")
{ foreign "C" barf("ASYNCIOOP object (%p) entered!", R1) never returns; }

INFO_TABLE_CONSTR(stg_ASYNCIO_LIVE0,0,0,0,CONSTR_NOCAF,"ASYNCIO_LIVE0","ASYNCIO_LIVE0")
{ foreign "C" barf("ASYNCIO_LIVE0 object (%p) entered!", R1) never returns; }

CLOSURE(stg_ASYNCIO_LIVE0_closure,stg_ASYNCIO_LIVE0);
