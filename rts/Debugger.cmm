/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2025
 *
 * Debugger support
 *
 * This file is written in a subset of C--, extended with various
 * features specific to GHC.  It is compiled by GHC directly.  For the
 * syntax of .cmm files, see the parser in ghc/compiler/GHC/Cmm/Parser.y.
 *
 * ---------------------------------------------------------------------------*/

#include "Cmm.h"

#if !defined(UnregisteredCompiler)
import CLOSURE stg_stop_after_ret_frame_info;
#endif

/* --------------------------------------------------------------------------
                         Step out / Stop after return
   -------------------------------------------------------------------------- */

/* The info table for an `stg_stop_after_ret_frame`.
 * This frame will be introduced before the parent's return frame to intercept
 * a return to the parent. Since its type is `RET_SMALL`, it will be entered
 * and the following code run. The entry code will enable single-step mode and
 * return to the parent frame, thus stopping at the immediate next breakpoint
 * following a return.
 *
 * See Note [Debugger: Step-out] for details.
 */
INFO_TABLE_RET (stg_stop_after_ret_frame, RET_SMALL, W_ info_ptr)
    /* no args => explicit stack */
{

    /* We've entered a stg_stop_after_ret_frame, thus we may want to stop at
     * the next immediate breakpoint in this thread. If TSO_STOP_AFTER_RETURN
     * is ON, toggle TSO_STOP_NEXT_BREAKPOINT for this thread exclusively. */
    W_ flags;
    flags = TO_W_(StgTSO_flags(CurrentTSO));

    if ((flags & TSO_STOP_AFTER_RETURN) > 0) {
        StgTSO_flags(CurrentTSO) =
           %lobits32( flags | TSO_STOP_NEXT_BREAKPOINT );

        /* Don't stepout again */
        StgTSO_flags(CurrentTSO) =
           %lobits32( flags & ~TSO_STOP_AFTER_RETURN );
    }

    /* After enabling the single step mode, execution is resumed by returning
     * to the frame this one intercepted.
     *
     * Note: Arguments passed to the frame we intercepted must be propagated,
     * and the floating point registers untouched! See Note [Frames intercepting frames].
     */
    Sp = Sp + SIZEOF_StgStopAfterRetFrame;
    jump %ENTRY_CODE(Sp(0)) GP_ARG_REGS; // NB. all GP arg regs live!
}
