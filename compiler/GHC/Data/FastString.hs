{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE MagicHash #-}
{-# LANGUAGE UnboxedTuples #-}
{-# LANGUAGE UnliftedFFITypes #-}
{-# LANGUAGE CPP #-}

{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}
#if MIN_VERSION_GLASGOW_HASKELL(9,8,0,0)
{-# OPTIONS_GHC -fno-unoptimized-core-for-interpreter #-}
#endif
-- We always optimise this, otherwise performance of a non-optimised
-- compiler is severely affected
--
-- Also important, if you load this module into GHCi then the data representation of
-- FastString has to match that of the host compiler due to the shared FastString
-- table. Otherwise you will get segfaults when the table is consulted and the fields
-- from the FastString are in an incorrect order.

-- |
-- There are two principal string types used internally by GHC:
--
-- ['FastString']
--
--   * A compact, hash-consed, representation of character strings.
--   * Generated by 'fsLit'.
--   * You can get a 'GHC.Types.Unique.Unique' from them.
--   * Equality test is O(1) (it uses the Unique).
--   * Comparison is O(1) or O(n):
--       * O(n) but deterministic with lexical comparison (`lexicalCompareFS`)
--       * O(1) but non-deterministic with Unique comparison (`uniqCompareFS`)
--   * Turn into 'GHC.Utils.Outputable.SDoc' with 'GHC.Utils.Outputable.ftext'.
--
-- ['PtrString']
--
--   * Pointer and size of a Latin-1 encoded string.
--   * Practically no operations.
--   * Outputting them is fast.
--   * Generated by 'mkPtrString#'.
--   * Length of string literals (mkPtrString# "abc"#) is computed statically
--   * Turn into 'GHC.Utils.Outputable.SDoc' with 'GHC.Utils.Outputable.ptext'
--   * Requires manual memory management.
--     Improper use may lead to memory leaks or dangling pointers.
--   * It assumes Latin-1 as the encoding, therefore it cannot represent
--     arbitrary Unicode strings.
--
-- Use 'PtrString' unless you want the facilities of 'FastString'.
module GHC.Data.FastString
       (
        -- * ByteString
        bytesFS,
        fastStringToByteString,
        mkFastStringByteString,
        fastZStringToByteString,
        unsafeMkByteString,

        -- * ShortByteString
        fastStringToShortByteString,
        mkFastStringShortByteString,

        -- * ShortText
        fastStringToShortText,

        -- * FastZString
        FastZString,
        hPutFZS,
        zString,
        zStringTakeN,
        lengthFZS,

        -- * FastStrings
        FastString(..),     -- not abstract, for now.
        NonDetFastString (..),
        LexicalFastString (..),

        -- ** Construction
        fsLit,
        mkFastString,
        mkFastStringBytes,
        mkFastStringByteList,
        mkFastString#,

        -- ** Deconstruction
        unpackFS,           -- :: FastString -> String
        unconsFS,           -- :: FastString -> Maybe (Char, FastString)

        -- ** Encoding
        zEncodeFS,

        -- ** Operations
        uniqueOfFS,
        lengthFS,
        nullFS,
        appendFS,
        concatFS,
        consFS,
        nilFS,
        lexicalCompareFS,
        uniqCompareFS,

        -- ** Outputting
        hPutFS,

        -- ** Internal
        getFastStringTable,
        getFastZStringTable,
        getFastStringZEncCounter,
        lookupPayloadByIndex,
        FastStringPayload(..),

        -- * PtrStrings
        PtrString (..),

        -- ** Construction
        mkPtrString#,

        -- ** Deconstruction
        unpackPtrString,
        unpackPtrStringTakeN,

        -- ** Operations
        lengthPS
       ) where

import GHC.Prelude.Basic as Prelude

import GHC.Utils.Encoding
import GHC.Utils.IO.Unsafe
import GHC.Utils.Panic.Plain
import GHC.Utils.Misc
import GHC.Data.FastMutInt

import Control.Concurrent.MVar
import Control.DeepSeq
import Control.Monad
import Data.Bits
import Data.ByteString (ByteString)
import Data.ByteString.Short (ShortByteString)
import Data.Word
import qualified Data.ByteString          as BS
import qualified Data.ByteString.Char8    as BSC
import qualified Data.ByteString.Unsafe   as BS
import qualified Data.ByteString.Short    as SBS
import GHC.Data.ShortText (ShortText(..))
import Foreign.C
import System.IO
import Data.Data
import Data.IORef
import Data.Semigroup as Semi

import Foreign

import GHC.Conc.Sync    (sharedCAF)

import GHC.Exts
import GHC.IO

-- | Gives the Modified UTF-8 encoded bytes corresponding to a 'FastString'
bytesFS, fastStringToByteString :: FastString -> ByteString
{-# INLINE[1] bytesFS #-}
bytesFS f = SBS.fromShort $ fs_sbs f

{-# DEPRECATED fastStringToByteString "Use `bytesFS` instead" #-}
fastStringToByteString = bytesFS

fastStringToShortByteString :: FastString -> ShortByteString
fastStringToShortByteString = fs_sbs

fastStringToShortText :: FastString -> ShortText
fastStringToShortText = ShortText . fs_sbs

fastZStringToByteString :: FastZString -> ByteString
fastZStringToByteString (FastZString bs) = bs

-- This will drop information if any character > '\xFF'
unsafeMkByteString :: String -> ByteString
unsafeMkByteString = BSC.pack

-- -----------------------------------------------------------------------------

newtype FastZString = FastZString ByteString
  deriving NFData

hPutFZS :: Handle -> FastZString -> IO ()
hPutFZS handle (FastZString bs) = BS.hPut handle bs

zString :: FastZString -> String
zString (FastZString bs) =
    inlinePerformIO $ BS.unsafeUseAsCStringLen bs peekCAStringLen

-- | @zStringTakeN n = 'take' n . 'zString'@
-- but is performed in \(O(\min(n,l))\) rather than \(O(l)\),
-- where \(l\) is the length of the 'FastZString'.
zStringTakeN :: Int -> FastZString -> String
zStringTakeN n (FastZString bs) =
    inlinePerformIO $ BS.unsafeUseAsCStringLen bs $ \(cp, len) ->
        peekCAStringLen (cp, min n len)

lengthFZS :: FastZString -> Int
lengthFZS (FastZString bs) = BS.length bs

mkFastZStringString :: String -> FastZString
mkFastZStringString str = FastZString (BSC.pack str)

-- -----------------------------------------------------------------------------

{-| A 'FastString' is a Modified UTF-8 encoded string together with a unique ID.
All 'FastString's are stored in a global hashtable to support fast O(1)
comparison.

-}
-- | Payload for table-referenced FastStrings
data FastStringPayload = FastString {
      payload_sbs :: {-# UNPACK #-} !ShortByteString
  }

{- Note [FastString Encoding]
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A FastString is uniformly represented as a single Word64 which serves as both
   the unique identifier and the string representation (for short strings).

   Inline strings (strings â‰¤ 7 bytes):
   - Top 5 bits are always 11111 (0x1F at bit position 59-63)
   - Next 3 bits encode the byte length (0-7)
   - Remaining 56 bits contain the actual string bytes
   - Top byte ranges: 0xF8-0xFF (248-255)
   - "a" (0x61): 0xF900000000000061

   Table-referenced strings (strings > 7 bytes):
   - Top 16 bits encode the UTF-8 character count (2-63487, 0x0002-0xF7FF)
   - Lower 48 bits encode an index into the FastStringPayload table
   - Top byte ranges: 0x00-0xF7 (0-247)
   - Top byte < 0xF8 to prevent ambiguity with inline encoding
   - Maximum character count: 63487 (0xF7FF)
   - Example: 10-char string at index 42: 0x000A00000000002A

   Top byte value determines encoding type:
   - 0xF8-0xFF: Inline string
   - 0x00-0xF7: Table reference
-}
data FastString = FastStringId {-# UNPACK #-} !Word64

encodeInline :: ShortByteString -> Word64
encodeInline sbs =
  let !len = SBS.length sbs
      !lenBits = (0xf8 .|. fromIntegral len) `unsafeShiftL` 56
      w8 :: Int -> Word64
      w8 shift = fromIntegral (SBS.index sbs (shift `unsafeShiftR` 3)) `unsafeShiftL` shift
  in case len of
       0 -> lenBits
       1 -> lenBits .|. w8 0
       2 -> lenBits .|. w8 8 .|. w8 0
       3 -> lenBits .|. w8 16 .|. w8 8 .|. w8 0
       4 -> lenBits .|. w8 24 .|. w8 16 .|. w8 8 .|. w8 0
       5 -> lenBits .|. w8 32 .|. w8 24 .|. w8 16 .|. w8 8 .|. w8 0
       6 -> lenBits .|. w8 40 .|. w8 32 .|. w8 24 .|. w8 16 .|. w8 8 .|. w8 0
       7 -> lenBits .|. w8 48 .|. w8 40 .|. w8 32 .|. w8 24 .|. w8 16 .|. w8 8 .|. w8 0
       _ -> panic "encodeInline: string too long"

encodeTableRef :: Int -> Int -> Word64
encodeTableRef n_chars idx
  | n_chars < 2 = panic "encodeTableRef: character count too small (< 2)"
  | n_chars > 0xf7ff = panic "encodeTableRef: character count too large (> 63487)"
  | otherwise =
      let charBits = fromIntegral n_chars `Data.Bits.shiftL` 48
          idxBits = fromIntegral idx .&. 0x0000ffffffffffff -- mask to 48 bits
      in charBits .|. idxBits


fs_sbs :: FastString -> ShortByteString
fs_sbs (FastStringId w)
  | w .&. 0xf8000000_00000000 == 0xf8000000_00000000
  = let bs_len = (w .&. 0x07000000_00000000) `unsafeShiftR` 56
        w8 :: Int -> Word8
        w8 shift = fromIntegral ((w `unsafeShiftR` shift) .&. 0xFF)
    in case bs_len of
         0 -> SBS.empty
         1 -> SBS.singleton $ w8 0
         2 -> SBS.pack [ w8 0, w8 8 ]
         3 -> SBS.pack [ w8 0, w8 8, w8 16 ]
         4 -> SBS.pack [ w8 0, w8 8, w8 16, w8 24 ]
         5 -> SBS.pack [ w8 0, w8 8, w8 16, w8 24, w8 32 ]
         6 -> SBS.pack [ w8 0, w8 8, w8 16, w8 24, w8 32, w8 40 ]
         7 -> SBS.pack [ w8 0, w8 8, w8 16, w8 24, w8 32, w8 40, w8 48 ]
         _ -> panic "fs_sbs: invalid inline string length"
  | otherwise =
    let idx = fromIntegral (w .&. 0x0000FFFFFFFFFFFF) :: Int
        payload = lookupPayloadByIndex idx
    in payload_sbs payload

n_chars :: FastString -> Int
n_chars (FastStringId w)
  | w .&. 0xf8000000_00000000 == 0xf8000000_00000000 =
    -- Inline string: count UTF-8 characters
    utf8CountCharsShortByteString (fs_sbs (FastStringId w))
  | otherwise =
    -- Table reference: extract character count from top 16 bits
    fromIntegral (w `unsafeShiftR` 48)

uniq :: FastString -> Int
uniq (FastStringId w) = fromIntegral w

instance Eq FastString where
  f1 == f2  =  uniq f1 == uniq f2

-- We don't provide any "Ord FastString" instance to force you to think about
-- which ordering you want:
--    * lexical:   deterministic,     O(n). Cf lexicalCompareFS and LexicalFastString.
--    * by unique: non-deterministic, O(1). Cf uniqCompareFS    and NonDetFastString.

instance IsString FastString where
    fromString = fsLit

instance Semi.Semigroup FastString where
    (<>) = appendFS

instance Monoid FastString where
    mempty = nilFS
    mappend = (Semi.<>)
    mconcat = concatFS

instance Show FastString where
   show fs = show (unpackFS fs)

instance Data FastString where
  -- don't traverse?
  toConstr _   = abstractConstr "FastString"
  gunfold _ _  = error "gunfold"
  dataTypeOf _ = mkNoRepType "FastString"

instance NFData FastString where
  rnf fs = seq fs ()

-- | Compare FastString lexically
--
-- If you don't care about the lexical ordering, use `uniqCompareFS` instead.
lexicalCompareFS :: FastString -> FastString -> Ordering
lexicalCompareFS fs1 fs2 =
  if uniq fs1 == uniq fs2 then EQ else
  utf8CompareShortByteString (fs_sbs fs1) (fs_sbs fs2)
  -- perform a lexical comparison taking into account the Modified UTF-8
  -- encoding we use (cf #18562)

-- | Compare FastString by their Unique (not lexically).
--
-- Much cheaper than `lexicalCompareFS` but non-deterministic!
uniqCompareFS :: FastString -> FastString -> Ordering
uniqCompareFS fs1 fs2 = compare (uniq fs1) (uniq fs2)

-- | Non-deterministic FastString
--
-- This is a simple FastString wrapper with an Ord instance using
-- `uniqCompareFS` (i.e. which compares FastStrings on their Uniques). Hence it
-- is not deterministic from one run to the other.
newtype NonDetFastString
   = NonDetFastString FastString
   deriving newtype (Eq, Show)
   deriving stock Data

instance Ord NonDetFastString where
   compare (NonDetFastString fs1) (NonDetFastString fs2) = uniqCompareFS fs1 fs2

-- | Lexical FastString
--
-- This is a simple FastString wrapper with an Ord instance using
-- `lexicalCompareFS` (i.e. which compares FastStrings on their String
-- representation). Hence it is deterministic from one run to the other.
newtype LexicalFastString
   = LexicalFastString { getLexicalFastString :: FastString }
   deriving newtype (Eq, Show)
   deriving stock Data

instance Ord LexicalFastString where
   compare (LexicalFastString fs1) (LexicalFastString fs2) = lexicalCompareFS fs1 fs2

instance NFData LexicalFastString where
  rnf (LexicalFastString f) = rnf f

-- -----------------------------------------------------------------------------
-- Construction

{-
Internally, the compiler will maintain a fast string symbol table, providing
sharing and fast comparison. Creation of new @FastString@s then covertly does a
lookup, re-using the @FastString@ if there was a hit.

The design of the FastString hash table allows for lockless concurrent reads
and updates to multiple buckets with low synchronization overhead.

See Note [Updating the FastString table] on how it's updated.
-}
-- | A segment of the payload array
data PayloadSegment = PayloadSegment
  (MutableArray# RealWorld FastStringPayload)

-- | Boxed wrapper for Array# to allow storage in IORef
data SegmentArray = SegmentArray (Array# (IORef PayloadSegment))

-- | Append-only array of FastStringPayload for O(1) lookup by index
data PayloadArray = PayloadArray
  {-# UNPACK #-} !FastMutInt  -- ^ Next free index
  {-# UNPACK #-} !(IORef SegmentArray)  -- ^ Growable segmented array
  {-# UNPACK #-} !(MVar ())  -- ^ Lock for growing the array

-- Number of payloads per segment
payloadSegmentSize :: Int
payloadSegmentSize = 1024

payloadSegmentBits :: Int
payloadSegmentBits = 10  -- 2^10 = 1024

initialPayloadSegments :: Int
initialPayloadSegments = 256

-- | Ensure a payload segment exists, growing the array if necessary
-- Returns the segment IORef for the given segment index
ensurePayloadSegment :: Int -> IO (IORef PayloadSegment)
ensurePayloadSegment segmentIdx = do
  let !(FastStringTable _ (PayloadArray _ segmentsRef growLock)) = stringTable
      !(I# segmentIdx#) = segmentIdx
  SegmentArray segments# <- readIORef segmentsRef
  let currentSize# = sizeofArray# segments#

  if isTrue# (segmentIdx# <# currentSize#)
    then do
      -- Segment exists, return it
      let (# segmentRef #) = indexArray# segments# segmentIdx#
      return segmentRef
    else do
      -- Need to grow the array
      withMVar growLock $ \_ -> do
        -- recheck after acquiring lock (another thread might have grown it)
        SegmentArray segments'# <- readIORef segmentsRef
        let currentSize'# = sizeofArray# segments'#
        if isTrue# (segmentIdx# <# currentSize'#)
          then do
            let (# segmentRef #) = indexArray# segments'# segmentIdx#
            return segmentRef
          else do
            -- grow: double the size
            let newSize# = currentSize'# *# 2#
                !(I# payloadSegmentSize#) = payloadSegmentSize
            SegmentArray newSegments# <- IO $ \s1# ->
              case newArray# newSize# (panic "unallocated_segment") s1# of
                (# s2#, arr# #) ->
                  case copyArray# segments'# 0# arr# 0# currentSize'# s2# of
                    s3# ->
                      -- Allocate new segments
                      let allocLoop i# s#
                            | isTrue# (i# ==# newSize#) = s#
                            | otherwise =
                                case newArray# payloadSegmentSize# (panic "uninitialized payload") s# of
                                  (# s'#, seg# #) -> case newIORef (PayloadSegment seg#) `unIO` s'# of
                                    (# s''#, segRef #) -> case writeArray# arr# i# segRef s''# of
                                      s'''# -> allocLoop (i# +# 1#) s'''#
                      in case allocLoop currentSize'# s3# of
                           s4# -> case unsafeFreezeArray# arr# s4# of
                             (# s5#, frozen# #) -> (# s5#, SegmentArray frozen# #)
            writeIORef segmentsRef (SegmentArray newSegments#)
            let (# segmentRef #) = indexArray# newSegments# segmentIdx#
            return segmentRef

-- | Allocate a payload in the global payload array and return its index
allocatePayload :: FastStringPayload -> IO Int
allocatePayload payload = do
  let !(FastStringTable _ (PayloadArray nextIdx _ _)) = stringTable
  idx <- atomicFetchAddFastMut nextIdx 1
  let !(I# idx#) = idx
      !(I# payloadSegmentBits#) = payloadSegmentBits
      !(I# payloadSegmentSize#) = payloadSegmentSize
      segmentIdx = I# (idx# `uncheckedIShiftRL#` payloadSegmentBits#)
      offsetInSegment# = idx# `andI#` (payloadSegmentSize# -# 1#)
  segmentRef <- ensurePayloadSegment segmentIdx
  PayloadSegment segment# <- readIORef segmentRef
  IO $ \s# ->
    case writeArray# segment# offsetInSegment# payload s# of
      s'# -> (# s'#, () #)
  return idx

-- | Look up a FastStringPayload by its index
-- The segment is guaranteed to exist because indices only come from allocatePayload
lookupPayloadByIndex :: Int -> FastStringPayload
lookupPayloadByIndex idx = inlinePerformIO $ do
  let !(FastStringTable _ (PayloadArray _ segmentsRef _)) = stringTable
      !(I# idx#) = idx
      !(I# payloadSegmentBits#) = payloadSegmentBits
      !(I# payloadSegmentSize#) = payloadSegmentSize
      segmentIdx# = idx# `uncheckedIShiftRL#` payloadSegmentBits#
      offsetInSegment# = idx# `andI#` (payloadSegmentSize# -# 1#)
  SegmentArray segments# <- readIORef segmentsRef
  let (# segmentRef #) = indexArray# segments# segmentIdx#
  PayloadSegment segment# <- readIORef segmentRef
  IO $ readArray# segment# offsetInSegment#

data FastStringTable = FastStringTable
  (Array# (IORef FastStringTableSegment)) -- ^  concurrent segments
  !PayloadArray  -- ^ Global payload array

data TableSegment a = TableSegment
  {-# UNPACK #-} !(MVar ())  -- the lock for write in each segment
  {-# UNPACK #-} !FastMutInt -- the number of elements
  (MutableArray# RealWorld [a]) -- buckets in this segment

type FastStringTableSegment = TableSegment Int -- ^ index into payload array

data FastZStringTable = FastZStringTable
  {-# UNPACK #-} !FastMutInt
  -- ^ The number of encoded Z strings
  (Array# (IORef FastZStringTableSegment)) -- ^  concurrent segments

type  FastZStringTableSegment = TableSegment HashedFastZString

data HashedFastZString
  = HashedFastZString
    {-# UNPACK #-} !Int
    {-# NOUNPACK #-} !FastZString

zStringHash :: HashedFastZString -> Int
zStringHash (HashedFastZString hash _) = hash

{-
Following parameters are determined based on:

* Benchmark based on testsuite/tests/utils/should_run/T14854.hs
* Stats of @echo :browse | ghc --interactive -dfaststring-stats >/dev/null@:
  on 2018-10-24, we have 13920 entries.
-}
segmentBits, numSegments, segmentMask, initialNumBuckets :: Int
segmentBits = 8
numSegments = 256   -- bit segmentBits
segmentMask = 0xff  -- bit segmentBits - 1
initialNumBuckets = 64

hashToSegment# :: Int# -> Int#
hashToSegment# hash# = hash# `andI#` segmentMask#
  where
    !(I# segmentMask#) = segmentMask

hashToIndex# :: MutableArray# RealWorld a -> Int# -> Int#
hashToIndex# buckets# hash# =
  (hash# `uncheckedIShiftRL#` segmentBits#) `remInt#` size#
  where
    !(I# segmentBits#) = segmentBits
    size# = sizeofMutableArray# buckets#

{-# INLINE maybeResizeSegment #-}
maybeResizeSegment :: forall a. (a -> Int) -> IORef (TableSegment a) -> IO (TableSegment a)
maybeResizeSegment hashElem segmentRef = do
  segment@(TableSegment lock counter old#) <- readIORef segmentRef
  let oldSize# = sizeofMutableArray# old#
      newSize# = oldSize# *# 2#
  (I# n#) <- readFastMutInt counter
  if isTrue# (n# <# newSize#) -- maximum load of 1
  then return segment
  else do
    resizedSegment@(TableSegment _ _ new#) <- IO $ \s1# ->
      case newArray# newSize# [] s1# of
        (# s2#, arr# #) -> (# s2#, TableSegment lock counter arr# #)
    forM_ [0 .. (I# oldSize#) - 1] $ \(I# i#) -> do
      fsList <- IO $ readArray# old# i#
      forM_ fsList $ \fs -> do
        let -- Shall we store in hash value in FastString instead?
            !(I# hash#) = hashElem fs
            idx# = hashToIndex# new# hash#
        IO $ \s1# ->
          case readArray# new# idx# s1# of
            (# s2#, bucket #) -> case writeArray# new# idx# (fs : bucket) s2# of
              s3# -> (# s3#, () #)
    writeIORef segmentRef resizedSegment
    return resizedSegment

{-# NOINLINE stringTable #-}
stringTable :: FastStringTable
stringTable = unsafePerformIO $ do
  let !(I# numSegments#) = numSegments
      !(I# initialNumBuckets#) = initialNumBuckets
      !(I# payloadSegmentSize#) = payloadSegmentSize
      !(I# numPayloadSegments#) = initialPayloadSegments

      loop a# i# s1#
        | isTrue# (i# ==# numSegments#) = s1#
        | otherwise = case newMVar () `unIO` s1# of
            (# s2#, lock #) -> case newFastMutInt 0 `unIO` s2# of
              (# s3#, counter #) -> case newArray# initialNumBuckets# [] s3# of
                (# s4#, buckets# #) -> case newIORef
                    (TableSegment lock counter buckets#) `unIO` s4# of
                  (# s5#, segment #) -> case writeArray# a# i# segment s5# of
                    s6# -> loop a# (i# +# 1#) s6#

      -- Initialize payload array segments
      payloadLoop a# i# s1#
        | isTrue# (i# ==# numPayloadSegments#) = s1#
        | otherwise = case newArray# payloadSegmentSize#
                           (panic "uninitialized payload") s1# of
            (# s2#, segment# #) -> case newIORef (PayloadSegment segment#) `unIO` s2# of
              (# s3#, segmentRef #) -> case writeArray# a# i# segmentRef s3# of
                s4# -> payloadLoop a# (i# +# 1#) s4#

  nextPayloadIdx <- newFastMutInt 0
  payloadGrowLock <- newMVar ()

  payloadArray <- IO $ \s1# ->
    case newArray# numPayloadSegments# (panic "payload_array") s1# of
      (# s2#, arr# #) -> case payloadLoop arr# 0# s2# of
        s3# -> case unsafeFreezeArray# arr# s3# of
          (# s4#, segments# #) -> case newIORef (SegmentArray segments#) `unIO` s4# of
            (# s5#, segmentsRef #) ->
              (# s5#, PayloadArray nextPayloadIdx segmentsRef payloadGrowLock #)

  tab <- IO $ \s1# ->
    case newArray# numSegments# (panic "string_table") s1# of
      (# s2#, arr# #) -> case loop arr# 0# s2# of
        s3# -> case unsafeFreezeArray# arr# s3# of
          (# s4#, segments# #) ->
            (# s4#, FastStringTable segments# payloadArray #)

  -- use the support wired into the RTS to share this CAF among all images of
  -- libHSghc
  sharedCAF tab getOrSetLibHSghcFastStringTable


-- from the 9.3 RTS; the previous RTS before might not have this symbol.  The
-- right way to do this however would be to define some HAVE_FAST_STRING_TABLE
-- or similar rather than use (odd parity) development versions.
foreign import ccall unsafe "getOrSetLibHSghcFastStringTable"
  getOrSetLibHSghcFastStringTable :: Ptr a -> IO (Ptr a)

{-# NOINLINE zstringTable #-}
zstringTable :: FastZStringTable
zstringTable = unsafePerformIO $ do
  let !(I# numSegments#) = numSegments
      !(I# initialNumBuckets#) = initialNumBuckets
      loop a# i# s1#
        | isTrue# (i# ==# numSegments#) = s1#
        | otherwise = case newMVar () `unIO` s1# of
            (# s2#, lock #) -> case newFastMutInt 0 `unIO` s2# of
              (# s3#, counter #) -> case newArray# initialNumBuckets# [] s3# of
                (# s4#, buckets# #) -> case newIORef
                    (TableSegment lock counter buckets#) `unIO` s4# of
                  (# s5#, segment #) -> case writeArray# a# i# segment s5# of
                    s6# -> loop a# (i# +# 1#) s6#
  uid <- newFastMutInt 0 -- ord '$' * 0x01000000
  tab <- IO $ \s1# ->
    case newArray# numSegments# (panic "string_table") s1# of
      (# s2#, arr# #) -> case loop arr# 0# s2# of
        s3# -> case unsafeFreezeArray# arr# s3# of
          (# s4#, segments# #) ->
            (# s4#, FastZStringTable uid segments# #)

  -- use the support wired into the RTS to share this CAF among all images of
  -- libHSghc
#if !MIN_VERSION_rts(1,0,3)
  return tab
#else
  sharedCAF tab getOrSetLibHSghcFastZStringTable

-- from the 9.3 RTS; the previous RTS before might not have this symbol.  The
-- right way to do this however would be to define some HAVE_FAST_STRING_TABLE
-- or similar rather than use (odd parity) development versions.
foreign import ccall unsafe "getOrSetLibHSghcFastZStringTable"
  getOrSetLibHSghcFastZStringTable :: Ptr a -> IO (Ptr a)
#endif

{-

We include the FastString table in the `sharedCAF` mechanism because we'd like
FastStrings created by a Core plugin to have the same uniques as corresponding
strings created by the host compiler itself.  For example, this allows plugins
to lookup known names (eg `mkTcOcc "MySpecialType"`) in the GlobalRdrEnv or
even re-invoke the parser.

In particular, the following little sanity test was failing in a plugin
prototyping safe newtype-coercions: GHC.NT.Type.NT was imported, but could not
be looked up /by the plugin/.

   let rdrName = mkModuleName "GHC.NT.Type" `mkRdrQual` mkTcOcc "NT"
   putMsgS $ showSDoc dflags $ ppr $
     lookupGRE (mg_rdr_env guts) (LookupRdrName rdrName AllRelevantGREs)

`mkTcOcc` involves the lookup (or creation) of a FastString.  Since the
plugin's FastString.string_table is empty, constructing the RdrName also
allocates new uniques for the FastStrings "GHC.NT.Type" and "NT".  These
uniques are almost certainly unequal to the ones that the host compiler
originally assigned to those FastStrings.  Thus the lookup fails since the
domain of the GlobalRdrEnv is affected by the RdrName's OccName's FastString's
unique.

Maintaining synchronization of the two instances of this global is rather
difficult because of the uses of `unsafePerformIO` in this module.  Not
synchronizing them risks breaking the rather major invariant that two
FastStrings with the same unique have the same string. Thus we use the
lower-level `sharedCAF` mechanism that relies on Globals.c.

-}

mkFastString# :: Addr# -> FastString
{-# INLINE mkFastString# #-}
mkFastString# a# = mkFastStringBytes ptr (ptrStrLength ptr)
  where ptr = Ptr a#

{- Note [Updating the FastString table]
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We use a concurrent hashtable which contains multiple segments, each hash value
always maps to the same segment. Read is lock-free, write to the a segment
should acquire a lock for that segment to avoid race condition, writes to
different segments are independent.

The procedure goes like this:

1. Find out which segment to operate on based on the hash value
2. Read the relevant bucket and perform a look up of the string.
3. If it exists, return it.
4. Otherwise grab a unique ID, create a new FastString and atomically attempt
   to update the relevant segment with this FastString:

   * Resize the segment by doubling the number of buckets when the number of
     FastStrings in this segment grows beyond the threshold.
   * Double check that the string is not in the bucket. Another thread may have
     inserted it while we were creating our string.
   * Return the existing FastString if it exists. The one we preemptively
     created will get GCed.
   * Otherwise, insert and return the string we created.
-}

mkFastStringWith :: ShortByteString -> IO FastString
mkFastStringWith sbs = do
  let len = SBS.length sbs
  if len <= 7
    then do
      -- Inline strings: encode directly, no table lookup needed
      return $ FastStringId (encodeInline sbs)
    else do
      -- Table strings: check for existing index, or create new one
      let chars = utf8CountCharsShortByteString sbs
      TableSegment lock _ buckets# <- readIORef segmentRef
      let idx# = hashToIndex# buckets# hash#
      bucket <- IO $ readArray# buckets# idx#
      case bucket_match bucket sbs of
        Just payloadIdx -> do
          -- Found existing payload index, convert to FastString reference
          return $ FastStringId (encodeTableRef chars payloadIdx)
        Nothing -> do
          -- Create new payload and insert into table
          noDuplicate
          withMVar lock $ \_ -> insert
  where
    !(FastStringTable segments# _) = stringTable

    !(I# hash#) = hashStr sbs
    (# segmentRef #) = indexArray# segments# (hashToSegment# hash#)

    -- Helper to hash an index for table operations
    hashIndex :: Int -> Int
    hashIndex idx = hashStr (payload_sbs (lookupPayloadByIndex idx))

    insert :: IO FastString
    insert = do
      let chars = utf8CountCharsShortByteString sbs
          payload = FastString { payload_sbs = sbs }
      -- Allocate payload in global array and get its index
      payloadIdx <- allocatePayload payload
      TableSegment _ counter buckets# <- maybeResizeSegment hashIndex segmentRef
      let idx# = hashToIndex# buckets# hash#
      bucket <- IO $ readArray# buckets# idx#
      case bucket_match bucket sbs of
        -- The payload was added by another thread after previous read and
        -- before we acquired the write lock.
        Just existingIdx -> do
          return $ FastStringId (encodeTableRef chars existingIdx)
        Nothing -> do
          -- Insert the payload index into the hash table
          IO $ \s1# ->
            case writeArray# buckets# idx# (payloadIdx : bucket) s1# of
              s2# -> (# s2#, () #)
          _ <- atomicFetchAddFastMut counter 1
          return $ FastStringId (encodeTableRef chars payloadIdx)

-- | Match a ShortByteString against a bucket of payload indices
-- Returns the matching index if found
bucket_match :: [Int] -> ShortByteString -> Maybe Int
bucket_match indices sbs = go indices
  where go [] = Nothing
        go (idx : rest) =
          let payload = lookupPayloadByIndex idx
          in if payload_sbs payload == sbs
             then Just idx
             else go rest
-- bucket_match used to inline before changes to instance Eq ShortByteString
-- in bytestring-0.12, which made it slightly larger than inlining threshold.
-- Non-inlining causes a small, but measurable performance regression, so let's force it.
{-# INLINE bucket_match #-}


{-# INLINE mkNewFastZString #-}

mkNewFastZString :: FastString -> IO FastZString
mkNewFastZString fs = do
  let sbs = fs_sbs fs
  TableSegment lock _ buckets# <- readIORef segmentRef
  let idx# = hashToIndex# buckets# hash#
  bucket <- IO $ readArray# buckets# idx#
  case zbucket_match bucket hash# of
    Just found -> return found
    Nothing -> do
      -- The withMVar below is not dupable. It can lead to deadlock if it is
      -- only run partially and putMVar is not called after takeMVar.
      noDuplicate
      _ <- get_uid
      let !new_fs = mkZFastString sbs
      withMVar lock $ \_ -> insert (I# hash#) new_fs
  where
    !(FastZStringTable uid segments#) = zstringTable
    get_uid = atomicFetchAddFastMut uid 1

    -- FastString uniques are sequential, pass them through a linear
    -- congruential generator to randomise
    !(I# hash#) = uniq fs * 6364136223846793005 + 1
    (# segmentRef #) = indexArray# segments# (hashToSegment# hash#)
    insert n fs = do
      TableSegment _ counter buckets# <- maybeResizeSegment zStringHash segmentRef
      let idx# = hashToIndex# buckets# hash#
      bucket <- IO $ readArray# buckets# idx#
      case zbucket_match bucket hash# of
        -- The FastString was added by another thread after previous read and
        -- before we acquired the write lock.
        Just found -> return found
        Nothing -> do
          IO $ \s1# ->
            case writeArray# buckets# idx# (HashedFastZString n fs : bucket) s1# of
              s2# -> (# s2#, () #)
          _ <- atomicFetchAddFastMut counter 1
          return fs

zbucket_match :: [HashedFastZString] -> Int# -> Maybe FastZString
zbucket_match fs hash = go fs
  where go [] = Nothing
        go (HashedFastZString (I# u) x : ls)
          | isTrue# (u ==# hash) = Just x
          | otherwise     = go ls
{-# INLINE zbucket_match #-}

mkFastStringBytes :: Ptr Word8 -> Int -> FastString
mkFastStringBytes !ptr !len =
    -- NB: Might as well use unsafeDupablePerformIO, since mkFastStringWith is
    -- idempotent.
    unsafeDupablePerformIO $ do
        sbs <- newSBSFromPtr ptr len
        mkFastStringWith sbs

newSBSFromPtr :: Ptr a -> Int -> IO ShortByteString
newSBSFromPtr (Ptr src#) (I# len#) =
  IO $ \s ->
    case newByteArray# len# s of { (# s, dst# #) ->
    case copyAddrToByteArray# src# dst# 0# len# s of { s ->
    case unsafeFreezeByteArray# dst# s of { (# s, ba# #) ->
    (# s, SBS.SBS ba# #) }}}

-- | Create a 'FastString' by copying an existing 'ByteString'
mkFastStringByteString :: ByteString -> FastString
mkFastStringByteString bs =
  let sbs = SBS.toShort bs in
  inlinePerformIO $ mkFastStringWith sbs

-- | Create a 'FastString' from an existing 'ShortByteString' without
-- copying.
mkFastStringShortByteString :: ShortByteString -> FastString
mkFastStringShortByteString sbs =
  inlinePerformIO $ mkFastStringWith sbs

-- | Creates a UTF-8 encoded 'FastString' from a 'String'
mkFastString :: String -> FastString
{-# NOINLINE[1] mkFastString #-}
mkFastString str =
  inlinePerformIO $ do
    let !sbs = utf8EncodeShortByteString str
    mkFastStringWith sbs

-- The following rule is used to avoid polluting the non-reclaimable FastString
-- table with transient strings when we only want their encoding.
{-# RULES
"bytesFS/mkFastString" forall x. bytesFS (mkFastString x) = utf8EncodeByteString x #-}

-- | Creates a 'FastString' from a UTF-8 encoded @[Word8]@
mkFastStringByteList :: [Word8] -> FastString
mkFastStringByteList str = mkFastStringShortByteString (SBS.pack str)

-- | Creates a (lazy) Z-encoded 'FastString' from a 'ShortByteString' and
-- account the number of forced z-strings into the passed 'FastMutInt'.
mkZFastString :: ShortByteString -> FastZString
mkZFastString sbs = mkFastZStringString (zEncodeString (utf8DecodeShortByteString sbs))

hashStr  :: ShortByteString -> Int
 -- produce a hash value between 0 & m (inclusive)
hashStr sbs@(SBS.SBS ba#) = loop 0# 0#
   where
    !(I# len#) = SBS.length sbs
    loop h n =
      if isTrue# (n ==# len#) then
        I# h
      else
        let
          -- DO NOT move this let binding! indexCharOffAddr# reads from the
          -- pointer so we need to evaluate this based on the length check
          -- above. Not doing this right caused #17909.
          !c = int8ToInt# (indexInt8Array# ba# n)
          !h2 = (h *# 16777619#) `xorI#` c
        in
          loop h2 (n +# 1#)

-- -----------------------------------------------------------------------------
-- Operations

-- | Returns the length of the 'FastString' in characters
lengthFS :: FastString -> Int
lengthFS fs = n_chars fs

-- | Returns @True@ if the 'FastString' is empty
nullFS :: FastString -> Bool
nullFS (FastStringId w) = w == 0xF800000000000000

-- | Lazily unpacks and decodes the FastString
unpackFS :: FastString -> String
unpackFS fs = utf8DecodeShortByteString $ fs_sbs fs

-- | Returns a Z-encoded version of a 'FastString'.  This might be the
-- original, if it was already Z-encoded.  The first time this
-- function is applied to a particular 'FastString', the results are
-- memoized.
--
zEncodeFS :: FastString -> FastZString
zEncodeFS fs = inlinePerformIO $ mkNewFastZString fs

{-# INLINE zEncodeFS #-}

appendFS :: FastString -> FastString -> FastString
appendFS fs1 fs2 = mkFastStringShortByteString
                 $ (Semi.<>) (fs_sbs fs1) (fs_sbs fs2)

concatFS :: [FastString] -> FastString
concatFS = mkFastStringShortByteString . mconcat . map fs_sbs

consFS :: Char -> FastString -> FastString
consFS c fs = mkFastString (c : unpackFS fs)

unconsFS :: FastString -> Maybe (Char, FastString)
unconsFS fs =
  case unpackFS fs of
    []          -> Nothing
    (chr : str) -> Just (chr, mkFastString str)

uniqueOfFS :: FastString -> Int
uniqueOfFS fs = uniq fs

nilFS :: FastString
nilFS = FastStringId 0xF800000000000000  -- Empty inline string

-- -----------------------------------------------------------------------------
-- Stats

-- | Get all FastString payloads from the table (for debugging/stats)
-- Returns indices organized by segment and bucket
getFastStringTable :: IO [[[Int]]]
getFastStringTable =
  forM [0 .. numSegments - 1] $ \(I# i#) -> do
    let (# segmentRef #) = indexArray# segments# i#
    TableSegment _ _ buckets# <- readIORef segmentRef
    let bucketSize = I# (sizeofMutableArray# buckets#)
    forM [0 .. bucketSize - 1] $ \(I# j#) ->
      IO $ readArray# buckets# j#
  where
    !(FastStringTable segments# _) = stringTable

getFastZStringTable :: IO [[[FastZString]]]
getFastZStringTable =
  forM [0 .. numSegments - 1] $ \(I# i#) -> do
    let (# segmentRef #) = indexArray# segments# i#
    TableSegment _ _ buckets# <- readIORef segmentRef
    let bucketSize = I# (sizeofMutableArray# buckets#)
    forM [0 .. bucketSize - 1] $ \(I# j#) ->
      fmap (map (\(HashedFastZString _ s) -> s)) $ IO $ readArray# buckets# j#
  where
    !(FastZStringTable _ segments#) = zstringTable

getFastStringZEncCounter :: IO Int
getFastStringZEncCounter = readFastMutInt counter
  where (FastZStringTable counter _) = zstringTable

-- -----------------------------------------------------------------------------
-- Outputting 'FastString's

-- |Outputs a 'FastString' with /no decoding at all/, that is, you
-- get the actual bytes in the 'FastString' written to the 'Handle'.
hPutFS :: Handle -> FastString -> IO ()
hPutFS handle fs = BS.hPut handle $ bytesFS fs

-- ToDo: we'll probably want an hPutFSLocal, or something, to output
-- in the current locale's encoding (for error messages and suchlike).

-- -----------------------------------------------------------------------------
-- PtrStrings, here for convenience only.

-- | A 'PtrString' is a pointer to some array of Latin-1 encoded chars.
data PtrString = PtrString !(Ptr Word8) !Int

-- | Wrap an unboxed address into a 'PtrString'.
mkPtrString# :: Addr# -> PtrString
{-# INLINE mkPtrString# #-}
mkPtrString# a# = PtrString (Ptr a#) (ptrStrLength (Ptr a#))

-- | Decode a 'PtrString' back into a 'String' using Latin-1 encoding.
-- This does not free the memory associated with 'PtrString'.
unpackPtrString :: PtrString -> String
unpackPtrString (PtrString (Ptr p#) (I# n#)) = unpackNBytes# p# n#

-- | @unpackPtrStringTakeN n = 'take' n . 'unpackPtrString'@
-- but is performed in \(O(\min(n,l))\) rather than \(O(l)\),
-- where \(l\) is the length of the 'PtrString'.
unpackPtrStringTakeN :: Int -> PtrString -> String
unpackPtrStringTakeN n (PtrString (Ptr p#) len) =
  case min n len of
    I# n# -> unpackNBytes# p# n#

-- | Return the length of a 'PtrString'
lengthPS :: PtrString -> Int
lengthPS (PtrString _ n) = n

-- -----------------------------------------------------------------------------
-- under the carpet


ptrStrLength :: Ptr Word8 -> Int
{-# INLINE ptrStrLength #-}
ptrStrLength (Ptr a) = I# (cstringLength# a)

{-# NOINLINE fsLit #-}
fsLit :: String -> FastString
fsLit x = mkFastString x

{-# RULES "fslit"
    forall x . fsLit (unpackCString# x) = mkFastString# x #-}
