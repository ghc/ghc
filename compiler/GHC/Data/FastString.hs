{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE CPP #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE MagicHash #-}
{-# LANGUAGE UnboxedTuples #-}
{-# LANGUAGE UnliftedFFITypes #-}

{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}
-- We always optimise this, otherwise performance of a non-optimised
-- compiler is severely affected

-- |
-- There are two principal string types used internally by GHC:
--
-- ['FastString']
--
--   * A compact, hash-consed, representation of character strings.
--   * Generated by 'fsLit'.
--   * You can get a 'GHC.Types.Unique.Unique' from them.
--   * Equality test is O(1) (it uses the Unique).
--   * Comparison is O(1) or O(n):
--       * O(n) but deterministic with lexical comparison (`lexicalCompareFS`)
--       * O(1) but non-deterministic with Unique comparison (`uniqCompareFS`)
--   * Turn into 'GHC.Utils.Outputable.SDoc' with 'GHC.Utils.Outputable.ftext'.
--
-- ['PtrString']
--
--   * Pointer and size of a Latin-1 encoded string.
--   * Practically no operations.
--   * Outputting them is fast.
--   * Generated by 'mkPtrString#'.
--   * Length of string literals (mkPtrString# "abc"#) is computed statically
--   * Turn into 'GHC.Utils.Outputable.SDoc' with 'GHC.Utils.Outputable.ptext'
--   * Requires manual memory management.
--     Improper use may lead to memory leaks or dangling pointers.
--   * It assumes Latin-1 as the encoding, therefore it cannot represent
--     arbitrary Unicode strings.
--
-- Use 'PtrString' unless you want the facilities of 'FastString'.
module GHC.Data.FastString
       (
        -- * ByteString
        bytesFS,
        fastStringToByteString,
        mkFastStringByteString,
        fastZStringToByteString,
        unsafeMkByteString,

        -- * ShortByteString
        fastStringToShortByteString,
        mkFastStringShortByteString,

        -- * ShortText
        fastStringToShortText,

        -- * FastZString
        FastZString,
        hPutFZS,
        zString,
        zStringTakeN,
        lengthFZS,

        -- * FastStrings
        FastString,     -- not abstract, for now.
        NonDetFastString (..),
        LexicalFastString (..),

        -- ** Construction
        fsLit,
        mkFastString,
        mkFastStringBytes,
        mkFastStringByteList,
        mkFastString#,

        -- ** Deconstruction
        unpackFS,           -- :: FastString -> String
        unconsFS,           -- :: FastString -> Maybe (Char, FastString)

        -- ** Encoding
        zEncodeFS,

        -- ** Operations
        uniqueOfFS,
        lengthFS,
        nullFS,
        appendFS,
        concatFS,
        consFS,
        nilFS,
        lexicalCompareFS,
        uniqCompareFS,

        -- ** Outputting
        hPutFS,

        -- ** Internal
        getFastStringTable,
        getFastStringZEncCounter,

        -- * PtrStrings
        PtrString (..),

        -- ** Construction
        mkPtrString#,

        -- ** Deconstruction
        unpackPtrString,
        unpackPtrStringTakeN,

        -- ** Operations
        lengthPS
       ) where

import GHC.Prelude.Basic as Prelude

import GHC.Utils.Encoding
import GHC.Utils.IO.Unsafe
import GHC.Utils.Panic.Plain
import GHC.Data.FastMutInt

import Control.Concurrent.MVar
import Control.DeepSeq
import Control.Monad
import Data.ByteString (ByteString)
import Data.ByteString.Short (ShortByteString)
import qualified Data.ByteString          as BS
import qualified Data.ByteString.Char8    as BSC
import qualified Data.ByteString.Unsafe   as BS
import qualified Data.ByteString.Short    as SBS
#if !MIN_VERSION_bytestring(0,11,0)
import qualified Data.ByteString.Short.Internal as SBS
#endif
import GHC.Data.ShortText (ShortText(..))
import Foreign.C
import System.IO
import Data.Data
import Data.IORef
import Data.Semigroup as Semi

import Foreign

#if MIN_VERSION_GLASGOW_HASKELL(9,3,0,0)
import GHC.Conc.Sync    (sharedCAF)
#endif

import GHC.Exts
import GHC.IO

-- | Gives the Modified UTF-8 encoded bytes corresponding to a 'FastString'
bytesFS, fastStringToByteString :: FastString -> ByteString
bytesFS = SBS.fromShort

{-# DEPRECATED fastStringToByteString "Use `bytesFS` instead" #-}
fastStringToByteString = bytesFS

fastStringToShortByteString :: FastString -> ShortByteString
fastStringToShortByteString = id

fastStringToShortText :: FastString -> ShortText
fastStringToShortText = ShortText

fastZStringToByteString :: FastZString -> ByteString
fastZStringToByteString (FastZString bs) = bs

-- This will drop information if any character > '\xFF'
unsafeMkByteString :: String -> ByteString
unsafeMkByteString = BSC.pack


-- -----------------------------------------------------------------------------

newtype FastZString = FastZString ByteString
  deriving NFData

hPutFZS :: Handle -> FastZString -> IO ()
hPutFZS handle (FastZString bs) = BS.hPut handle bs

zString :: FastZString -> String
zString (FastZString bs) =
    inlinePerformIO $ BS.unsafeUseAsCStringLen bs peekCAStringLen

-- | @zStringTakeN n = 'take' n . 'zString'@
-- but is performed in \(O(\min(n,l))\) rather than \(O(l)\),
-- where \(l\) is the length of the 'FastZString'.
zStringTakeN :: Int -> FastZString -> String
zStringTakeN n (FastZString bs) =
    inlinePerformIO $ BS.unsafeUseAsCStringLen bs $ \(cp, len) ->
        peekCAStringLen (cp, min n len)

lengthFZS :: FastZString -> Int
lengthFZS (FastZString bs) = BS.length bs

mkFastZStringString :: String -> FastZString
mkFastZStringString str = FastZString (BSC.pack str)

-- -----------------------------------------------------------------------------

{-| A 'FastString' is a Modified UTF-8 encoded string together with a unique ID.
All 'FastString's are stored in a global hashtable to support fast O(1)
comparison.

It is also associated with a lazy reference to the Z-encoding
of this string which is used by the compiler internally.
-}
type FastString = ShortByteString

-- We don't provide any "Ord FastString" instance to force you to think about
-- which ordering you want:
--    * lexical:   deterministic,     O(n). Cf lexicalCompareFS and LexicalFastString.
--    * by unique: non-deterministic, O(1). Cf uniqCompareFS    and NonDetFastString.







-- | Compare FastString lexically
--
-- If you don't care about the lexical ordering, use `uniqCompareFS` instead.
lexicalCompareFS :: FastString -> FastString -> Ordering
lexicalCompareFS = compare
  -- perform a lexical comparison taking into account the Modified UTF-8
  -- encoding we use (cf #18562)

-- | Compare FastString by their Unique (not lexically).
--
-- Much cheaper than `lexicalCompareFS` but non-deterministic!
uniqCompareFS :: FastString -> FastString -> Ordering
uniqCompareFS = compare

-- | Non-deterministic FastString
--
-- This is a simple FastString wrapper with an Ord instance using
-- `uniqCompareFS` (i.e. which compares FastStrings on their Uniques). Hence it
-- is not deterministic from one run to the other.
newtype NonDetFastString
   = NonDetFastString FastString
   deriving newtype (Eq, Show)
   deriving stock Data

instance Ord NonDetFastString where
   compare (NonDetFastString fs1) (NonDetFastString fs2) = uniqCompareFS fs1 fs2

-- | Lexical FastString
--
-- This is a simple FastString wrapper with an Ord instance using
-- `lexicalCompareFS` (i.e. which compares FastStrings on their String
-- representation). Hence it is deterministic from one run to the other.
newtype LexicalFastString
   = LexicalFastString { getLexicalFastString :: FastString }
   deriving newtype (Eq, Show)
   deriving stock Data

instance Ord LexicalFastString where
   compare (LexicalFastString fs1) (LexicalFastString fs2) = lexicalCompareFS fs1 fs2

instance NFData LexicalFastString where
  rnf (LexicalFastString f) = rnf f

-- -----------------------------------------------------------------------------
-- Construction

{-
Internally, the compiler will maintain a fast string symbol table, providing
sharing and fast comparison. Creation of new @FastString@s then covertly does a
lookup, re-using the @FastString@ if there was a hit.

The design of the FastString hash table allows for lockless concurrent reads
and updates to multiple buckets with low synchronization overhead.

See Note [Updating the FastString table] on how it's updated.
-}
data FastStringTable = FastStringTable
  {-# UNPACK #-} !FastMutInt
  -- ^ The unique ID counter shared with all buckets
  --
  -- We unpack the 'FastMutInt' counter as it is always consumed strictly.
  {-# NOUNPACK #-} !FastMutInt
  -- ^ Number of computed z-encodings for all buckets.
  --
  -- We mark this as 'NOUNPACK' as this 'FastMutInt' is retained by a thunk
  -- in 'mkFastStringWith' and needs to be boxed any way.
  -- If this is unpacked, then we box this single 'FastMutInt' once for each
  -- allocated FastString.
  (Array# (IORef FastStringTableSegment)) -- ^  concurrent segments

data FastStringTableSegment = FastStringTableSegment
  {-# UNPACK #-} !(MVar ())  -- the lock for write in each segment
  {-# UNPACK #-} !FastMutInt -- the number of elements
  (MutableArray# RealWorld [FastString]) -- buckets in this segment

{-
Following parameters are determined based on:

* Benchmark based on testsuite/tests/utils/should_run/T14854.hs
* Stats of @echo :browse | ghc --interactive -dfaststring-stats >/dev/null@:
  on 2018-10-24, we have 13920 entries.
-}
numSegments, initialNumBuckets :: Int
numSegments = 256   -- bit segmentBits
initialNumBuckets = 64


{-# NOINLINE stringTable #-}
stringTable :: FastStringTable
stringTable = unsafePerformIO $ do
  let !(I# numSegments#) = numSegments
      !(I# initialNumBuckets#) = initialNumBuckets
      loop a# i# s1#
        | isTrue# (i# ==# numSegments#) = s1#
        | otherwise = case newMVar () `unIO` s1# of
            (# s2#, lock #) -> case newFastMutInt 0 `unIO` s2# of
              (# s3#, counter #) -> case newArray# initialNumBuckets# [] s3# of
                (# s4#, buckets# #) -> case newIORef
                    (FastStringTableSegment lock counter buckets#) `unIO` s4# of
                  (# s5#, segment #) -> case writeArray# a# i# segment s5# of
                    s6# -> loop a# (i# +# 1#) s6#
  uid <- newFastMutInt 603979776 -- ord '$' * 0x01000000
  n_zencs <- newFastMutInt 0
  tab <- IO $ \s1# ->
    case newArray# numSegments# (panic "string_table") s1# of
      (# s2#, arr# #) -> case loop arr# 0# s2# of
        s3# -> case unsafeFreezeArray# arr# s3# of
          (# s4#, segments# #) ->
            (# s4#, FastStringTable uid n_zencs segments# #)

  -- use the support wired into the RTS to share this CAF among all images of
  -- libHSghc
#if !MIN_VERSION_GLASGOW_HASKELL(9,3,0,0)
  return tab
#else
  sharedCAF tab getOrSetLibHSghcFastStringTable

-- from the 9.3 RTS; the previous RTS before might not have this symbol.  The
-- right way to do this however would be to define some HAVE_FAST_STRING_TABLE
-- or similar rather than use (odd parity) development versions.
foreign import ccall unsafe "getOrSetLibHSghcFastStringTable"
  getOrSetLibHSghcFastStringTable :: Ptr a -> IO (Ptr a)
#endif

{-

We include the FastString table in the `sharedCAF` mechanism because we'd like
FastStrings created by a Core plugin to have the same uniques as corresponding
strings created by the host compiler itself.  For example, this allows plugins
to lookup known names (eg `mkTcOcc "MySpecialType"`) in the GlobalRdrEnv or
even re-invoke the parser.

In particular, the following little sanity test was failing in a plugin
prototyping safe newtype-coercions: GHC.NT.Type.NT was imported, but could not
be looked up /by the plugin/.

   let rdrName = mkModuleName "GHC.NT.Type" `mkRdrQual` mkTcOcc "NT"
   putMsgS $ showSDoc dflags $ ppr $
     lookupGRE (mg_rdr_env guts) (LookupRdrName rdrName AllRelevantGREs)

`mkTcOcc` involves the lookup (or creation) of a FastString.  Since the
plugin's FastString.string_table is empty, constructing the RdrName also
allocates new uniques for the FastStrings "GHC.NT.Type" and "NT".  These
uniques are almost certainly unequal to the ones that the host compiler
originally assigned to those FastStrings.  Thus the lookup fails since the
domain of the GlobalRdrEnv is affected by the RdrName's OccName's FastString's
unique.

Maintaining synchronization of the two instances of this global is rather
difficult because of the uses of `unsafePerformIO` in this module.  Not
synchronizing them risks breaking the rather major invariant that two
FastStrings with the same unique have the same string. Thus we use the
lower-level `sharedCAF` mechanism that relies on Globals.c.

-}

mkFastString# :: Addr# -> FastString
{-# INLINE mkFastString# #-}
mkFastString# a# = mkFastStringBytes ptr (ptrStrLength ptr)
  where ptr = Ptr a#

{- Note [Updating the FastString table]
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We use a concurrent hashtable which contains multiple segments, each hash value
always maps to the same segment. Read is lock-free, write to the a segment
should acquire a lock for that segment to avoid race condition, writes to
different segments are independent.

The procedure goes like this:

1. Find out which segment to operate on based on the hash value
2. Read the relevant bucket and perform a look up of the string.
3. If it exists, return it.
4. Otherwise grab a unique ID, create a new FastString and atomically attempt
   to update the relevant segment with this FastString:

   * Resize the segment by doubling the number of buckets when the number of
     FastStrings in this segment grows beyond the threshold.
   * Double check that the string is not in the bucket. Another thread may have
     inserted it while we were creating our string.
   * Return the existing FastString if it exists. The one we preemptively
     created will get GCed.
   * Otherwise, insert and return the string we created.
-}


mkFastStringBytes :: Ptr Word8 -> Int -> FastString
mkFastStringBytes !ptr !len =
    -- NB: Might as well use unsafeDupablePerformIO, since mkFastStringWith is
    -- idempotent.
    unsafeDupablePerformIO $ newSBSFromPtr ptr len

newSBSFromPtr :: Ptr a -> Int -> IO ShortByteString
newSBSFromPtr (Ptr src#) (I# len#) =
  IO $ \s ->
    case newByteArray# len# s of { (# s, dst# #) ->
    case copyAddrToByteArray# src# dst# 0# len# s of { s ->
    case unsafeFreezeByteArray# dst# s of { (# s, ba# #) ->
    (# s, SBS.SBS ba# #) }}}

-- | Create a 'FastString' by copying an existing 'ByteString'
mkFastStringByteString :: ByteString -> FastString
mkFastStringByteString = SBS.toShort

-- | Create a 'FastString' from an existing 'ShortByteString' without
-- copying.
mkFastStringShortByteString :: ShortByteString -> FastString
mkFastStringShortByteString = id

-- | Creates a UTF-8 encoded 'FastString' from a 'String'
mkFastString :: String -> FastString
mkFastString str =
    let !sbs = utf8EncodeShortByteString str
     in sbs

-- | Creates a 'FastString' from a UTF-8 encoded @[Word8]@
mkFastStringByteList :: [Word8] -> FastString
mkFastStringByteList str = mkFastStringShortByteString (SBS.pack str)

hashStr  :: ShortByteString -> Int
 -- produce a hash value between 0 & m (inclusive)
hashStr sbs@(SBS.SBS ba#) = loop 0# 0#
   where
    !(I# len#) = SBS.length sbs
    loop h n =
      if isTrue# (n ==# len#) then
        I# h
      else
        let
          -- DO NOT move this let binding! indexCharOffAddr# reads from the
          -- pointer so we need to evaluate this based on the length check
          -- above. Not doing this right caused #17909.
          !c = int8ToInt# (indexInt8Array# ba# n)
          !h2 = (h *# 16777619#) `xorI#` c
        in
          loop h2 (n +# 1#)

-- -----------------------------------------------------------------------------
-- Operations

-- | Returns the length of the 'FastString' in characters
lengthFS :: FastString -> Int
lengthFS = SBS.length -- romes: does this return utf8 length?

-- | Returns @True@ if the 'FastString' is empty
nullFS :: FastString -> Bool
nullFS = SBS.null

-- | Lazily unpacks and decodes the FastString
unpackFS :: FastString -> String
unpackFS = utf8DecodeShortByteString

-- | Returns a Z-encoded version of a 'FastString'.  This might be the
-- original, if it was already Z-encoded.  The first time this
-- function is applied to a particular 'FastString', the results are
-- memoized.
--
zEncodeFS :: FastString -> FastZString
zEncodeFS = mkFastZStringString . zEncodeString . utf8DecodeShortByteString

appendFS :: FastString -> FastString -> FastString
appendFS = (Semi.<>)

concatFS :: [FastString] -> FastString
concatFS = mconcat

consFS :: Char -> FastString -> FastString
consFS c fs = mkFastString (c : unpackFS fs)

unconsFS :: FastString -> Maybe (Char, FastString)
unconsFS fs =
  case unpackFS fs of
    []          -> Nothing
    (chr : str) -> Just (chr, mkFastString str)

uniqueOfFS :: FastString -> Int
uniqueOfFS x =
  let y = abs $ hashStr x -- that can't possibly be unique...
   in assert (0 <= y) y

nilFS :: FastString
nilFS = mkFastString ""

-- -----------------------------------------------------------------------------
-- Stats

getFastStringTable :: IO [[[FastString]]]
getFastStringTable =
  forM [0 .. numSegments - 1] $ \(I# i#) -> do
    let (# segmentRef #) = indexArray# segments# i#
    FastStringTableSegment _ _ buckets# <- readIORef segmentRef
    let bucketSize = I# (sizeofMutableArray# buckets#)
    forM [0 .. bucketSize - 1] $ \(I# j#) ->
      IO $ readArray# buckets# j#
  where
    !(FastStringTable _ _ segments#) = stringTable

getFastStringZEncCounter :: IO Int
getFastStringZEncCounter = readFastMutInt n_zencs
  where
    !(FastStringTable _ n_zencs _) = stringTable

-- -----------------------------------------------------------------------------
-- Outputting 'FastString's

-- |Outputs a 'FastString' with /no decoding at all/, that is, you
-- get the actual bytes in the 'FastString' written to the 'Handle'.
hPutFS :: Handle -> FastString -> IO ()
hPutFS handle fs = BS.hPut handle $ bytesFS fs

-- ToDo: we'll probably want an hPutFSLocal, or something, to output
-- in the current locale's encoding (for error messages and suchlike).

-- -----------------------------------------------------------------------------
-- PtrStrings, here for convenience only.

-- | A 'PtrString' is a pointer to some array of Latin-1 encoded chars.
data PtrString = PtrString !(Ptr Word8) !Int

-- | Wrap an unboxed address into a 'PtrString'.
mkPtrString# :: Addr# -> PtrString
{-# INLINE mkPtrString# #-}
mkPtrString# a# = PtrString (Ptr a#) (ptrStrLength (Ptr a#))

-- | Decode a 'PtrString' back into a 'String' using Latin-1 encoding.
-- This does not free the memory associated with 'PtrString'.
unpackPtrString :: PtrString -> String
unpackPtrString (PtrString (Ptr p#) (I# n#)) = unpackNBytes# p# n#

-- | @unpackPtrStringTakeN n = 'take' n . 'unpackPtrString'@
-- but is performed in \(O(\min(n,l))\) rather than \(O(l)\),
-- where \(l\) is the length of the 'PtrString'.
unpackPtrStringTakeN :: Int -> PtrString -> String
unpackPtrStringTakeN n (PtrString (Ptr p#) len) =
  case min n len of
    I# n# -> unpackNBytes# p# n#

-- | Return the length of a 'PtrString'
lengthPS :: PtrString -> Int
lengthPS (PtrString _ n) = n

-- -----------------------------------------------------------------------------
-- under the carpet

#if !MIN_VERSION_GLASGOW_HASKELL(9,0,0,0)
foreign import ccall unsafe "strlen"
  cstringLength# :: Addr# -> Int#
#endif

ptrStrLength :: Ptr Word8 -> Int
{-# INLINE ptrStrLength #-}
ptrStrLength (Ptr a) = I# (cstringLength# a)

{-# NOINLINE fsLit #-}
fsLit :: String -> FastString
fsLit x = mkFastString x

{-# RULES "fslit"
    forall x . fsLit (unpackCString# x) = mkFastString# x #-}
