
==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 469, types: 747, coercions: 431, joins: 1/1}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl_r1ny :: Int
[GblId, Unf=OtherCon []]
lvl_r1ny = GHC.Internal.Types.I# 6#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl1_r1nz :: GHC.Internal.Prim.Addr#
[GblId, Unf=OtherCon []]
lvl1_r1nz = "Nil"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl2_r1nA :: GHC.Internal.Prim.Addr#
[GblId, Unf=OtherCon []]
lvl2_r1nA = " ::: "#

Rec {
-- RHS size: {terms: 48, types: 39, coercions: 0, joins: 0/0}
Ifoldl.$fShowVec_$cshowsPrec [Occ=LoopBreaker]
  :: forall a (n :: Nat). Show a => Int -> Vec n a -> ShowS
[GblId,
 Arity=4,
 Str=<LP(SC(S,C(1,C(1,L))),A,A)><ML><1L><L>,
 Unf=OtherCon []]
Ifoldl.$fShowVec_$cshowsPrec
  = \ (@a_a11x)
      (@(n_a11y :: Nat))
      ($dShow_a11z :: Show a_a11x)
      (ds_d1hG :: Int)
      (ds1_d1hH :: Vec n_a11y a_a11x)
      (eta_B0 :: String) ->
      case ds1_d1hH of {
        Nil co_a11G [Dmd=B] ->
          GHC.Internal.CString.unpackAppendCString# lvl1_r1nz eta_B0;
        ::: @n1_a11K co_a11L [Dmd=B] b1_aJI b2_aJJ ->
          case ds_d1hG of { GHC.Internal.Types.I# x_a1lr ->
          case GHC.Internal.Prim.>=# x_a1lr 6# of {
            __DEFAULT ->
              showsPrec
                @a_a11x
                $dShow_a11z
                lvl_r1ny
                b1_aJI
                (GHC.Internal.CString.unpackAppendCString#
                   lvl2_r1nA
                   (Ifoldl.$fShowVec_$cshowsPrec
                      @a_a11x @n1_a11K $dShow_a11z lvl_r1ny b2_aJJ eta_B0));
            1# ->
              GHC.Internal.Types.:
                @Char
                GHC.Internal.Show.$fShowCallStack3
                (showsPrec
                   @a_a11x
                   $dShow_a11z
                   lvl_r1ny
                   b1_aJI
                   (GHC.Internal.CString.unpackAppendCString#
                      lvl2_r1nA
                      (Ifoldl.$fShowVec_$cshowsPrec
                         @a_a11x
                         @n1_a11K
                         $dShow_a11z
                         lvl_r1ny
                         b2_aJJ
                         (GHC.Internal.Types.:
                            @Char GHC.Internal.Show.$fShowCallStack2 eta_B0))))
          }
          }
      }
end Rec }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$fShowVec1 :: Int
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$fShowVec1 = GHC.Internal.Types.I# 0#

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
Ifoldl.$fShowVec_$cshowList
  :: forall a (n :: Nat). Show a => [Vec n a] -> ShowS
[GblId,
 Arity=3,
 Str=<LP(SC(S,C(1,C(1,L))),A,A)><1L><L>,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0] 70 0}]
Ifoldl.$fShowVec_$cshowList
  = \ (@a_a11x)
      (@(n_a11y :: Nat))
      ($dShow_a11z :: Show a_a11x)
      (ls_a1iA :: [Vec n_a11y a_a11x])
      (s_a1iB :: String) ->
      GHC.Internal.Show.showList__
        @(Vec n_a11y a_a11x)
        (Ifoldl.$fShowVec_$cshowsPrec
           @a_a11x @n_a11y $dShow_a11z Ifoldl.$fShowVec1)
        ls_a1iA
        s_a1iB

-- RHS size: {terms: 9, types: 10, coercions: 0, joins: 0/0}
Ifoldl.$fShowVec_$cshow
  :: forall a (n :: Nat). Show a => Vec n a -> String
[GblId,
 Arity=2,
 Str=<LP(SC(S,C(1,C(1,L))),A,A)><1L>,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 50 0}]
Ifoldl.$fShowVec_$cshow
  = \ (@a_a11x)
      (@(n_a11y :: Nat))
      ($dShow_a11z :: Show a_a11x)
      (x_a1ix :: Vec n_a11y a_a11x) ->
      Ifoldl.$fShowVec_$cshowsPrec
        @a_a11x
        @n_a11y
        $dShow_a11z
        Ifoldl.$fShowVec1
        x_a1ix
        (GHC.Internal.Types.[] @Char)

-- RHS size: {terms: 10, types: 13, coercions: 0, joins: 0/0}
Ifoldl.$fShowVec [InlPrag=CONLIKE]
  :: forall a (n :: Nat). Show a => Show (Vec n a)
[GblId[DFunId],
 Arity=1,
 Str=<LP(LC(L,C(1,C(1,L))),A,A)>,
 Unf=DFun: \ (@a_aAm) (@(n_aAn :: Nat)) (v_B1 :: Show a_aAm) ->
       GHC.Internal.Show.C:Show TYPE: Vec n_aAn a_aAm
                                Ifoldl.$fShowVec_$cshowsPrec @a_aAm @n_aAn v_B1
                                Ifoldl.$fShowVec_$cshow @a_aAm @n_aAn v_B1
                                Ifoldl.$fShowVec_$cshowList @a_aAm @n_aAn v_B1]
Ifoldl.$fShowVec
  = \ (@a_a11x) (@(n_a11y :: Nat)) ($dShow_a11z :: Show a_a11x) ->
      GHC.Internal.Show.C:Show
        @(Vec n_a11y a_a11x)
        (Ifoldl.$fShowVec_$cshowsPrec @a_a11x @n_a11y $dShow_a11z)
        (Ifoldl.$fShowVec_$cshow @a_a11x @n_a11y $dShow_a11z)
        (Ifoldl.$fShowVec_$cshowList @a_a11x @n_a11y $dShow_a11z)

-- RHS size: {terms: 7, types: 13, coercions: 0, joins: 0/0}
Ifoldl.unFlip1
  :: forall k1 k2 (f :: k1 -> k2 -> *) (y :: k2) (x :: k1).
     Flip f y x -> Flip f y x
[GblId,
 Arity=1,
 Str=<1L>,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
Ifoldl.unFlip1
  = \ (@k_aJp)
      (@k1_aJq)
      (@(f_aJr :: k_aJp -> k1_aJq -> *))
      (@(y_aJs :: k1_aJq))
      (@(x_aJt :: k_aJp))
      (ds_d1hE :: Flip f_aJr y_aJs x_aJt) ->
      ds_d1hE

-- RHS size: {terms: 1, types: 0, coercions: 26, joins: 0/0}
unFlip
  :: forall {k1} {k2} (f :: k1 -> k2 -> *) (y :: k2) (x :: k1).
     Flip f y x -> f x y
[GblId[[RecSel]],
 Arity=1,
 Str=<1L>,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
unFlip
  = Ifoldl.unFlip1
    `cast` (forall (k :: <*>_N) (k1 :: <*>_N) (f :: <k
                                                     -> k1 -> *>_N) (y :: <k1>_N) (x :: <k>_N).
            <Flip f y x>_R
            %<Many>_N ->_R Ifoldl.N:Flip <k>_N <k1>_N <f>_R <y>_N <x>_N
            :: (forall k k1 (f :: k -> k1 -> *) (y :: k1) (x :: k).
                Flip f y x -> Flip f y x)
               ~R# (forall k k1 (f :: k -> k1 -> *) (y :: k1) (x :: k).
                    Flip f y x -> f x y))

-- RHS size: {terms: 7, types: 37, coercions: 63, joins: 0/0}
upWonk :: forall (k :: Nat) (w :: Nat). Wonk k w -> Wonk (S k) w
[GblId,
 Arity=1,
 Str=<1!P(L)>,
 Cpr=1,
 Unf=Unf{Src=StableSystem, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@(k_aXZ :: Nat))
                 (@(w_aY0 :: Nat))
                 (ds_d1gk [Occ=Once1!] :: Wonk k_aXZ w_aY0) ->
                 case ds_d1gk
                      `cast` (Ifoldl.N:Wonk <k_aXZ>_N <w_aY0>_N
                              :: Wonk k_aXZ w_aY0
                                 ~R# ((S k_aXZ + S w_aY0) :~: (S (S k_aXZ) + w_aY0)))
                 of
                 { Refl co_aY4 ->
                 (GHC.Internal.Data.Type.Equality.$WRefl
                    @Nat @(S (S (S (k_aXZ + w_aY0)))))
                 `cast` (((:~:)
                            <Nat>_N
                            ((S ((S (Sym (Ifoldl.D:R:+[1] <k_aXZ>_N <w_aY0>_N)
                                     ; SelCo:Tc(0,N)
                                           (Sym (Ifoldl.D:R:+[1] <S k_aXZ>_N <w_aY0>_N)
                                            ; co_aY4
                                            ; Ifoldl.D:R:+[1] <k_aXZ>_N <S w_aY0>_N)))_N
                                 ; Sym (Ifoldl.D:R:+[1] <k_aXZ>_N <S w_aY0>_N)))_N
                             ; Sym (Ifoldl.D:R:+[1] <S k_aXZ>_N <S w_aY0>_N))
                            ((S ((S (Sym (Ifoldl.D:R:+[1] <k_aXZ>_N <w_aY0>_N)))_N
                                 ; Sym (Ifoldl.D:R:+[1] <S k_aXZ>_N <w_aY0>_N)))_N
                             ; Sym (Ifoldl.D:R:+[1] <S (S k_aXZ)>_N <w_aY0>_N)))_R
                         ; Sym (Ifoldl.N:Wonk <S k_aXZ>_N <w_aY0>_N)
                         :: (S (S (S (k_aXZ + w_aY0))) :~: S (S (S (k_aXZ + w_aY0))))
                            ~R# Wonk (S k_aXZ) w_aY0)
                 }}]
upWonk
  = \ (@(k_aXZ :: Nat))
      (@(w_aY0 :: Nat))
      (ds_d1gk :: Wonk k_aXZ w_aY0) ->
      case ds_d1gk
           `cast` (Ifoldl.N:Wonk <k_aXZ>_N <w_aY0>_N
                   :: Wonk k_aXZ w_aY0
                      ~R# ((S k_aXZ + S w_aY0) :~: (S (S k_aXZ) + w_aY0)))
      of
      { Refl co_aY4 ->
      (GHC.Internal.Data.Type.Equality.$WRefl
         @Nat @(S (S (S (k_aXZ + w_aY0)))))
      `cast` (((:~:)
                 <Nat>_N
                 ((S ((S (Sym (Ifoldl.D:R:+[1] <k_aXZ>_N <w_aY0>_N)
                          ; SelCo:Tc(0,N)
                                (Sym (Ifoldl.D:R:+[1] <S k_aXZ>_N <w_aY0>_N)
                                 ; co_aY4
                                 ; Ifoldl.D:R:+[1] <k_aXZ>_N <S w_aY0>_N)))_N
                      ; Sym (Ifoldl.D:R:+[1] <k_aXZ>_N <S w_aY0>_N)))_N
                  ; Sym (Ifoldl.D:R:+[1] <S k_aXZ>_N <S w_aY0>_N))
                 ((S ((S (Sym (Ifoldl.D:R:+[1] <k_aXZ>_N <w_aY0>_N)))_N
                      ; Sym (Ifoldl.D:R:+[1] <S k_aXZ>_N <w_aY0>_N)))_N
                  ; Sym (Ifoldl.D:R:+[1] <S (S k_aXZ)>_N <w_aY0>_N)))_R
              ; Sym (Ifoldl.N:Wonk <S k_aXZ>_N <w_aY0>_N)
              :: (S (S (S (k_aXZ + w_aY0))) :~: S (S (S (k_aXZ + w_aY0))))
                 ~R# Wonk (S k_aXZ) w_aY0)
      }

-- RHS size: {terms: 43, types: 198, coercions: 150, joins: 1/1}
ifoldlRec [InlPrag=INLINE (sat-args=1)]
  :: forall (b :: Nat -> *) (n :: Nat) a.
     (forall (m :: Nat). b m -> a -> b (S m)) -> b Z -> Vec n a -> b n
[GblId,
 Arity=3,
 Str=<LC(S,C(1,L))><L><1L>,
 Unf=Unf{Src=StableUser, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@(b_aYi :: Nat -> *))
                 (@(n_aYj :: Nat))
                 (@a_aYk)
                 (f_aA2 [Occ=OnceL1!]
                    :: forall (m :: Nat). b_aYi m -> a_aYk -> b_aYi (S m))
                 (eta_B0 [Occ=Once1] :: b_aYi Z)
                 (eta1_B1 [Occ=Once1] :: Vec n_aYj a_aYk) ->
                 joinrec {
                   go_aA3 [Occ=LoopBreakerT[7]]
                     :: forall (k :: Nat) (m :: Nat).
                        ((k + Z) :~: k)
                        -> ((k + m) :~: n_aYj)
                        -> (forall (w :: Nat). Wonk k w)
                        -> b_aYi k
                        -> Vec m a_aYk
                        -> b_aYi n_aYj
                   [LclId[JoinId(7)(Nothing)],
                    Arity=5,
                    Str=<L><L><L><L><L>,
                    Unf=OtherCon []]
                   go_aA3 (@(k_aZ3 :: Nat))
                          (@(m_aZ4 :: Nat))
                          (ds_d1gu [Occ=Once1!] :: (k_aZ3 + Z) :~: k_aZ3)
                          (ds1_d1gv [Occ=Once1!] :: (k_aZ3 + m_aZ4) :~: n_aYj)
                          (ds2_d1gw :: forall (w :: Nat). Wonk k_aZ3 w)
                          (bk_aA7 [Occ=Once2] :: b_aYi k_aZ3)
                          (ds3_d1gx [Occ=Once1!] :: Vec m_aZ4 a_aYk)
                     = case ds_d1gu of { Refl co_aZ7 ->
                       case ds1_d1gv of { Refl co1_aZ9 ->
                       case (ds2_d1gw @(GHC.Internal.Types.ZonkAny 0))
                            `cast` (Ifoldl.N:Wonk <k_aZ3>_N <GHC.Internal.Types.ZonkAny 0>_N
                                    :: Wonk k_aZ3 (GHC.Internal.Types.ZonkAny 0)
                                       ~R# ((S k_aZ3 + S (GHC.Internal.Types.ZonkAny 0))
                                            :~: (S (S k_aZ3) + GHC.Internal.Types.ZonkAny 0)))
                       of
                       { Refl _ [Occ=Dead] ->
                       case ds3_d1gx of {
                         Nil co3_aZf ->
                           bk_aA7
                           `cast` (<b_aYi>_R (co_aZ7
                                              ; (<k_aZ3>_N + Sym co3_aZf)_N
                                              ; Sym co1_aZ9)
                                   :: b_aYi k_aZ3 ~R# b_aYi n_aYj);
                         ::: @ipv_s1jT ipv1_s1jU ipv2_s1jV [Occ=Once1]
                             ipv3_s1jW [Occ=Once1] ->
                           case ds2_d1gw of ds4_X5 { __DEFAULT ->
                           jump go_aA3
                             @(S k_aZ3)
                             @ipv_s1jT
                             ((GHC.Internal.Data.Type.Equality.$WRefl @Nat @(S k_aZ3))
                              `cast` (((:~:)
                                         <Nat>_N
                                         ((S co_aZ7)_N
                                          ; Sym (Ifoldl.D:R:+[1] <k_aZ3>_N <Z>_N))
                                         <S k_aZ3>_N)_R
                                      :: (S k_aZ3 :~: S k_aZ3) ~R# ((S k_aZ3 + Z) :~: S k_aZ3)))
                             (case (ds4_X5 @ipv_s1jT)
                                   `cast` (Ifoldl.N:Wonk <k_aZ3>_N <ipv_s1jT>_N
                                           :: Wonk k_aZ3 ipv_s1jT
                                              ~R# ((S k_aZ3 + S ipv_s1jT)
                                                   :~: (S (S k_aZ3) + ipv_s1jT)))
                              of
                              { Refl co3_aZT ->
                              (GHC.Internal.Data.Type.Equality.$WRefl @Nat @n_aYj)
                              `cast` (((:~:)
                                         <Nat>_N
                                         (co1_aZ9
                                          ; (<k_aZ3>_N + ipv1_s1jU)_N
                                          ; SelCo:Tc(0,N)
                                                (Sym (Ifoldl.D:R:+[1] <k_aZ3>_N <S ipv_s1jT>_N)
                                                 ; Sym co3_aZT
                                                 ; Ifoldl.D:R:+[1] <S k_aZ3>_N <ipv_s1jT>_N))
                                         <n_aYj>_N)_R
                                      :: (n_aYj :~: n_aYj) ~R# ((S k_aZ3 + ipv_s1jT) :~: n_aYj))
                              })
                             (\ (@(w_aZZ :: Nat)) ->
                                case (ds4_X5 @w_aZZ)
                                     `cast` (Ifoldl.N:Wonk <k_aZ3>_N <w_aZZ>_N
                                             :: Wonk k_aZ3 w_aZZ
                                                ~R# ((S k_aZ3 + S w_aZZ) :~: (S (S k_aZ3) + w_aZZ)))
                                of
                                { Refl co3_aY4 ->
                                (GHC.Internal.Data.Type.Equality.$WRefl
                                   @Nat @(S (S (S (k_aZ3 + w_aZZ)))))
                                `cast` (((:~:)
                                           <Nat>_N
                                           ((S ((S (Sym (Ifoldl.D:R:+[1] <k_aZ3>_N <w_aZZ>_N)
                                                    ; SelCo:Tc(0,N)
                                                          (Sym (Ifoldl.D:R:+[1]
                                                                    <S k_aZ3>_N <w_aZZ>_N)
                                                           ; co3_aY4
                                                           ; Ifoldl.D:R:+[1]
                                                                 <k_aZ3>_N <S w_aZZ>_N)))_N
                                                ; Sym (Ifoldl.D:R:+[1] <k_aZ3>_N <S w_aZZ>_N)))_N
                                            ; Sym (Ifoldl.D:R:+[1] <S k_aZ3>_N <S w_aZZ>_N))
                                           ((S ((S (Sym (Ifoldl.D:R:+[1] <k_aZ3>_N <w_aZZ>_N)))_N
                                                ; Sym (Ifoldl.D:R:+[1] <S k_aZ3>_N <w_aZZ>_N)))_N
                                            ; Sym (Ifoldl.D:R:+[1] <S (S k_aZ3)>_N <w_aZZ>_N)))_R
                                        ; Sym (Ifoldl.N:Wonk <S k_aZ3>_N <w_aZZ>_N)
                                        :: (S (S (S (k_aZ3 + w_aZZ))) :~: S (S (S (k_aZ3 + w_aZZ))))
                                           ~R# Wonk (S k_aZ3) w_aZZ)
                                })
                             (f_aA2 @k_aZ3 bk_aA7 ipv2_s1jV)
                             ipv3_s1jW
                           }
                       }
                       }
                       }
                       }; } in
                 jump go_aA3
                   @Z
                   @n_aYj
                   ((GHC.Internal.Data.Type.Equality.$WRefl @Nat @Z)
                    `cast` (((:~:) <Nat>_N (Sym (Ifoldl.D:R:+[0] <Z>_N)) <Z>_N)_R
                            :: (Z :~: Z) ~R# ((Z + Z) :~: Z)))
                   ((GHC.Internal.Data.Type.Equality.$WRefl @Nat @n_aYj)
                    `cast` (((:~:)
                               <Nat>_N (Sym (Ifoldl.D:R:+[0] <n_aYj>_N)) <n_aYj>_N)_R
                            :: (n_aYj :~: n_aYj) ~R# ((Z + n_aYj) :~: n_aYj)))
                   ((\ (@(w_a10q :: Nat)) ->
                       GHC.Internal.Data.Type.Equality.$WRefl @Nat @(S (S w_a10q)))
                    `cast` (forall (w :: <Nat>_N).
                            ((:~:)
                               <Nat>_N
                               ((S (Sym (Ifoldl.D:R:+[0] <S w>_N)))_N
                                ; Sym (Ifoldl.D:R:+[1] <Z>_N <S w>_N))
                               ((S ((S (Sym (Ifoldl.D:R:+[0] <w>_N)))_N
                                    ; Sym (Ifoldl.D:R:+[1] <Z>_N <w>_N)))_N
                                ; Sym (Ifoldl.D:R:+[1] <S Z>_N <w>_N)))_R
                            ; Sym (Ifoldl.N:Wonk <Z>_N <w>_N)
                            :: (forall (w :: Nat). S (S w) :~: S (S w))
                               ~R# (forall (w :: Nat). Wonk Z w)))
                   eta_B0
                   eta1_B1}]
ifoldlRec
  = \ (@(b_aYi :: Nat -> *))
      (@(n_aYj :: Nat))
      (@a_aYk)
      (f_aA2 :: forall (m :: Nat). b_aYi m -> a_aYk -> b_aYi (S m))
      (eta_B0 :: b_aYi Z)
      (eta1_B1 :: Vec n_aYj a_aYk) ->
      joinrec {
        $wgo_s1mt [InlPrag=[2],
                   Occ=LoopBreaker,
                   Dmd=SC(S,C(1,C(1,C(1,C(1,L)))))]
          :: forall (k :: Nat) (m :: Nat).
             (k GHC.Internal.Prim.~# (k + Z),
              n_aYj GHC.Internal.Prim.~# (k + m)) =>
             (forall (w :: Nat). Wonk k w)
             -> b_aYi k -> Vec m a_aYk -> b_aYi n_aYj
        [LclId[JoinId(7)(Just [~, ~, !, ~, !])],
         Arity=5,
         Str=<L><L><SL><L><1L>,
         Unf=OtherCon []]
        $wgo_s1mt (@(k_s1mg :: Nat))
                  (@(m_s1mh :: Nat))
                  (ww_s1mk :: k_s1mg GHC.Internal.Prim.~# (k_s1mg + Z))
                  (ww1_s1mo :: n_aYj GHC.Internal.Prim.~# (k_s1mg + m_s1mh))
                  (ds_s1mq :: forall (w :: Nat). Wonk k_s1mg w)
                  (bk_s1mr :: b_aYi k_s1mg)
                  (ds1_s1ms :: Vec m_s1mh a_aYk)
          = case (ds_s1mq @(GHC.Internal.Types.ZonkAny 0))
                 `cast` (Ifoldl.N:Wonk <k_s1mg>_N <GHC.Internal.Types.ZonkAny 0>_N
                         :: Wonk k_s1mg (GHC.Internal.Types.ZonkAny 0)
                            ~R# ((S k_s1mg + S (GHC.Internal.Types.ZonkAny 0))
                                 :~: (S (S k_s1mg) + GHC.Internal.Types.ZonkAny 0)))
            of
            { Refl co_aZd [Dmd=A] ->
            case ds1_s1ms of {
              Nil co1_aZf [Dmd=S] ->
                bk_s1mr
                `cast` (<b_aYi>_R (ww_s1mk
                                   ; (<k_s1mg>_N + Sym co1_aZf)_N
                                   ; Sym ww1_s1mo)
                        :: b_aYi k_s1mg ~R# b_aYi n_aYj);
              ::: @ipv_s1jO ipv1_s1jP [Dmd=S] ipv2_s1jQ ipv3_s1jR ->
                case ds_s1mq of ds2_X5 { __DEFAULT ->
                case (ds2_X5 @ipv_s1jO)
                     `cast` (Ifoldl.N:Wonk <k_s1mg>_N <ipv_s1jO>_N
                             :: Wonk k_s1mg ipv_s1jO
                                ~R# ((S k_s1mg + S ipv_s1jO) :~: (S (S k_s1mg) + ipv_s1jO)))
                of
                { Refl co1_aZT ->
                jump $wgo_s1mt
                  @(S k_s1mg)
                  @ipv_s1jO
                  @~((S ww_s1mk)_N
                     ; Sym (Ifoldl.D:R:+[1] <k_s1mg>_N <Z>_N)
                     :: S k_s1mg GHC.Internal.Prim.~# (S k_s1mg + Z))
                  @~(ww1_s1mo
                     ; (<k_s1mg>_N + ipv1_s1jP)_N
                     ; SelCo:Tc(0,N)
                           (Sym (Ifoldl.D:R:+[1] <k_s1mg>_N <S ipv_s1jO>_N)
                            ; Sym co1_aZT
                            ; Ifoldl.D:R:+[1] <S k_s1mg>_N <ipv_s1jO>_N)
                     :: n_aYj GHC.Internal.Prim.~# (S k_s1mg + ipv_s1jO))
                  (\ (@(w_aZZ :: Nat)) ->
                     case (ds2_X5 @w_aZZ)
                          `cast` (Ifoldl.N:Wonk <k_s1mg>_N <w_aZZ>_N
                                  :: Wonk k_s1mg w_aZZ
                                     ~R# ((S k_s1mg + S w_aZZ) :~: (S (S k_s1mg) + w_aZZ)))
                     of
                     { Refl co2_aY4 ->
                     (GHC.Internal.Data.Type.Equality.$WRefl
                        @Nat @(S (S (S (k_s1mg + w_aZZ)))))
                     `cast` (((:~:)
                                <Nat>_N
                                ((S ((S (Sym (Ifoldl.D:R:+[1] <k_s1mg>_N <w_aZZ>_N)
                                         ; SelCo:Tc(0,N)
                                               (Sym (Ifoldl.D:R:+[1] <S k_s1mg>_N <w_aZZ>_N)
                                                ; co2_aY4
                                                ; Ifoldl.D:R:+[1] <k_s1mg>_N <S w_aZZ>_N)))_N
                                     ; Sym (Ifoldl.D:R:+[1] <k_s1mg>_N <S w_aZZ>_N)))_N
                                 ; Sym (Ifoldl.D:R:+[1] <S k_s1mg>_N <S w_aZZ>_N))
                                ((S ((S (Sym (Ifoldl.D:R:+[1] <k_s1mg>_N <w_aZZ>_N)))_N
                                     ; Sym (Ifoldl.D:R:+[1] <S k_s1mg>_N <w_aZZ>_N)))_N
                                 ; Sym (Ifoldl.D:R:+[1] <S (S k_s1mg)>_N <w_aZZ>_N)))_R
                             ; Sym (Ifoldl.N:Wonk <S k_s1mg>_N <w_aZZ>_N)
                             :: (S (S (S (k_s1mg + w_aZZ))) :~: S (S (S (k_s1mg + w_aZZ))))
                                ~R# Wonk (S k_s1mg) w_aZZ)
                     })
                  (f_aA2 @k_s1mg bk_s1mr ipv2_s1jQ)
                  ipv3_s1jR
                }
                }
            }
            }; } in
      jump $wgo_s1mt
        @Z
        @n_aYj
        @~(Sym (Ifoldl.D:R:+[0] <Z>_N) :: Z GHC.Internal.Prim.~# (Z + Z))
        @~(Sym (Ifoldl.D:R:+[0] <n_aYj>_N)
           :: n_aYj GHC.Internal.Prim.~# (Z + n_aYj))
        ((\ (@(w_a10q :: Nat)) ->
            GHC.Internal.Data.Type.Equality.$WRefl @Nat @(S (S w_a10q)))
         `cast` (forall (w :: <Nat>_N).
                 ((:~:)
                    <Nat>_N
                    ((S (Sym (Ifoldl.D:R:+[0] <S w>_N)))_N
                     ; Sym (Ifoldl.D:R:+[1] <Z>_N <S w>_N))
                    ((S ((S (Sym (Ifoldl.D:R:+[0] <w>_N)))_N
                         ; Sym (Ifoldl.D:R:+[1] <Z>_N <w>_N)))_N
                     ; Sym (Ifoldl.D:R:+[1] <S Z>_N <w>_N)))_R
                 ; Sym (Ifoldl.N:Wonk <Z>_N <w>_N)
                 :: (forall (w :: Nat). S (S w) :~: S (S w))
                    ~R# (forall (w :: Nat). Wonk Z w)))
        eta_B0
        eta1_B1

Rec {
-- RHS size: {terms: 33, types: 159, coercions: 128, joins: 0/0}
Ifoldl.$wpoly_go [InlPrag=[2], Occ=LoopBreaker]
  :: forall a (n :: Nat) (k :: Nat) (m :: Nat).
     (k GHC.Internal.Prim.~# (k + Z), n GHC.Internal.Prim.~# (k + m)) =>
     (forall (w :: Nat). Wonk k w)
     -> Flip Vec a k -> Vec m a -> Flip Vec a n
[GblId[StrictWorker([~, ~, !, ~, !])],
 Arity=5,
 Str=<L><L><SL><L><1L>,
 Unf=OtherCon []]
Ifoldl.$wpoly_go
  = \ (@a_s1mw)
      (@(n_s1mx :: Nat))
      (@(k_s1my :: Nat))
      (@(m_s1mz :: Nat))
      (ww_s1mC :: k_s1my GHC.Internal.Prim.~# (k_s1my + Z))
      (ww1_s1mG :: n_s1mx GHC.Internal.Prim.~# (k_s1my + m_s1mz))
      (ds_s1mI :: forall (w :: Nat). Wonk k_s1my w)
      (bk_s1mJ :: Flip Vec a_s1mw k_s1my)
      (ds1_s1mK :: Vec m_s1mz a_s1mw) ->
      case (ds_s1mI @(GHC.Internal.Types.ZonkAny 0))
           `cast` (Ifoldl.N:Wonk <k_s1my>_N <GHC.Internal.Types.ZonkAny 0>_N
                   :: Wonk k_s1my (GHC.Internal.Types.ZonkAny 0)
                      ~R# ((S k_s1my + S (GHC.Internal.Types.ZonkAny 0))
                           :~: (S (S k_s1my) + GHC.Internal.Types.ZonkAny 0)))
      of
      { Refl co_aZd [Dmd=A] ->
      case ds1_s1mK of {
        Nil co1_aZf [Dmd=S] ->
          bk_s1mJ
          `cast` ((Flip
                     <Nat>_N
                     <*>_N
                     <Vec>_R
                     <a_s1mw>_N
                     (ww_s1mC
                      ; (<k_s1my>_N + Sym co1_aZf)_N
                      ; Sym ww1_s1mG))_R
                  :: Flip Vec a_s1mw k_s1my ~R# Flip Vec a_s1mw n_s1mx);
        ::: @ipv_s1jT ipv1_s1jU [Dmd=S] ipv2_s1jV ipv3_s1jW ->
          case ds_s1mI of ds2_X5 { __DEFAULT ->
          case (ds2_X5 @ipv_s1jT)
               `cast` (Ifoldl.N:Wonk <k_s1my>_N <ipv_s1jT>_N
                       :: Wonk k_s1my ipv_s1jT
                          ~R# ((S k_s1my + S ipv_s1jT) :~: (S (S k_s1my) + ipv_s1jT)))
          of
          { Refl co1_aZT ->
          Ifoldl.$wpoly_go
            @a_s1mw
            @n_s1mx
            @(S k_s1my)
            @ipv_s1jT
            @~((S ww_s1mC)_N
               ; Sym (Ifoldl.D:R:+[1] <k_s1my>_N <Z>_N)
               :: S k_s1my GHC.Internal.Prim.~# (S k_s1my + Z))
            @~(ww1_s1mG
               ; (<k_s1my>_N + ipv1_s1jU)_N
               ; SelCo:Tc(0,N)
                     (Sym (Ifoldl.D:R:+[1] <k_s1my>_N <S ipv_s1jT>_N)
                      ; Sym co1_aZT
                      ; Ifoldl.D:R:+[1] <S k_s1my>_N <ipv_s1jT>_N)
               :: n_s1mx GHC.Internal.Prim.~# (S k_s1my + ipv_s1jT))
            (\ (@(w_aZZ :: Nat)) ->
               case (ds2_X5 @w_aZZ)
                    `cast` (Ifoldl.N:Wonk <k_s1my>_N <w_aZZ>_N
                            :: Wonk k_s1my w_aZZ
                               ~R# ((S k_s1my + S w_aZZ) :~: (S (S k_s1my) + w_aZZ)))
               of
               { Refl co2_aY4 ->
               (GHC.Internal.Data.Type.Equality.$WRefl
                  @Nat @(S (S (S (k_s1my + w_aZZ)))))
               `cast` (((:~:)
                          <Nat>_N
                          ((S ((S (Sym (Ifoldl.D:R:+[1] <k_s1my>_N <w_aZZ>_N)
                                   ; SelCo:Tc(0,N)
                                         (Sym (Ifoldl.D:R:+[1] <S k_s1my>_N <w_aZZ>_N)
                                          ; co2_aY4
                                          ; Ifoldl.D:R:+[1] <k_s1my>_N <S w_aZZ>_N)))_N
                               ; Sym (Ifoldl.D:R:+[1] <k_s1my>_N <S w_aZZ>_N)))_N
                           ; Sym (Ifoldl.D:R:+[1] <S k_s1my>_N <S w_aZZ>_N))
                          ((S ((S (Sym (Ifoldl.D:R:+[1] <k_s1my>_N <w_aZZ>_N)))_N
                               ; Sym (Ifoldl.D:R:+[1] <S k_s1my>_N <w_aZZ>_N)))_N
                           ; Sym (Ifoldl.D:R:+[1] <S (S k_s1my)>_N <w_aZZ>_N)))_R
                       ; Sym (Ifoldl.N:Wonk <S k_s1my>_N <w_aZZ>_N)
                       :: (S (S (S (k_s1my + w_aZZ))) :~: S (S (S (k_s1my + w_aZZ))))
                          ~R# Wonk (S k_s1my) w_aZZ)
               })
            ((Ifoldl.:::
                @(S k_s1my)
                @a_s1mw
                @k_s1my
                @~(<S k_s1my>_N :: S k_s1my GHC.Internal.Prim.~# S k_s1my)
                ipv2_s1jV
                (bk_s1mJ
                 `cast` (Ifoldl.N:Flip <Nat>_N <*>_N <Vec>_R <a_s1mw>_N <k_s1my>_N
                         :: Flip Vec a_s1mw k_s1my ~R# Vec k_s1my a_s1mw)))
             `cast` (Sym (Ifoldl.N:Flip
                              <Nat>_N <*>_N <Vec>_R <a_s1mw>_N <S k_s1my>_N)
                     :: Vec (S k_s1my) a_s1mw ~R# Flip Vec a_s1mw (S k_s1my)))
            ipv3_s1jW
          }
          }
      }
      }
end Rec }

-- RHS size: {terms: 8, types: 15, coercions: 49, joins: 0/0}
Ifoldl.reverseVec1 :: forall (n :: Nat) a. Vec n a -> Flip Vec a n
[GblId,
 Arity=1,
 Str=<1L>,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 60}]
Ifoldl.reverseVec1
  = \ (@(n_a10F :: Nat)) (@a_a10G) (x_a1k3 :: Vec n_a10F a_a10G) ->
      Ifoldl.$wpoly_go
        @a_a10G
        @n_a10F
        @Z
        @n_a10F
        @~(Sym (Ifoldl.D:R:+[0] <Z>_N) :: Z GHC.Internal.Prim.~# (Z + Z))
        @~(Sym (Ifoldl.D:R:+[0] <n_a10F>_N)
           :: n_a10F GHC.Internal.Prim.~# (Z + n_a10F))
        ((\ (@(w_a10q :: Nat)) ->
            GHC.Internal.Data.Type.Equality.$WRefl @Nat @(S (S w_a10q)))
         `cast` (forall (w :: <Nat>_N).
                 ((:~:)
                    <Nat>_N
                    ((S (Sym (Ifoldl.D:R:+[0] <S w>_N)))_N
                     ; Sym (Ifoldl.D:R:+[1] <Z>_N <S w>_N))
                    ((S ((S (Sym (Ifoldl.D:R:+[0] <w>_N)))_N
                         ; Sym (Ifoldl.D:R:+[1] <Z>_N <w>_N)))_N
                     ; Sym (Ifoldl.D:R:+[1] <S Z>_N <w>_N)))_R
                 ; Sym (Ifoldl.N:Wonk <Z>_N <w>_N)
                 :: (forall (w :: Nat). S (S w) :~: S (S w))
                    ~R# (forall (w :: Nat). Wonk Z w)))
        ((Ifoldl.$WNil @a_a10G)
         `cast` (Sym (Ifoldl.N:Flip <Nat>_N <*>_N <Vec>_R <a_a10G>_N <Z>_N)
                 :: Vec Z a_a10G ~R# Flip Vec a_a10G Z))
        x_a1k3

-- RHS size: {terms: 1, types: 0, coercions: 15, joins: 0/0}
reverseVec :: forall (n :: Nat) a. Vec n a -> Vec n a
[GblId,
 Arity=1,
 Str=<1L>,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
reverseVec
  = Ifoldl.reverseVec1
    `cast` (forall (n :: <Nat>_N) (a :: <*>_N).
            <Vec n a>_R
            %<Many>_N ->_R Ifoldl.N:Flip <Nat>_N <*>_N <Vec>_R <a>_N <n>_N
            :: (forall (n :: Nat) a. Vec n a -> Flip Vec a n)
               ~R# (forall (n :: Nat) a. Vec n a -> Vec n a))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$trModule4 :: GHC.Internal.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 0}]
Ifoldl.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$trModule3 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$trModule3 = GHC.Internal.Types.TrNameS Ifoldl.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$trModule2 :: GHC.Internal.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
Ifoldl.$trModule2 = "Ifoldl"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$trModule1 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$trModule1 = GHC.Internal.Types.TrNameS Ifoldl.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$trModule :: GHC.Internal.Types.Module
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$trModule
  = GHC.Internal.Types.Module Ifoldl.$trModule3 Ifoldl.$trModule1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep_r1nB :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep_r1nB = GHC.Internal.Types.KindRepVar 1#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep1_r1nC :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep1_r1nC
  = GHC.Internal.Types.KindRepFun
      $krep_r1nB GHC.Internal.Types.krep$*

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep2_r1nD :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep2_r1nD = GHC.Internal.Types.KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep3_r1nE :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep3_r1nE = GHC.Internal.Types.KindRepFun $krep2_r1nD $krep1_r1nC

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4_r1nF :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep4_r1nF
  = GHC.Internal.Types.KindRepFun
      $krep2_r1nD GHC.Internal.Types.krep$*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5_r1nG :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep5_r1nG = GHC.Internal.Types.KindRepFun $krep_r1nB $krep4_r1nF

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tcFlip1 [InlPrag=[~]] :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
Ifoldl.$tcFlip1
  = GHC.Internal.Types.KindRepFun $krep3_r1nE $krep5_r1nG

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep6_r1nH :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep6_r1nH = GHC.Internal.Types.KindRepVar 2#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep7_r1nI :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep7_r1nI = GHC.Internal.Types.KindRepVar 3#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep8_r1nJ :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep8_r1nJ = GHC.Internal.Types.KindRepVar 4#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep9_r1nK :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep9_r1nK = GHC.Internal.Types.KindRepApp $krep6_r1nH $krep8_r1nJ

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep10_r1nL :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep10_r1nL
  = GHC.Internal.Types.KindRepApp $krep9_r1nK $krep7_r1nI

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tcNat2 :: GHC.Internal.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 0}]
Ifoldl.$tcNat2 = "Nat"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tcNat1 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$tcNat1 = GHC.Internal.Types.TrNameS Ifoldl.$tcNat2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tcNat :: GHC.Internal.Types.TyCon
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$tcNat
  = GHC.Internal.Types.TyCon
      18236869020729724782#Word64
      4245855676397049056#Word64
      Ifoldl.$trModule
      Ifoldl.$tcNat1
      0#
      GHC.Internal.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Ifoldl.$tc'Z1 [InlPrag=[~]] :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
Ifoldl.$tc'Z1
  = GHC.Internal.Types.KindRepTyConApp
      Ifoldl.$tcNat (GHC.Internal.Types.[] @GHC.Internal.Types.KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tc'Z3 :: GHC.Internal.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 0}]
Ifoldl.$tc'Z3 = "'Z"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tc'Z2 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$tc'Z2 = GHC.Internal.Types.TrNameS Ifoldl.$tc'Z3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tc'Z :: GHC.Internal.Types.TyCon
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$tc'Z
  = GHC.Internal.Types.TyCon
      12150613558191457985#Word64
      17820276006185949984#Word64
      Ifoldl.$trModule
      Ifoldl.$tc'Z2
      0#
      Ifoldl.$tc'Z1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep11_r1nM :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep11_r1nM
  = GHC.Internal.Types.KindRepTyConApp
      Ifoldl.$tc'Z (GHC.Internal.Types.[] @GHC.Internal.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tcVec1 [InlPrag=[~]] :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
Ifoldl.$tcVec1
  = GHC.Internal.Types.KindRepFun
      Ifoldl.$tc'Z1 GHC.Internal.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep12_r1nN :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep12_r1nN
  = GHC.Internal.Types.KindRepFun
      Ifoldl.$tc'Z1 GHC.Internal.Types.krep$*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tcWonk1 [InlPrag=[~]] :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
Ifoldl.$tcWonk1
  = GHC.Internal.Types.KindRepFun Ifoldl.$tc'Z1 $krep12_r1nN

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tc'S1 [InlPrag=[~]] :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
Ifoldl.$tc'S1
  = GHC.Internal.Types.KindRepFun Ifoldl.$tc'Z1 Ifoldl.$tc'Z1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tc'S3 :: GHC.Internal.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 0}]
Ifoldl.$tc'S3 = "'S"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tc'S2 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$tc'S2 = GHC.Internal.Types.TrNameS Ifoldl.$tc'S3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tc'S :: GHC.Internal.Types.TyCon
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$tc'S
  = GHC.Internal.Types.TyCon
      11382371654426533936#Word64
      12395597000343428369#Word64
      Ifoldl.$trModule
      Ifoldl.$tc'S2
      0#
      Ifoldl.$tc'S1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep13_r1nO :: [GHC.Internal.Types.KindRep]
[GblId, Unf=OtherCon []]
$krep13_r1nO
  = GHC.Internal.Types.:
      @GHC.Internal.Types.KindRep
      $krep_r1nB
      (GHC.Internal.Types.[] @GHC.Internal.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep14_r1nP :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep14_r1nP
  = GHC.Internal.Types.KindRepTyConApp Ifoldl.$tc'S $krep13_r1nO

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tcVec3 :: GHC.Internal.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 0}]
Ifoldl.$tcVec3 = "Vec"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tcVec2 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$tcVec2 = GHC.Internal.Types.TrNameS Ifoldl.$tcVec3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tcVec :: GHC.Internal.Types.TyCon
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$tcVec
  = GHC.Internal.Types.TyCon
      14854607458058977841#Word64
      8374922991311866538#Word64
      Ifoldl.$trModule
      Ifoldl.$tcVec2
      0#
      Ifoldl.$tcVec1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep15_r1nQ :: [GHC.Internal.Types.KindRep]
[GblId, Unf=OtherCon []]
$krep15_r1nQ
  = GHC.Internal.Types.:
      @GHC.Internal.Types.KindRep
      $krep2_r1nD
      (GHC.Internal.Types.[] @GHC.Internal.Types.KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep16_r1nR :: [GHC.Internal.Types.KindRep]
[GblId, Unf=OtherCon []]
$krep16_r1nR
  = GHC.Internal.Types.:
      @GHC.Internal.Types.KindRep $krep_r1nB $krep15_r1nQ

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep17_r1nS :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep17_r1nS
  = GHC.Internal.Types.KindRepTyConApp Ifoldl.$tcVec $krep16_r1nR

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep18_r1nT :: [GHC.Internal.Types.KindRep]
[GblId, Unf=OtherCon []]
$krep18_r1nT
  = GHC.Internal.Types.:
      @GHC.Internal.Types.KindRep $krep14_r1nP $krep15_r1nQ

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep19_r1nU :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep19_r1nU
  = GHC.Internal.Types.KindRepTyConApp Ifoldl.$tcVec $krep18_r1nT

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep20_r1nV :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep20_r1nV
  = GHC.Internal.Types.KindRepFun $krep17_r1nS $krep19_r1nU

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tc':::1 [InlPrag=[~]] :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
Ifoldl.$tc':::1
  = GHC.Internal.Types.KindRepFun $krep2_r1nD $krep20_r1nV

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tc':::3 :: GHC.Internal.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 0}]
Ifoldl.$tc':::3 = "':::"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tc':::2 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$tc':::2 = GHC.Internal.Types.TrNameS Ifoldl.$tc':::3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tc'::: :: GHC.Internal.Types.TyCon
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$tc':::
  = GHC.Internal.Types.TyCon
      334686219684160234#Word64
      3014902632845087398#Word64
      Ifoldl.$trModule
      Ifoldl.$tc':::2
      2#
      Ifoldl.$tc':::1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep21_r1nW :: [GHC.Internal.Types.KindRep]
[GblId, Unf=OtherCon []]
$krep21_r1nW
  = GHC.Internal.Types.:
      @GHC.Internal.Types.KindRep $krep11_r1nM $krep15_r1nQ

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tc'Nil1 [InlPrag=[~]] :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
Ifoldl.$tc'Nil1
  = GHC.Internal.Types.KindRepTyConApp Ifoldl.$tcVec $krep21_r1nW

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tc'Nil3 :: GHC.Internal.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 0}]
Ifoldl.$tc'Nil3 = "'Nil"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tc'Nil2 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$tc'Nil2 = GHC.Internal.Types.TrNameS Ifoldl.$tc'Nil3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tc'Nil :: GHC.Internal.Types.TyCon
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$tc'Nil
  = GHC.Internal.Types.TyCon
      6632636372057876164#Word64
      13532705703229277899#Word64
      Ifoldl.$trModule
      Ifoldl.$tc'Nil2
      1#
      Ifoldl.$tc'Nil1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tcWonk3 :: GHC.Internal.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 0}]
Ifoldl.$tcWonk3 = "Wonk"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tcWonk2 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$tcWonk2 = GHC.Internal.Types.TrNameS Ifoldl.$tcWonk3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tcWonk :: GHC.Internal.Types.TyCon
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$tcWonk
  = GHC.Internal.Types.TyCon
      2107340412666559272#Word64
      605784541161197679#Word64
      Ifoldl.$trModule
      Ifoldl.$tcWonk2
      0#
      Ifoldl.$tcWonk1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tcFlip3 :: GHC.Internal.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 0}]
Ifoldl.$tcFlip3 = "Flip"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tcFlip2 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$tcFlip2 = GHC.Internal.Types.TrNameS Ifoldl.$tcFlip3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tcFlip :: GHC.Internal.Types.TyCon
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$tcFlip
  = GHC.Internal.Types.TyCon
      562740838472115680#Word64
      15461924706169976739#Word64
      Ifoldl.$trModule
      Ifoldl.$tcFlip2
      2#
      Ifoldl.$tcFlip1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep22_r1nX :: [GHC.Internal.Types.KindRep]
[GblId, Unf=OtherCon []]
$krep22_r1nX
  = GHC.Internal.Types.:
      @GHC.Internal.Types.KindRep
      $krep8_r1nJ
      (GHC.Internal.Types.[] @GHC.Internal.Types.KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep23_r1nY :: [GHC.Internal.Types.KindRep]
[GblId, Unf=OtherCon []]
$krep23_r1nY
  = GHC.Internal.Types.:
      @GHC.Internal.Types.KindRep $krep7_r1nI $krep22_r1nX

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep24_r1nZ :: [GHC.Internal.Types.KindRep]
[GblId, Unf=OtherCon []]
$krep24_r1nZ
  = GHC.Internal.Types.:
      @GHC.Internal.Types.KindRep $krep6_r1nH $krep23_r1nY

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep25_r1o0 :: [GHC.Internal.Types.KindRep]
[GblId, Unf=OtherCon []]
$krep25_r1o0
  = GHC.Internal.Types.:
      @GHC.Internal.Types.KindRep $krep_r1nB $krep24_r1nZ

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep26_r1o1 :: [GHC.Internal.Types.KindRep]
[GblId, Unf=OtherCon []]
$krep26_r1o1
  = GHC.Internal.Types.:
      @GHC.Internal.Types.KindRep $krep2_r1nD $krep25_r1o0

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep27_r1o2 :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep27_r1o2
  = GHC.Internal.Types.KindRepTyConApp Ifoldl.$tcFlip $krep26_r1o1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tc'Flip1 [InlPrag=[~]] :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
Ifoldl.$tc'Flip1
  = GHC.Internal.Types.KindRepFun $krep10_r1nL $krep27_r1o2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tc'Flip3 :: GHC.Internal.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
Ifoldl.$tc'Flip3 = "'Flip"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tc'Flip2 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$tc'Flip2 = GHC.Internal.Types.TrNameS Ifoldl.$tc'Flip3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Ifoldl.$tc'Flip :: GHC.Internal.Types.TyCon
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
Ifoldl.$tc'Flip
  = GHC.Internal.Types.TyCon
      7623277265010559423#Word64
      16926366384040641029#Word64
      Ifoldl.$trModule
      Ifoldl.$tc'Flip2
      5#
      Ifoldl.$tc'Flip1



