[1 of 2] Compiling T26615a          ( T26615a.hs, T26615a.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 1,209, types: 1,139, coercions: 18, joins: 17/29}

-- RHS size: {terms: 6, types: 8, coercions: 0, joins: 0/0}
unArray :: forall a. Array a -> SmallArray# a
[GblId[[RecSel]],
 Arity=1,
 Str=<1!P(1L)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
unArray = \ (@a) (ds :: Array a) -> case ds of { Array ds1 -> ds1 }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T26615a.$trModule4 :: Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 0}]
T26615a.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T26615a.$trModule3 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$trModule3 = GHC.Internal.Types.TrNameS T26615a.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T26615a.$trModule2 :: Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
T26615a.$trModule2 = "T26615a"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T26615a.$trModule1 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$trModule1 = GHC.Internal.Types.TrNameS T26615a.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T26615a.$trModule :: GHC.Internal.Types.Module
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$trModule
  = GHC.Internal.Types.Module T26615a.$trModule3 T26615a.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep
  = GHC.Internal.Types.KindRepTyConApp
      GHC.Internal.Types.$tc'Lifted
      (GHC.Internal.Types.[] @GHC.Internal.Types.KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1 :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep1
  = GHC.Internal.Types.KindRepTyConApp
      GHC.Internal.Types.$tcWord
      (GHC.Internal.Types.[] @GHC.Internal.Types.KindRep)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep2 :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep2 = GHC.Internal.Types.KindRepVar 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep3 :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep3 = GHC.Internal.Types.KindRepVar 0#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep4 :: [GHC.Internal.Types.KindRep]
[GblId, Unf=OtherCon []]
$krep4
  = GHC.Internal.Types.:
      @GHC.Internal.Types.KindRep
      $krep3
      (GHC.Internal.Types.[] @GHC.Internal.Types.KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep5 :: [GHC.Internal.Types.KindRep]
[GblId, Unf=OtherCon []]
$krep5
  = GHC.Internal.Types.: @GHC.Internal.Types.KindRep $krep $krep4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep6 :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep6
  = GHC.Internal.Types.KindRepTyConApp
      GHC.Internal.Types.$tcSmallArray# $krep5

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T26615a.$tcLeaf2 :: Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 0}]
T26615a.$tcLeaf2 = "Leaf"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T26615a.$tcLeaf1 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tcLeaf1 = GHC.Internal.Types.TrNameS T26615a.$tcLeaf2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
T26615a.$tcLeaf :: GHC.Internal.Types.TyCon
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tcLeaf
  = GHC.Internal.Types.TyCon
      13798714324392902582#Word64
      3237499036029031497#Word64
      T26615a.$trModule
      T26615a.$tcLeaf1
      0#
      GHC.Internal.Types.krep$*->*->*

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep7 :: [GHC.Internal.Types.KindRep]
[GblId, Unf=OtherCon []]
$krep7
  = GHC.Internal.Types.:
      @GHC.Internal.Types.KindRep
      $krep2
      (GHC.Internal.Types.[] @GHC.Internal.Types.KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep8 :: [GHC.Internal.Types.KindRep]
[GblId, Unf=OtherCon []]
$krep8
  = GHC.Internal.Types.: @GHC.Internal.Types.KindRep $krep3 $krep7

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep9 :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep9 = GHC.Internal.Types.KindRepTyConApp T26615a.$tcLeaf $krep8

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep10 :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep10 = GHC.Internal.Types.KindRepFun $krep2 $krep9

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'L1 [InlPrag=[~]] :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
T26615a.$tc'L1 = GHC.Internal.Types.KindRepFun $krep3 $krep10

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'L3 :: Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 0}]
T26615a.$tc'L3 = "'L"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'L2 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tc'L2 = GHC.Internal.Types.TrNameS T26615a.$tc'L3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'L :: GHC.Internal.Types.TyCon
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tc'L
  = GHC.Internal.Types.TyCon
      8570419491837374712#Word64
      2090006989092642392#Word64
      T26615a.$trModule
      T26615a.$tc'L2
      2#
      T26615a.$tc'L1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T26615a.$tcArray2 :: Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
T26615a.$tcArray2 = "Array"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T26615a.$tcArray1 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tcArray1 = GHC.Internal.Types.TrNameS T26615a.$tcArray2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
T26615a.$tcArray :: GHC.Internal.Types.TyCon
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tcArray
  = GHC.Internal.Types.TyCon
      10495761415291712389#Word64
      7580086293698619153#Word64
      T26615a.$trModule
      T26615a.$tcArray1
      0#
      GHC.Internal.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep11 :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep11
  = GHC.Internal.Types.KindRepTyConApp T26615a.$tcArray $krep4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Array1 [InlPrag=[~]] :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
T26615a.$tc'Array1 = GHC.Internal.Types.KindRepFun $krep6 $krep11

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Array3 :: Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
T26615a.$tc'Array3 = "'Array"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Array2 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tc'Array2 = GHC.Internal.Types.TrNameS T26615a.$tc'Array3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Array :: GHC.Internal.Types.TyCon
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tc'Array
  = GHC.Internal.Types.TyCon
      12424115309881832159#Word64
      15542868641947707803#Word64
      T26615a.$trModule
      T26615a.$tc'Array2
      1#
      T26615a.$tc'Array1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep12 :: [GHC.Internal.Types.KindRep]
[GblId, Unf=OtherCon []]
$krep12
  = GHC.Internal.Types.:
      @GHC.Internal.Types.KindRep
      $krep9
      (GHC.Internal.Types.[] @GHC.Internal.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep13 :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep13
  = GHC.Internal.Types.KindRepTyConApp T26615a.$tcArray $krep12

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T26615a.$tcHashMap2 :: Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
T26615a.$tcHashMap2 = "HashMap"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T26615a.$tcHashMap1 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tcHashMap1
  = GHC.Internal.Types.TrNameS T26615a.$tcHashMap2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
T26615a.$tcHashMap :: GHC.Internal.Types.TyCon
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tcHashMap
  = GHC.Internal.Types.TyCon
      2021755758654901686#Word64
      8209241086311595496#Word64
      T26615a.$trModule
      T26615a.$tcHashMap1
      0#
      GHC.Internal.Types.krep$*->*->*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Empty1 [InlPrag=[~]] :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
T26615a.$tc'Empty1
  = GHC.Internal.Types.KindRepTyConApp T26615a.$tcHashMap $krep8

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Empty3 :: Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
T26615a.$tc'Empty3 = "'Empty"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Empty2 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tc'Empty2 = GHC.Internal.Types.TrNameS T26615a.$tc'Empty3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Empty :: GHC.Internal.Types.TyCon
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tc'Empty
  = GHC.Internal.Types.TyCon
      2520556399233147460#Word64
      17224648764450205443#Word64
      T26615a.$trModule
      T26615a.$tc'Empty2
      2#
      T26615a.$tc'Empty1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep14 :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep14 = GHC.Internal.Types.KindRepFun $krep9 T26615a.$tc'Empty1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Leaf1 [InlPrag=[~]] :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
T26615a.$tc'Leaf1 = GHC.Internal.Types.KindRepFun $krep1 $krep14

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Leaf3 :: Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
T26615a.$tc'Leaf3 = "'Leaf"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Leaf2 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tc'Leaf2 = GHC.Internal.Types.TrNameS T26615a.$tc'Leaf3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Leaf :: GHC.Internal.Types.TyCon
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tc'Leaf
  = GHC.Internal.Types.TyCon
      5773656560257991946#Word64
      17028074687139582545#Word64
      T26615a.$trModule
      T26615a.$tc'Leaf2
      2#
      T26615a.$tc'Leaf1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep15 :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep15 = GHC.Internal.Types.KindRepFun $krep13 T26615a.$tc'Empty1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Collision1 [InlPrag=[~]] :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
T26615a.$tc'Collision1
  = GHC.Internal.Types.KindRepFun $krep1 $krep15

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Collision3 :: Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 40 0}]
T26615a.$tc'Collision3 = "'Collision"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Collision2 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tc'Collision2
  = GHC.Internal.Types.TrNameS T26615a.$tc'Collision3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Collision :: GHC.Internal.Types.TyCon
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tc'Collision
  = GHC.Internal.Types.TyCon
      18175105753528304021#Word64
      13986842878006680511#Word64
      T26615a.$trModule
      T26615a.$tc'Collision2
      2#
      T26615a.$tc'Collision1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep16 :: [GHC.Internal.Types.KindRep]
[GblId, Unf=OtherCon []]
$krep16
  = GHC.Internal.Types.:
      @GHC.Internal.Types.KindRep
      T26615a.$tc'Empty1
      (GHC.Internal.Types.[] @GHC.Internal.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep17 :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
$krep17
  = GHC.Internal.Types.KindRepTyConApp T26615a.$tcArray $krep16

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Full1 [InlPrag=[~]] :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
T26615a.$tc'Full1
  = GHC.Internal.Types.KindRepFun $krep17 T26615a.$tc'Empty1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Full3 :: Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
T26615a.$tc'Full3 = "'Full"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Full2 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tc'Full2 = GHC.Internal.Types.TrNameS T26615a.$tc'Full3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'Full :: GHC.Internal.Types.TyCon
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tc'Full
  = GHC.Internal.Types.TyCon
      12008762105994325570#Word64
      13514145886440831186#Word64
      T26615a.$trModule
      T26615a.$tc'Full2
      2#
      T26615a.$tc'Full1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'BitmapIndexed1 [InlPrag=[~]]
  :: GHC.Internal.Types.KindRep
[GblId, Unf=OtherCon []]
T26615a.$tc'BitmapIndexed1
  = GHC.Internal.Types.KindRepFun $krep1 T26615a.$tc'Full1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'BitmapIndexed3 :: Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 0}]
T26615a.$tc'BitmapIndexed3 = "'BitmapIndexed"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'BitmapIndexed2 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tc'BitmapIndexed2
  = GHC.Internal.Types.TrNameS T26615a.$tc'BitmapIndexed3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
T26615a.$tc'BitmapIndexed :: GHC.Internal.Types.TyCon
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615a.$tc'BitmapIndexed
  = GHC.Internal.Types.TyCon
      15226751910432948177#Word64
      957331387129868915#Word64
      T26615a.$trModule
      T26615a.$tc'BitmapIndexed2
      2#
      T26615a.$tc'BitmapIndexed1

-- RHS size: {terms: 98, types: 109, coercions: 0, joins: 3/4}
T26615a.$wdisjointCollisions [InlPrag=INLINABLE[2]]
  :: forall k a b.
     Eq k =>
     Word#
     -> Array (Leaf k a) -> Word# -> SmallArray# (Leaf k b) -> Bool
[GblId[StrictWorker([~, ~, !])],
 Arity=5,
 Str=<LP(SC(S,C(1,L)),A)><L><1L><L><L>,
 Unf=Unf{Src=StableUser, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 20 0 0] 406 10
         Tmpl= \ (@k)
                 (@a)
                 (@b)
                 ($dEq :: Eq k)
                 (ww [Occ=Once1] :: Word#)
                 (aryA [Occ=Once1!] :: Array (Leaf k a))
                 (ww1 [Occ=Once1] :: Word#)
                 (ww2 :: SmallArray# (Leaf k b)) ->
                 case aryA of aryA1 [Occ=Once1] { Array ipv [Occ=Once1] ->
                 let {
                   aryB [Occ=OnceL1] :: Array (Leaf k b)
                   [LclId, Unf=OtherCon []]
                   aryB = T26615a.Array @(Leaf k b) ww2 } in
                 case GHC.Internal.Classes.eqWord
                        (GHC.Internal.Types.W# ww) (GHC.Internal.Types.W# ww1)
                 of {
                   False -> GHC.Internal.Types.True;
                   True ->
                     joinrec {
                       foldr_ [Occ=LoopBreakerT[4]]
                         :: Array (Leaf k a) -> Int -> Int -> Bool -> Bool
                       [LclId[JoinId(4)(Nothing)],
                        Arity=4,
                        Str=<L><L><L><L>,
                        Unf=OtherCon []]
                       foldr_ (ary [Occ=Once1!] :: Array (Leaf k a))
                              (n :: Int)
                              (i :: Int)
                              (z [Occ=Once2] :: Bool)
                         = case GHC.Internal.Classes.geInt i n of {
                             False ->
                               case i of { I# i# ->
                               case ary of wild3 [Occ=Once1] { Array ds [Occ=Once1] ->
                               case indexSmallArray# @Lifted @(Leaf k a) ds i# of
                               { (# ipv1 [Occ=Once1!] #) ->
                               case ipv1 of { L kA [Occ=Once1] _ [Occ=Dead] ->
                               join {
                                 $j [Occ=OnceL1T[0]] :: Bool
                                 [LclId[JoinId(0)(Nothing)]]
                                 $j = jump foldr_ wild3 n (GHC.Internal.Types.I# (+# i# 1#)) z } in
                               joinrec {
                                 lookupInArrayCont_ [Occ=LoopBreakerT[5]]
                                   :: Eq k => k -> Array (Leaf k b) -> Int -> Int -> Bool
                                 [LclId[JoinId(5)(Nothing)],
                                  Arity=5,
                                  Str=<L><L><L><L><L>,
                                  Unf=OtherCon []]
                                 lookupInArrayCont_ _ [Occ=Dead]
                                                    (k1 [Occ=Once1] :: k)
                                                    (ary1 [Occ=Once1!] :: Array (Leaf k b))
                                                    (i1 [Occ=Once1!] :: Int)
                                                    (n1 [Occ=Once1!] :: Int)
                                   = case k1 of k2 { __DEFAULT ->
                                     case ary1 of ary2 [Occ=Once1] { Array ipv2 [Occ=Once1] ->
                                     case i1 of i2 [Occ=Once1] { I# ipv3 ->
                                     case n1 of n2 { I# _ [Occ=Dead] ->
                                     case GHC.Internal.Classes.geInt i2 n2 of {
                                       False ->
                                         case indexSmallArray# @Lifted @(Leaf k b) ipv2 ipv3 of
                                         { (# ipv5 [Occ=Once1!] #) ->
                                         case ipv5 of { L kx [Occ=Once1] _ [Occ=Dead] ->
                                         case == @k $dEq k2 kx of {
                                           False ->
                                             jump lookupInArrayCont_
                                               $dEq k2 ary2 (GHC.Internal.Types.I# (+# ipv3 1#)) n2;
                                           True -> GHC.Internal.Types.False
                                         }
                                         }
                                         };
                                       True -> jump $j
                                     }
                                     }
                                     }
                                     }
                                     }; } in
                               jump lookupInArrayCont_
                                 $dEq
                                 kA
                                 aryB
                                 (GHC.Internal.Types.I# 0#)
                                 (GHC.Internal.Types.I# (sizeofSmallArray# @Lifted @(Leaf k b) ww2))
                               }
                               }
                               }
                               };
                             True -> z
                           }; } in
                     jump foldr_
                       aryA1
                       (GHC.Internal.Types.I# (sizeofSmallArray# @Lifted @(Leaf k a) ipv))
                       (GHC.Internal.Types.I# 0#)
                       GHC.Internal.Types.True
                 }
                 }}]
T26615a.$wdisjointCollisions
  = \ (@k)
      (@a)
      (@b)
      ($dEq :: Eq k)
      (ww :: Word#)
      (aryA :: Array (Leaf k a))
      (ww1 :: Word#)
      (ww2 :: SmallArray# (Leaf k b)) ->
      case aryA of { Array ipv ->
      case eqWord# ww ww1 of {
        __DEFAULT -> GHC.Internal.Types.True;
        1# ->
          let {
            lvl2 :: Int#
            [LclId]
            lvl2 = sizeofSmallArray# @Lifted @(Leaf k b) ww2 } in
          joinrec {
            $s$wfoldr_ [InlPrag=[2],
                        Occ=LoopBreaker,
                        Dmd=SC(S,C(1,C(1,C(1,L))))]
              :: Bool -> Int# -> Int# -> SmallArray# (Leaf k a) -> Bool
            [LclId[JoinId(4)(Nothing)],
             Arity=4,
             Str=<L><L><L><L>,
             Unf=OtherCon []]
            $s$wfoldr_ (sc :: Bool)
                       (sc1 :: Int#)
                       (sc2 :: Int#)
                       (sc3 :: SmallArray# (Leaf k a))
              = case >=# sc1 sc2 of {
                  __DEFAULT ->
                    case indexSmallArray# @Lifted @(Leaf k a) sc3 sc1 of
                    { (# ipv1 #) ->
                    case ipv1 of { L kA ds1 ->
                    join {
                      $j :: Bool
                      [LclId[JoinId(0)(Nothing)]]
                      $j = jump $s$wfoldr_ sc (+# sc1 1#) sc2 sc3 } in
                    joinrec {
                      $wlookupInArrayCont_ [InlPrag=[2],
                                            Occ=LoopBreaker,
                                            Dmd=SC(S,C(1,C(1,C(1,L))))]
                        :: k -> SmallArray# (Leaf k b) -> Int# -> Int# -> Bool
                      [LclId[JoinId(4)(Just [!])],
                       Arity=4,
                       Str=<1L><L><L><L>,
                       Unf=OtherCon []]
                      $wlookupInArrayCont_ (k1 :: k)
                                           (ww3 :: SmallArray# (Leaf k b))
                                           (ww4 :: Int#)
                                           (ww5 :: Int#)
                        = case k1 of k2 { __DEFAULT ->
                          case >=# ww4 ww5 of {
                            __DEFAULT ->
                              case indexSmallArray# @Lifted @(Leaf k b) ww3 ww4 of
                              { (# ipv2 #) ->
                              case ipv2 of { L kx v ->
                              case == @k $dEq k2 kx of {
                                False -> jump $wlookupInArrayCont_ k2 ww3 (+# ww4 1#) ww5;
                                True -> GHC.Internal.Types.False
                              }
                              }
                              };
                            1# -> jump $j
                          }
                          }; } in
                    jump $wlookupInArrayCont_ kA ww2 0# lvl2
                    }
                    };
                  1# -> sc
                }; } in
          jump $s$wfoldr_
            GHC.Internal.Types.True
            0#
            (sizeofSmallArray# @Lifted @(Leaf k a) ipv)
            ipv
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Addr#
[GblId, Unf=OtherCon []]
lvl = "T26615a.hs:(26,1)-(65,59)|function disjointSubtrees"#

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
lvl1 :: ()
[GblId, Str=b, Cpr=b]
lvl1
  = GHC.Internal.Control.Exception.Base.patError @LiftedRep @() lvl

Rec {
-- RHS size: {terms: 133, types: 126, coercions: 0, joins: 1/2}
T26615a.disjointSubtrees_$s$wdisjointSubtrees [InlPrag=INLINABLE[2],
                                               Occ=LoopBreaker]
  :: forall b a k.
     Word#
     -> SmallArray# (Leaf k a) -> Int# -> Eq k => HashMap k b -> Bool
[GblId[StrictWorker([~, ~, ~, ~, !])],
 Arity=5,
 Str=<L><L><L><LP(SC(S,C(1,L)),A)><1L>,
 Unf=OtherCon []]
T26615a.disjointSubtrees_$s$wdisjointSubtrees
  = \ (@b)
      (@a)
      (@k)
      (sc :: Word#)
      (sc1 :: SmallArray# (Leaf k a))
      (sc2 :: Int#)
      (sc3 :: Eq k)
      (_b :: HashMap k b) ->
      case _b of {
        Empty -> GHC.Internal.Types.True;
        Leaf bx ds ->
          case ds of { L kB ds1 ->
          case kB of k0 { __DEFAULT ->
          case eqWord# bx sc of {
            __DEFAULT -> GHC.Internal.Types.True;
            1# ->
              joinrec {
                $wlookupInArrayCont_ [InlPrag=[2],
                                      Occ=LoopBreaker,
                                      Dmd=SC(S,C(1,C(1,C(1,L))))]
                  :: k -> SmallArray# (Leaf k a) -> Int# -> Int# -> Bool
                [LclId[JoinId(4)(Just [!])],
                 Arity=4,
                 Str=<1L><L><L><L>,
                 Unf=OtherCon []]
                $wlookupInArrayCont_ (k1 :: k)
                                     (ww :: SmallArray# (Leaf k a))
                                     (ww1 :: Int#)
                                     (ww2 :: Int#)
                  = case k1 of k2 { __DEFAULT ->
                    case >=# ww1 ww2 of {
                      __DEFAULT ->
                        case indexSmallArray# @Lifted @(Leaf k a) ww ww1 of { (# ipv #) ->
                        case ipv of { L kx v ->
                        case == @k sc3 k2 kx of {
                          False -> jump $wlookupInArrayCont_ k2 ww (+# ww1 1#) ww2;
                          True -> GHC.Internal.Types.False
                        }
                        }
                        };
                      1# -> GHC.Internal.Types.True
                    }
                    }; } in
              jump $wlookupInArrayCont_
                k0 sc1 0# (sizeofSmallArray# @Lifted @(Leaf k a) sc1)
          }
          }
          };
        Collision bx bx1 ->
          T26615a.$wdisjointCollisions
            @k @a @b sc3 sc (T26615a.Array @(Leaf k a) sc1) bx bx1;
        BitmapIndexed bx bx1 ->
          let {
            m :: Word#
            [LclId]
            m = uncheckedShiftL#
                  1## (word2Int# (and# (uncheckedShiftRL# sc sc2) 31##)) } in
          case and# m bx of {
            __DEFAULT ->
              case indexSmallArray#
                     @Lifted
                     @(HashMap k b)
                     bx1
                     (word2Int# (popCnt# (and# bx (minusWord# m 1##))))
              of
              { (# ipv #) ->
              T26615a.disjointSubtrees_$s$wdisjointSubtrees
                @b @a @k sc sc1 (+# sc2 5#) sc3 ipv
              };
            0## -> GHC.Internal.Types.True
          };
        Full bx ->
          case indexSmallArray#
                 @Lifted
                 @(HashMap k b)
                 bx
                 (word2Int# (and# (uncheckedShiftRL# sc sc2) 31##))
          of
          { (# ipv #) ->
          T26615a.disjointSubtrees_$s$wdisjointSubtrees
            @b @a @k sc sc1 (+# sc2 5#) sc3 ipv
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 705, types: 732, coercions: 18, joins: 13/23}
T26615a.$wdisjointSubtrees [InlPrag=INLINABLE[2], Occ=LoopBreaker]
  :: forall k a b. Eq k => Int# -> HashMap k a -> HashMap k b -> Bool
[GblId[StrictWorker([~, ~, !])],
 Arity=4,
 Str=<LP(LC(L,C(1,L)),LC(S,C(1,L)))><L><SL><L>,
 Unf=Unf{Src=StableUser, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=NEVER
         Tmpl= \ (@k)
                 (@a)
                 (@b)
                 ($dEq :: Eq k)
                 (ww :: Int#)
                 (ds :: HashMap k a)
                 (_b :: HashMap k b) ->
                 join {
                   fail [Occ=Once3!T[1]] :: (# #) -> Bool
                   [LclId[JoinId(1)(Nothing)], Arity=1, Str=<L>, Unf=OtherCon []]
                   fail _ [Occ=Dead, OS=OneShot]
                     = case _b of wild [Occ=Once1] {
                         __DEFAULT ->
                           case GHC.Internal.Control.Exception.Base.patError
                                  @LiftedRep
                                  @()
                                  "T26615a.hs:(26,1)-(65,59)|function disjointSubtrees"#
                           of {};
                         Empty -> GHC.Internal.Types.True;
                         Leaf bx [Occ=Once1] ds2 [Occ=Once1!] ->
                           case ds2 of { L kB [Occ=Once1] _ [Occ=Dead] ->
                           case kB of k0 [Occ=Once1] { __DEFAULT ->
                           joinrec {
                             lookupCont_ [Occ=LoopBreakerT[5]]
                               :: Eq k => Word -> k -> Int -> HashMap k a -> Bool
                             [LclId[JoinId(5)(Nothing)],
                              Arity=5,
                              Str=<L><L><L><L><L>,
                              Unf=OtherCon []]
                             lookupCont_ _ [Occ=Dead]
                                         (ds4 [Occ=Once1!] :: Word)
                                         (ds5 [Occ=Once1] :: k)
                                         (ds6 [Occ=Once1!] :: Int)
                                         (ds7 [Occ=Once1!] :: HashMap k a)
                               = case ds4 of ds8 [Occ=Once4] { W# ipv [Occ=Once2] ->
                                 case ds5 of ds9 [Occ=Once4] { __DEFAULT ->
                                 case ds6 of { I# ipv1 ->
                                 case ds7 of {
                                   Empty -> GHC.Internal.Types.True;
                                   Leaf bx1 [Occ=Once1] ds11 [Occ=Once1!] ->
                                     case ds11 of { L kx [Occ=Once1] _ [Occ=Dead] ->
                                     case GHC.Internal.Classes.eqWord
                                            ds8 (GHC.Internal.Types.W# bx1)
                                     of {
                                       False -> GHC.Internal.Types.True;
                                       True ->
                                         case == @k $dEq ds9 kx of {
                                           False -> GHC.Internal.Types.True;
                                           True -> GHC.Internal.Types.False
                                         }
                                     }
                                     };
                                   Collision bx1 [Occ=Once1] bx2 ->
                                     case GHC.Internal.Classes.eqWord
                                            ds8 (GHC.Internal.Types.W# bx1)
                                     of {
                                       False -> GHC.Internal.Types.True;
                                       True ->
                                         joinrec {
                                           lookupInArrayCont_ [Occ=LoopBreakerT[5]]
                                             :: Eq k => k -> Array (Leaf k a) -> Int -> Int -> Bool
                                           [LclId[JoinId(5)(Nothing)],
                                            Arity=5,
                                            Str=<L><L><L><L><L>,
                                            Unf=OtherCon []]
                                           lookupInArrayCont_ _ [Occ=Dead]
                                                              (k1 [Occ=Once1] :: k)
                                                              (ary [Occ=Once1!] :: Array (Leaf k a))
                                                              (i [Occ=Once1!] :: Int)
                                                              (n [Occ=Once1!] :: Int)
                                             = case k1 of k2 { __DEFAULT ->
                                               case ary of ary1 [Occ=Once1]
                                               { Array ipv2 [Occ=Once1] ->
                                               case i of i1 [Occ=Once1] { I# ipv3 ->
                                               case n of n1 { I# _ [Occ=Dead] ->
                                               case GHC.Internal.Classes.geInt i1 n1 of {
                                                 False ->
                                                   case indexSmallArray#
                                                          @Lifted @(Leaf k a) ipv2 ipv3
                                                   of
                                                   { (# ipv5 [Occ=Once1!] #) ->
                                                   case ipv5 of { L kx [Occ=Once1] _ [Occ=Dead] ->
                                                   case == @k $dEq k2 kx of {
                                                     False ->
                                                       jump lookupInArrayCont_
                                                         $dEq
                                                         k2
                                                         ary1
                                                         (GHC.Internal.Types.I# (+# ipv3 1#))
                                                         n1;
                                                     True -> GHC.Internal.Types.False
                                                   }
                                                   }
                                                   };
                                                 True -> GHC.Internal.Types.True
                                               }
                                               }
                                               }
                                               }
                                               }; } in
                                         jump lookupInArrayCont_
                                           $dEq
                                           ds9
                                           (T26615a.Array @(Leaf k a) bx2)
                                           (GHC.Internal.Types.I# 0#)
                                           (GHC.Internal.Types.I#
                                              (sizeofSmallArray# @Lifted @(Leaf k a) bx2))
                                     };
                                   BitmapIndexed bx1 bx2 [Occ=Once1] ->
                                     let {
                                       m :: Word#
                                       [LclId]
                                       m = uncheckedShiftL#
                                             1##
                                             (word2Int#
                                                (and# (uncheckedShiftRL# ipv ipv1) 31##)) } in
                                     case GHC.Internal.Classes.eqWord
                                            (GHC.Internal.Types.W# (and# bx1 m))
                                            (GHC.Internal.Types.W# 0##)
                                     of {
                                       False ->
                                         case indexSmallArray#
                                                @Lifted
                                                @(HashMap k a)
                                                bx2
                                                (word2Int# (popCnt# (and# bx1 (minusWord# m 1##))))
                                         of
                                         { (# ipv2 [Occ=Once1] #) ->
                                         jump lookupCont_
                                           $dEq ds8 ds9 (GHC.Internal.Types.I# (+# ipv1 5#)) ipv2
                                         };
                                       True -> GHC.Internal.Types.True
                                     };
                                   Full bx1 [Occ=Once1] ->
                                     case indexSmallArray#
                                            @Lifted
                                            @(HashMap k a)
                                            bx1
                                            (word2Int# (and# (uncheckedShiftRL# ipv ipv1) 31##))
                                     of
                                     { (# ipv2 [Occ=Once1] #) ->
                                     jump lookupCont_
                                       $dEq ds8 ds9 (GHC.Internal.Types.I# (+# ipv1 5#)) ipv2
                                     }
                                 }
                                 }
                                 }
                                 }; } in
                           jump lookupCont_
                             $dEq (GHC.Internal.Types.W# bx) k0 (GHC.Internal.Types.I# ww) ds
                           }
                           };
                         Collision _ [Occ=Dead] _ [Occ=Dead] ->
                           T26615a.$wdisjointSubtrees @k @b @a $dEq ww wild ds
                       } } in
                 case ds of wild [Occ=Once2] {
                   Empty -> GHC.Internal.Types.True;
                   Leaf bx [Occ=Once2] ds1 [Occ=Once1!] ->
                     case ds1 of { L kA [Occ=Once2] _ [Occ=Dead] ->
                     case _b of wild2 [Occ=Once1] {
                       __DEFAULT ->
                         case kA of k0 [Occ=Once1] { __DEFAULT ->
                         joinrec {
                           lookupCont_ [Occ=LoopBreakerT[5]]
                             :: Eq k => Word -> k -> Int -> HashMap k b -> Bool
                           [LclId[JoinId(5)(Nothing)],
                            Arity=5,
                            Str=<L><L><L><L><L>,
                            Unf=OtherCon []]
                           lookupCont_ _ [Occ=Dead]
                                       (ds3 [Occ=Once1!] :: Word)
                                       (ds4 [Occ=Once1] :: k)
                                       (ds5 [Occ=Once1!] :: Int)
                                       (ds6 [Occ=Once1!] :: HashMap k b)
                             = case ds3 of ds7 [Occ=Once4] { W# ipv [Occ=Once2] ->
                               case ds4 of ds8 [Occ=Once4] { __DEFAULT ->
                               case ds5 of { I# ipv1 ->
                               case ds6 of {
                                 Empty -> GHC.Internal.Types.True;
                                 Leaf bx1 [Occ=Once1] ds10 [Occ=Once1!] ->
                                   case ds10 of { L kx [Occ=Once1] _ [Occ=Dead] ->
                                   case GHC.Internal.Classes.eqWord ds7 (GHC.Internal.Types.W# bx1)
                                   of {
                                     False -> GHC.Internal.Types.True;
                                     True ->
                                       case == @k $dEq ds8 kx of {
                                         False -> GHC.Internal.Types.True;
                                         True -> GHC.Internal.Types.False
                                       }
                                   }
                                   };
                                 Collision bx1 [Occ=Once1] bx2 ->
                                   case GHC.Internal.Classes.eqWord ds7 (GHC.Internal.Types.W# bx1)
                                   of {
                                     False -> GHC.Internal.Types.True;
                                     True ->
                                       joinrec {
                                         lookupInArrayCont_ [Occ=LoopBreakerT[5]]
                                           :: Eq k => k -> Array (Leaf k b) -> Int -> Int -> Bool
                                         [LclId[JoinId(5)(Nothing)],
                                          Arity=5,
                                          Str=<L><L><L><L><L>,
                                          Unf=OtherCon []]
                                         lookupInArrayCont_ _ [Occ=Dead]
                                                            (k1 [Occ=Once1] :: k)
                                                            (ary [Occ=Once1!] :: Array (Leaf k b))
                                                            (i [Occ=Once1!] :: Int)
                                                            (n [Occ=Once1!] :: Int)
                                           = case k1 of k2 { __DEFAULT ->
                                             case ary of ary1 [Occ=Once1]
                                             { Array ipv2 [Occ=Once1] ->
                                             case i of i1 [Occ=Once1] { I# ipv3 ->
                                             case n of n1 { I# _ [Occ=Dead] ->
                                             case GHC.Internal.Classes.geInt i1 n1 of {
                                               False ->
                                                 case indexSmallArray# @Lifted @(Leaf k b) ipv2 ipv3
                                                 of
                                                 { (# ipv5 [Occ=Once1!] #) ->
                                                 case ipv5 of { L kx [Occ=Once1] _ [Occ=Dead] ->
                                                 case == @k $dEq k2 kx of {
                                                   False ->
                                                     jump lookupInArrayCont_
                                                       $dEq
                                                       k2
                                                       ary1
                                                       (GHC.Internal.Types.I# (+# ipv3 1#))
                                                       n1;
                                                   True -> GHC.Internal.Types.False
                                                 }
                                                 }
                                                 };
                                               True -> GHC.Internal.Types.True
                                             }
                                             }
                                             }
                                             }
                                             }; } in
                                       jump lookupInArrayCont_
                                         $dEq
                                         ds8
                                         (T26615a.Array @(Leaf k b) bx2)
                                         (GHC.Internal.Types.I# 0#)
                                         (GHC.Internal.Types.I#
                                            (sizeofSmallArray# @Lifted @(Leaf k b) bx2))
                                   };
                                 BitmapIndexed bx1 bx2 [Occ=Once1] ->
                                   let {
                                     m :: Word#
                                     [LclId]
                                     m = uncheckedShiftL#
                                           1##
                                           (word2Int# (and# (uncheckedShiftRL# ipv ipv1) 31##)) } in
                                   case GHC.Internal.Classes.eqWord
                                          (GHC.Internal.Types.W# (and# bx1 m))
                                          (GHC.Internal.Types.W# 0##)
                                   of {
                                     False ->
                                       case indexSmallArray#
                                              @Lifted
                                              @(HashMap k b)
                                              bx2
                                              (word2Int# (popCnt# (and# bx1 (minusWord# m 1##))))
                                       of
                                       { (# ipv2 [Occ=Once1] #) ->
                                       jump lookupCont_
                                         $dEq ds7 ds8 (GHC.Internal.Types.I# (+# ipv1 5#)) ipv2
                                       };
                                     True -> GHC.Internal.Types.True
                                   };
                                 Full bx1 [Occ=Once1] ->
                                   case indexSmallArray#
                                          @Lifted
                                          @(HashMap k b)
                                          bx1
                                          (word2Int# (and# (uncheckedShiftRL# ipv ipv1) 31##))
                                   of
                                   { (# ipv2 [Occ=Once1] #) ->
                                   jump lookupCont_
                                     $dEq ds7 ds8 (GHC.Internal.Types.I# (+# ipv1 5#)) ipv2
                                   }
                               }
                               }
                               }
                               }; } in
                         jump lookupCont_
                           $dEq (GHC.Internal.Types.W# bx) k0 (GHC.Internal.Types.I# ww) wild2
                         };
                       Leaf bx1 [Occ=Once1] ds3 [Occ=Once1!] ->
                         case ds3 of { L kB [Occ=Once1] _ [Occ=Dead] ->
                         case GHC.Internal.Classes.neWord
                                (GHC.Internal.Types.W# bx) (GHC.Internal.Types.W# bx1)
                         of {
                           False -> /= @k $dEq kA kB;
                           True -> GHC.Internal.Types.True
                         }
                         }
                     }
                     };
                   Collision bx [Occ=Once3] bx1 [Occ=Once1] ->
                     case _b of {
                       __DEFAULT -> jump fail GHC.Internal.Types.(##);
                       Collision bx2 [Occ=Once1] bx3 [Occ=Once1] ->
                         T26615a.$wdisjointCollisions
                           @k @a @b $dEq bx (T26615a.Array @(Leaf k a) bx1) bx2 bx3;
                       BitmapIndexed bx2 bx3 [Occ=Once1] ->
                         let {
                           m :: Word#
                           [LclId]
                           m = uncheckedShiftL#
                                 1## (word2Int# (and# (uncheckedShiftRL# bx ww) 31##)) } in
                         case GHC.Internal.Classes.eqWord
                                (GHC.Internal.Types.W# (and# m bx2)) (GHC.Internal.Types.W# 0##)
                         of {
                           False ->
                             case indexSmallArray#
                                    @Lifted
                                    @(HashMap k b)
                                    bx3
                                    (word2Int# (popCnt# (and# bx2 (minusWord# m 1##))))
                             of
                             { (# ipv [Occ=Once1] #) ->
                             T26615a.$wdisjointSubtrees @k @a @b $dEq (+# ww 5#) wild ipv
                             };
                           True -> GHC.Internal.Types.True
                         };
                       Full bx2 [Occ=Once1] ->
                         case indexSmallArray#
                                @Lifted
                                @(HashMap k b)
                                bx2
                                (word2Int# (and# (uncheckedShiftRL# bx ww) 31##))
                         of
                         { (# ipv [Occ=Once1] #) ->
                         T26615a.$wdisjointSubtrees @k @a @b $dEq (+# ww 5#) wild ipv
                         }
                     };
                   BitmapIndexed bx bx1 ->
                     case _b of {
                       __DEFAULT -> jump fail GHC.Internal.Types.(##);
                       BitmapIndexed bx2 bx3 ->
                         case GHC.Internal.Classes.eqWord
                                (GHC.Internal.Types.W# (and# bx bx2)) (GHC.Internal.Types.W# 0##)
                         of {
                           False ->
                             case GHC.Internal.Unsafe.Coerce.unsafeEqualityProof
                                    @(*)
                                    @(SmallArray# (HashMap k a)
                                      -> SmallArray# (HashMap k b) -> Int#)
                                    @(GHC.Internal.Types.ZonkAny 0
                                      -> GHC.Internal.Types.ZonkAny 1 -> Int#)
                             of
                             { GHC.Internal.Unsafe.Coerce.UnsafeRefl v2 ->
                             case reallyUnsafePtrEquality#
                                    @Lifted
                                    @Lifted
                                    @(GHC.Internal.Types.ZonkAny 0)
                                    @(GHC.Internal.Types.ZonkAny 1)
                                    (bx1
                                     `cast` (SelCo:Fun(arg) (Sub (Sym v2))
                                             :: SmallArray# (HashMap k a)
                                                ~R# GHC.Internal.Types.ZonkAny 0))
                                    (bx3
                                     `cast` (SelCo:Fun(arg) (SelCo:Fun(res) (Sub (Sym v2)))
                                             :: SmallArray# (HashMap k b)
                                                ~R# GHC.Internal.Types.ZonkAny 1))
                             of {
                               __DEFAULT ->
                                 joinrec {
                                   go [Occ=LoopBreakerT[1]] :: Word -> Bool
                                   [LclId[JoinId(1)(Nothing)], Arity=1, Str=<L>, Unf=OtherCon []]
                                   go (ds1 [Occ=Once1!] :: Word)
                                     = case ds1 of { W# ds2 [Occ=Once1!] ->
                                       case ds2 of ds3 {
                                         __DEFAULT ->
                                           let {
                                             m :: Word#
                                             [LclId]
                                             m = and#
                                                   ds3 (int2Word# (negateInt# (word2Int# ds3))) } in
                                           case indexSmallArray#
                                                  @Lifted
                                                  @(HashMap k a)
                                                  bx1
                                                  (word2Int# (popCnt# (and# bx (minusWord# m 1##))))
                                           of
                                           { (# ipv [Occ=Once1] #) ->
                                           case indexSmallArray#
                                                  @Lifted
                                                  @(HashMap k b)
                                                  bx3
                                                  (word2Int#
                                                     (popCnt# (and# bx2 (minusWord# m 1##))))
                                           of
                                           { (# ipv1 [Occ=Once1] #) ->
                                           case T26615a.$wdisjointSubtrees
                                                  @k @a @b $dEq (+# ww 5#) ipv ipv1
                                           of {
                                             False -> GHC.Internal.Types.False;
                                             True ->
                                               jump go (GHC.Internal.Types.W# (and# ds3 (not# m)))
                                           }
                                           }
                                           };
                                         0## -> GHC.Internal.Types.True
                                       }
                                       }; } in
                                 jump go (GHC.Internal.Types.W# (and# bx bx2));
                               1# -> GHC.Internal.Types.False
                             }
                             };
                           True -> GHC.Internal.Types.True
                         };
                       Full bx2 [Occ=OnceL1] ->
                         joinrec {
                           go [Occ=LoopBreakerT[1]] :: Word -> Bool
                           [LclId[JoinId(1)(Nothing)], Arity=1, Str=<L>, Unf=OtherCon []]
                           go (ds1 [Occ=Once1!] :: Word)
                             = case ds1 of { W# ds2 [Occ=Once1!] ->
                               case ds2 of ds3 {
                                 __DEFAULT ->
                                   let {
                                     m :: Word#
                                     [LclId]
                                     m = and# ds3 (int2Word# (negateInt# (word2Int# ds3))) } in
                                   case indexSmallArray#
                                          @Lifted
                                          @(HashMap k a)
                                          bx1
                                          (word2Int# (popCnt# (and# bx (minusWord# m 1##))))
                                   of
                                   { (# ipv [Occ=Once1] #) ->
                                   case indexSmallArray#
                                          @Lifted
                                          @(HashMap k b)
                                          bx2
                                          (word2Int#
                                             (popCnt# (and# 4294967295## (minusWord# m 1##))))
                                   of
                                   { (# ipv1 [Occ=Once1] #) ->
                                   case T26615a.$wdisjointSubtrees @k @a @b $dEq (+# ww 5#) ipv ipv1
                                   of {
                                     False -> GHC.Internal.Types.False;
                                     True -> jump go (GHC.Internal.Types.W# (and# ds3 (not# m)))
                                   }
                                   }
                                   };
                                 0## -> GHC.Internal.Types.True
                               }
                               }; } in
                         jump go (GHC.Internal.Types.W# (and# bx 4294967295##))
                     };
                   Full bx ->
                     case _b of {
                       __DEFAULT -> jump fail GHC.Internal.Types.(##);
                       BitmapIndexed bx1 bx2 [Occ=OnceL1] ->
                         joinrec {
                           go [Occ=LoopBreakerT[1]] :: Word -> Bool
                           [LclId[JoinId(1)(Nothing)], Arity=1, Str=<L>, Unf=OtherCon []]
                           go (ds1 [Occ=Once1!] :: Word)
                             = case ds1 of { W# ds2 [Occ=Once1!] ->
                               case ds2 of ds3 {
                                 __DEFAULT ->
                                   let {
                                     m :: Word#
                                     [LclId]
                                     m = and# ds3 (int2Word# (negateInt# (word2Int# ds3))) } in
                                   case indexSmallArray#
                                          @Lifted
                                          @(HashMap k a)
                                          bx
                                          (word2Int#
                                             (popCnt# (and# 4294967295## (minusWord# m 1##))))
                                   of
                                   { (# ipv [Occ=Once1] #) ->
                                   case indexSmallArray#
                                          @Lifted
                                          @(HashMap k b)
                                          bx2
                                          (word2Int# (popCnt# (and# bx1 (minusWord# m 1##))))
                                   of
                                   { (# ipv1 [Occ=Once1] #) ->
                                   case T26615a.$wdisjointSubtrees @k @a @b $dEq (+# ww 5#) ipv ipv1
                                   of {
                                     False -> GHC.Internal.Types.False;
                                     True -> jump go (GHC.Internal.Types.W# (and# ds3 (not# m)))
                                   }
                                   }
                                   };
                                 0## -> GHC.Internal.Types.True
                               }
                               }; } in
                         jump go (GHC.Internal.Types.W# (and# 4294967295## bx1));
                       Full bx1 ->
                         case GHC.Internal.Unsafe.Coerce.unsafeEqualityProof
                                @(*)
                                @(SmallArray# (HashMap k a) -> SmallArray# (HashMap k b) -> Int#)
                                @(GHC.Internal.Types.ZonkAny 0
                                  -> GHC.Internal.Types.ZonkAny 1 -> Int#)
                         of
                         { GHC.Internal.Unsafe.Coerce.UnsafeRefl v2 ->
                         case reallyUnsafePtrEquality#
                                @Lifted
                                @Lifted
                                @(GHC.Internal.Types.ZonkAny 0)
                                @(GHC.Internal.Types.ZonkAny 1)
                                (bx
                                 `cast` (SelCo:Fun(arg) (Sub (Sym v2))
                                         :: SmallArray# (HashMap k a)
                                            ~R# GHC.Internal.Types.ZonkAny 0))
                                (bx1
                                 `cast` (SelCo:Fun(arg) (SelCo:Fun(res) (Sub (Sym v2)))
                                         :: SmallArray# (HashMap k b)
                                            ~R# GHC.Internal.Types.ZonkAny 1))
                         of {
                           __DEFAULT ->
                             joinrec {
                               go [Occ=LoopBreakerT[1]] :: Int -> Bool
                               [LclId[JoinId(1)(Nothing)], Arity=1, Str=<L>, Unf=OtherCon []]
                               go (i :: Int)
                                 = case GHC.Internal.Classes.ltInt i (GHC.Internal.Types.I# 0#) of {
                                     False ->
                                       case i of { I# i# ->
                                       case indexSmallArray# @Lifted @(HashMap k a) bx i# of
                                       { (# ipv [Occ=Once1] #) ->
                                       case indexSmallArray# @Lifted @(HashMap k b) bx1 i# of
                                       { (# ipv1 [Occ=Once1] #) ->
                                       case T26615a.$wdisjointSubtrees
                                              @k @a @b $dEq (+# ww 5#) ipv ipv1
                                       of {
                                         False -> GHC.Internal.Types.False;
                                         True -> jump go (GHC.Internal.Types.I# (-# i# 1#))
                                       }
                                       }
                                       }
                                       };
                                     True -> GHC.Internal.Types.True
                                   }; } in
                             jump go (GHC.Internal.Types.I# 31#);
                           1# -> GHC.Internal.Types.False
                         }
                         }
                     }
                 }}]
T26615a.$wdisjointSubtrees
  = \ (@k)
      (@a)
      (@b)
      ($dEq :: Eq k)
      (ww :: Int#)
      (ds :: HashMap k a)
      (_b :: HashMap k b) ->
      join {
        fail [Dmd=MC(1,L)] :: (# #) -> Bool
        [LclId[JoinId(1)(Nothing)], Arity=1, Str=<A>, Unf=OtherCon []]
        fail _ [Occ=Dead, OS=OneShot]
          = case _b of {
              __DEFAULT -> case lvl1 of {};
              Empty -> GHC.Internal.Types.True;
              Leaf bx ds2 ->
                case ds2 of { L kB ds3 ->
                case kB of k0 { __DEFAULT ->
                join {
                  exit [Dmd=LC(S,C(1,C(1,C(1,L))))]
                    :: Word# -> k -> Word# -> Leaf k a -> Bool
                  [LclId[JoinId(4)(Just [~, ~, ~, !])],
                   Arity=4,
                   Str=<L><L><L><1P(L,A)>]
                  exit (ww1 [OS=OneShot] :: Word#)
                       (ds4 [OS=OneShot] :: k)
                       (bx1 [OS=OneShot] :: Word#)
                       (ds5 [OS=OneShot] :: Leaf k a)
                    = case ds5 of { L kx x ->
                      case eqWord# ww1 bx1 of {
                        __DEFAULT -> GHC.Internal.Types.True;
                        1# ->
                          case == @k $dEq ds4 kx of {
                            False -> GHC.Internal.Types.True;
                            True -> GHC.Internal.Types.False
                          }
                      }
                      } } in
                join {
                  exit1 [Dmd=LC(S,C(1,C(1,C(1,L))))]
                    :: Word# -> k -> Word# -> SmallArray# (Leaf k a) -> Bool
                  [LclId[JoinId(4)(Nothing)], Arity=4, Str=<L><ML><L><L>]
                  exit1 (ww1 [OS=OneShot] :: Word#)
                        (ds4 [OS=OneShot] :: k)
                        (bx1 [OS=OneShot] :: Word#)
                        (bx2 [OS=OneShot] :: SmallArray# (Leaf k a))
                    = case eqWord# ww1 bx1 of {
                        __DEFAULT -> GHC.Internal.Types.True;
                        1# ->
                          joinrec {
                            $wlookupInArrayCont_ [InlPrag=[2],
                                                  Occ=LoopBreaker,
                                                  Dmd=SC(S,C(1,C(1,C(1,L))))]
                              :: k -> SmallArray# (Leaf k a) -> Int# -> Int# -> Bool
                            [LclId[JoinId(4)(Just [!])],
                             Arity=4,
                             Str=<1L><L><L><L>,
                             Unf=OtherCon []]
                            $wlookupInArrayCont_ (k1 :: k)
                                                 (ww2 :: SmallArray# (Leaf k a))
                                                 (ww3 :: Int#)
                                                 (ww4 :: Int#)
                              = case k1 of k2 { __DEFAULT ->
                                case >=# ww3 ww4 of {
                                  __DEFAULT ->
                                    case indexSmallArray# @Lifted @(Leaf k a) ww2 ww3 of
                                    { (# ipv #) ->
                                    case ipv of { L kx v ->
                                    case == @k $dEq k2 kx of {
                                      False -> jump $wlookupInArrayCont_ k2 ww2 (+# ww3 1#) ww4;
                                      True -> GHC.Internal.Types.False
                                    }
                                    }
                                    };
                                  1# -> GHC.Internal.Types.True
                                }
                                }; } in
                          jump $wlookupInArrayCont_
                            ds4 bx2 0# (sizeofSmallArray# @Lifted @(Leaf k a) bx2)
                      } } in
                joinrec {
                  $wlookupCont_ [InlPrag=[2],
                                 Occ=LoopBreaker,
                                 Dmd=SC(S,C(1,C(1,C(1,L))))]
                    :: Word# -> k -> Int# -> HashMap k a -> Bool
                  [LclId[JoinId(4)(Just [~, !, ~, !])],
                   Arity=4,
                   Str=<L><1L><L><1L>,
                   Unf=OtherCon []]
                  $wlookupCont_ (ww1 :: Word#)
                                (ds4 :: k)
                                (ww2 :: Int#)
                                (ds5 :: HashMap k a)
                    = case ds4 of ds6 { __DEFAULT ->
                      case ds5 of {
                        Empty -> GHC.Internal.Types.True;
                        Leaf bx1 ds7 -> jump exit ww1 ds6 bx1 ds7;
                        Collision bx1 bx2 -> jump exit1 ww1 ds6 bx1 bx2;
                        BitmapIndexed bx1 bx2 ->
                          let {
                            m :: Word#
                            [LclId]
                            m = uncheckedShiftL#
                                  1## (word2Int# (and# (uncheckedShiftRL# ww1 ww2) 31##)) } in
                          case and# bx1 m of {
                            __DEFAULT ->
                              case indexSmallArray#
                                     @Lifted
                                     @(HashMap k a)
                                     bx2
                                     (word2Int# (popCnt# (and# bx1 (minusWord# m 1##))))
                              of
                              { (# ipv #) ->
                              jump $wlookupCont_ ww1 ds6 (+# ww2 5#) ipv
                              };
                            0## -> GHC.Internal.Types.True
                          };
                        Full bx1 ->
                          case indexSmallArray#
                                 @Lifted
                                 @(HashMap k a)
                                 bx1
                                 (word2Int# (and# (uncheckedShiftRL# ww1 ww2) 31##))
                          of
                          { (# ipv #) ->
                          jump $wlookupCont_ ww1 ds6 (+# ww2 5#) ipv
                          }
                      }
                      }; } in
                jump $wlookupCont_ bx k0 ww ds
                }
                };
              Collision bx bx1 ->
                T26615a.disjointSubtrees_$s$wdisjointSubtrees
                  @a @b @k bx bx1 ww $dEq ds
            } } in
      case ds of {
        Empty -> GHC.Internal.Types.True;
        Leaf bx ds1 ->
          case ds1 of { L kA ds2 ->
          case _b of wild2 {
            __DEFAULT ->
              case kA of k0 { __DEFAULT ->
              join {
                exit [Dmd=LC(S,C(1,C(1,C(1,L))))]
                  :: Word# -> k -> Word# -> Leaf k b -> Bool
                [LclId[JoinId(4)(Just [~, ~, ~, !])],
                 Arity=4,
                 Str=<L><L><L><1P(L,A)>]
                exit (ww1 [OS=OneShot] :: Word#)
                     (ds3 [OS=OneShot] :: k)
                     (bx1 [OS=OneShot] :: Word#)
                     (ds4 [OS=OneShot] :: Leaf k b)
                  = case ds4 of { L kx x ->
                    case eqWord# ww1 bx1 of {
                      __DEFAULT -> GHC.Internal.Types.True;
                      1# ->
                        case == @k $dEq ds3 kx of {
                          False -> GHC.Internal.Types.True;
                          True -> GHC.Internal.Types.False
                        }
                    }
                    } } in
              join {
                exit1 [Dmd=LC(S,C(1,C(1,C(1,L))))]
                  :: Word# -> k -> Word# -> SmallArray# (Leaf k b) -> Bool
                [LclId[JoinId(4)(Nothing)], Arity=4, Str=<L><ML><L><L>]
                exit1 (ww1 [OS=OneShot] :: Word#)
                      (ds3 [OS=OneShot] :: k)
                      (bx1 [OS=OneShot] :: Word#)
                      (bx2 [OS=OneShot] :: SmallArray# (Leaf k b))
                  = case eqWord# ww1 bx1 of {
                      __DEFAULT -> GHC.Internal.Types.True;
                      1# ->
                        joinrec {
                          $wlookupInArrayCont_ [InlPrag=[2],
                                                Occ=LoopBreaker,
                                                Dmd=SC(S,C(1,C(1,C(1,L))))]
                            :: k -> SmallArray# (Leaf k b) -> Int# -> Int# -> Bool
                          [LclId[JoinId(4)(Just [!])],
                           Arity=4,
                           Str=<1L><L><L><L>,
                           Unf=OtherCon []]
                          $wlookupInArrayCont_ (k1 :: k)
                                               (ww2 :: SmallArray# (Leaf k b))
                                               (ww3 :: Int#)
                                               (ww4 :: Int#)
                            = case k1 of k2 { __DEFAULT ->
                              case >=# ww3 ww4 of {
                                __DEFAULT ->
                                  case indexSmallArray# @Lifted @(Leaf k b) ww2 ww3 of
                                  { (# ipv #) ->
                                  case ipv of { L kx v ->
                                  case == @k $dEq k2 kx of {
                                    False -> jump $wlookupInArrayCont_ k2 ww2 (+# ww3 1#) ww4;
                                    True -> GHC.Internal.Types.False
                                  }
                                  }
                                  };
                                1# -> GHC.Internal.Types.True
                              }
                              }; } in
                        jump $wlookupInArrayCont_
                          ds3 bx2 0# (sizeofSmallArray# @Lifted @(Leaf k b) bx2)
                    } } in
              joinrec {
                $wlookupCont_ [InlPrag=[2],
                               Occ=LoopBreaker,
                               Dmd=SC(S,C(1,C(1,C(1,L))))]
                  :: Word# -> k -> Int# -> HashMap k b -> Bool
                [LclId[JoinId(4)(Just [~, !, ~, !])],
                 Arity=4,
                 Str=<L><1L><L><1L>,
                 Unf=OtherCon []]
                $wlookupCont_ (ww1 :: Word#)
                              (ds3 :: k)
                              (ww2 :: Int#)
                              (ds4 :: HashMap k b)
                  = case ds3 of ds5 { __DEFAULT ->
                    case ds4 of {
                      Empty -> GHC.Internal.Types.True;
                      Leaf bx1 ds6 -> jump exit ww1 ds5 bx1 ds6;
                      Collision bx1 bx2 -> jump exit1 ww1 ds5 bx1 bx2;
                      BitmapIndexed bx1 bx2 ->
                        let {
                          m :: Word#
                          [LclId]
                          m = uncheckedShiftL#
                                1## (word2Int# (and# (uncheckedShiftRL# ww1 ww2) 31##)) } in
                        case and# bx1 m of {
                          __DEFAULT ->
                            case indexSmallArray#
                                   @Lifted
                                   @(HashMap k b)
                                   bx2
                                   (word2Int# (popCnt# (and# bx1 (minusWord# m 1##))))
                            of
                            { (# ipv #) ->
                            jump $wlookupCont_ ww1 ds5 (+# ww2 5#) ipv
                            };
                          0## -> GHC.Internal.Types.True
                        };
                      Full bx1 ->
                        case indexSmallArray#
                               @Lifted
                               @(HashMap k b)
                               bx1
                               (word2Int# (and# (uncheckedShiftRL# ww1 ww2) 31##))
                        of
                        { (# ipv #) ->
                        jump $wlookupCont_ ww1 ds5 (+# ww2 5#) ipv
                        }
                    }
                    }; } in
              jump $wlookupCont_ bx k0 ww wild2
              };
            Leaf bx1 ds3 ->
              case ds3 of { L kB ds4 ->
              case neWord# bx bx1 of {
                __DEFAULT -> /= @k $dEq kA kB;
                1# -> GHC.Internal.Types.True
              }
              }
          }
          };
        Collision bx bx1 ->
          case _b of {
            __DEFAULT -> jump fail GHC.Internal.Types.(##);
            Collision bx2 bx3 ->
              T26615a.$wdisjointCollisions
                @k @a @b $dEq bx (T26615a.Array @(Leaf k a) bx1) bx2 bx3;
            BitmapIndexed bx2 bx3 ->
              let {
                m :: Word#
                [LclId]
                m = uncheckedShiftL#
                      1## (word2Int# (and# (uncheckedShiftRL# bx ww) 31##)) } in
              case and# m bx2 of {
                __DEFAULT ->
                  case indexSmallArray#
                         @Lifted
                         @(HashMap k b)
                         bx3
                         (word2Int# (popCnt# (and# bx2 (minusWord# m 1##))))
                  of
                  { (# ipv #) ->
                  T26615a.disjointSubtrees_$s$wdisjointSubtrees
                    @b @a @k bx bx1 (+# ww 5#) $dEq ipv
                  };
                0## -> GHC.Internal.Types.True
              };
            Full bx2 ->
              case indexSmallArray#
                     @Lifted
                     @(HashMap k b)
                     bx2
                     (word2Int# (and# (uncheckedShiftRL# bx ww) 31##))
              of
              { (# ipv #) ->
              T26615a.disjointSubtrees_$s$wdisjointSubtrees
                @b @a @k bx bx1 (+# ww 5#) $dEq ipv
              }
          };
        BitmapIndexed bx bx1 ->
          case _b of {
            __DEFAULT -> jump fail GHC.Internal.Types.(##);
            BitmapIndexed bx2 bx3 ->
              case and# bx bx2 of wild2 {
                __DEFAULT ->
                  case GHC.Internal.Unsafe.Coerce.unsafeEqualityProof
                         @(*)
                         @(SmallArray# (HashMap k a) -> SmallArray# (HashMap k b) -> Int#)
                         @(GHC.Internal.Types.ZonkAny 0
                           -> GHC.Internal.Types.ZonkAny 1 -> Int#)
                  of
                  { GHC.Internal.Unsafe.Coerce.UnsafeRefl v2 ->
                  case reallyUnsafePtrEquality#
                         @Lifted
                         @Lifted
                         @(GHC.Internal.Types.ZonkAny 0)
                         @(GHC.Internal.Types.ZonkAny 1)
                         (bx1
                          `cast` (SelCo:Fun(arg) (Sub (Sym v2))
                                  :: SmallArray# (HashMap k a) ~R# GHC.Internal.Types.ZonkAny 0))
                         (bx3
                          `cast` (SelCo:Fun(arg) (SelCo:Fun(res) (Sub (Sym v2)))
                                  :: SmallArray# (HashMap k b) ~R# GHC.Internal.Types.ZonkAny 1))
                  of {
                    __DEFAULT ->
                      let {
                        lvl2 :: Int#
                        [LclId]
                        lvl2 = +# ww 5# } in
                      joinrec {
                        $wgo [InlPrag=[2], Occ=LoopBreaker, Dmd=SC(S,L)] :: Word# -> Bool
                        [LclId[JoinId(1)(Nothing)], Arity=1, Str=<1L>, Unf=OtherCon []]
                        $wgo (ww1 :: Word#)
                          = case ww1 of ds1 {
                              __DEFAULT ->
                                let {
                                  m :: Word#
                                  [LclId]
                                  m = and# ds1 (int2Word# (negateInt# (word2Int# ds1))) } in
                                case indexSmallArray#
                                       @Lifted
                                       @(HashMap k a)
                                       bx1
                                       (word2Int# (popCnt# (and# bx (minusWord# m 1##))))
                                of
                                { (# ipv #) ->
                                case indexSmallArray#
                                       @Lifted
                                       @(HashMap k b)
                                       bx3
                                       (word2Int# (popCnt# (and# bx2 (minusWord# m 1##))))
                                of
                                { (# ipv1 #) ->
                                case T26615a.$wdisjointSubtrees @k @a @b $dEq lvl2 ipv ipv1 of {
                                  False -> GHC.Internal.Types.False;
                                  True -> jump $wgo (and# ds1 (not# m))
                                }
                                }
                                };
                              0## -> GHC.Internal.Types.True
                            }; } in
                      jump $wgo wild2;
                    1# -> GHC.Internal.Types.False
                  }
                  };
                0## -> GHC.Internal.Types.True
              };
            Full bx2 ->
              let {
                lvl2 :: Int#
                [LclId]
                lvl2 = +# ww 5# } in
              joinrec {
                $wgo [InlPrag=[2], Occ=LoopBreaker, Dmd=SC(S,L)] :: Word# -> Bool
                [LclId[JoinId(1)(Nothing)], Arity=1, Str=<1L>, Unf=OtherCon []]
                $wgo (ww1 :: Word#)
                  = case ww1 of ds1 {
                      __DEFAULT ->
                        let {
                          m :: Word#
                          [LclId]
                          m = and# ds1 (int2Word# (negateInt# (word2Int# ds1))) } in
                        case indexSmallArray#
                               @Lifted
                               @(HashMap k a)
                               bx1
                               (word2Int# (popCnt# (and# bx (minusWord# m 1##))))
                        of
                        { (# ipv #) ->
                        case indexSmallArray#
                               @Lifted
                               @(HashMap k b)
                               bx2
                               (word2Int# (popCnt# (and# 4294967295## (minusWord# m 1##))))
                        of
                        { (# ipv1 #) ->
                        case T26615a.$wdisjointSubtrees @k @a @b $dEq lvl2 ipv ipv1 of {
                          False -> GHC.Internal.Types.False;
                          True -> jump $wgo (and# ds1 (not# m))
                        }
                        }
                        };
                      0## -> GHC.Internal.Types.True
                    }; } in
              jump $wgo (and# bx 4294967295##)
          };
        Full bx ->
          case _b of {
            __DEFAULT -> jump fail GHC.Internal.Types.(##);
            BitmapIndexed bx1 bx2 ->
              let {
                lvl2 :: Int#
                [LclId]
                lvl2 = +# ww 5# } in
              joinrec {
                $wgo [InlPrag=[2], Occ=LoopBreaker, Dmd=SC(S,L)] :: Word# -> Bool
                [LclId[JoinId(1)(Nothing)], Arity=1, Str=<1L>, Unf=OtherCon []]
                $wgo (ww1 :: Word#)
                  = case ww1 of ds1 {
                      __DEFAULT ->
                        let {
                          m :: Word#
                          [LclId]
                          m = and# ds1 (int2Word# (negateInt# (word2Int# ds1))) } in
                        case indexSmallArray#
                               @Lifted
                               @(HashMap k a)
                               bx
                               (word2Int# (popCnt# (and# 4294967295## (minusWord# m 1##))))
                        of
                        { (# ipv #) ->
                        case indexSmallArray#
                               @Lifted
                               @(HashMap k b)
                               bx2
                               (word2Int# (popCnt# (and# bx1 (minusWord# m 1##))))
                        of
                        { (# ipv1 #) ->
                        case T26615a.$wdisjointSubtrees @k @a @b $dEq lvl2 ipv ipv1 of {
                          False -> GHC.Internal.Types.False;
                          True -> jump $wgo (and# ds1 (not# m))
                        }
                        }
                        };
                      0## -> GHC.Internal.Types.True
                    }; } in
              jump $wgo (and# 4294967295## bx1);
            Full bx1 ->
              case GHC.Internal.Unsafe.Coerce.unsafeEqualityProof
                     @(*)
                     @(SmallArray# (HashMap k a) -> SmallArray# (HashMap k b) -> Int#)
                     @(GHC.Internal.Types.ZonkAny 0
                       -> GHC.Internal.Types.ZonkAny 1 -> Int#)
              of
              { GHC.Internal.Unsafe.Coerce.UnsafeRefl v2 ->
              case reallyUnsafePtrEquality#
                     @Lifted
                     @Lifted
                     @(GHC.Internal.Types.ZonkAny 0)
                     @(GHC.Internal.Types.ZonkAny 1)
                     (bx
                      `cast` (SelCo:Fun(arg) (Sub (Sym v2))
                              :: SmallArray# (HashMap k a) ~R# GHC.Internal.Types.ZonkAny 0))
                     (bx1
                      `cast` (SelCo:Fun(arg) (SelCo:Fun(res) (Sub (Sym v2)))
                              :: SmallArray# (HashMap k b) ~R# GHC.Internal.Types.ZonkAny 1))
              of {
                __DEFAULT ->
                  let {
                    lvl2 :: Int#
                    [LclId]
                    lvl2 = +# ww 5# } in
                  joinrec {
                    $wgo [InlPrag=[2], Occ=LoopBreaker, Dmd=SC(S,L)] :: Int# -> Bool
                    [LclId[JoinId(1)(Nothing)], Arity=1, Str=<L>, Unf=OtherCon []]
                    $wgo (ww1 :: Int#)
                      = case <# ww1 0# of {
                          __DEFAULT ->
                            case indexSmallArray# @Lifted @(HashMap k a) bx ww1 of
                            { (# ipv #) ->
                            case indexSmallArray# @Lifted @(HashMap k b) bx1 ww1 of
                            { (# ipv1 #) ->
                            case T26615a.$wdisjointSubtrees @k @a @b $dEq lvl2 ipv ipv1 of {
                              False -> GHC.Internal.Types.False;
                              True -> jump $wgo (-# ww1 1#)
                            }
                            }
                            };
                          1# -> GHC.Internal.Types.True
                        }; } in
                  jump $wgo 31#;
                1# -> GHC.Internal.Types.False
              }
              }
          }
      }
end Rec }

-- RHS size: {terms: 15, types: 17, coercions: 0, joins: 0/0}
disjointSubtrees [InlPrag=INLINABLE[2]]
  :: forall k a b. Eq k => Int -> HashMap k a -> HashMap k b -> Bool
[GblId,
 Arity=4,
 Str=<LP(LC(L,C(1,L)),LC(S,C(1,L)))><1!P(L)><SL><L>,
 Unf=Unf{Src=StableSystem, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@k)
                 (@a)
                 (@b)
                 ($dEq [Occ=Once1] :: Eq k)
                 (_s [Occ=Once1!] :: Int)
                 (ds [Occ=Once1] :: HashMap k a)
                 (_b [Occ=Once1] :: HashMap k b) ->
                 case _s of { I# ww [Occ=Once1] ->
                 T26615a.$wdisjointSubtrees @k @a @b $dEq ww ds _b
                 }}]
disjointSubtrees
  = \ (@k)
      (@a)
      (@b)
      ($dEq :: Eq k)
      (_s :: Int)
      (ds :: HashMap k a)
      (_b :: HashMap k b) ->
      case _s of { I# ww ->
      T26615a.$wdisjointSubtrees @k @a @b $dEq ww ds _b
      }


------ Local rules for imported ids --------
"SC:$wdisjointSubtrees1" [1]
    forall (@a)
           (@b)
           (@k)
           (sc :: Word#)
           (sc1 :: SmallArray# (Leaf k a))
           (sc2 :: Word#)
           (sc3 :: SmallArray# (Leaf k b))
           (sc4 :: Int#)
           (sc5 :: Eq k).
      T26615a.$wdisjointSubtrees @k
                                 @b
                                 @a
                                 sc5
                                 sc4
                                 (T26615a.Collision @k @b sc2 sc3)
                                 (T26615a.Collision @k @a sc sc1)
      = T26615a.$wdisjointCollisions
          @k @b @a sc5 sc2 (T26615a.Array @(Leaf k b) sc3) sc sc1
"SC:$wdisjointSubtrees0" [1]
    forall (@b)
           (@a)
           (@k)
           (sc :: Word#)
           (sc1 :: SmallArray# (Leaf k a))
           (sc2 :: Int#)
           (sc3 :: Eq k).
      T26615a.$wdisjointSubtrees @k
                                 @a
                                 @b
                                 sc3
                                 sc2
                                 (T26615a.Collision @k @a sc sc1)
      = T26615a.disjointSubtrees_$s$wdisjointSubtrees
          @b @a @k sc sc1 sc2 sc3


[2 of 2] Compiling T26615           ( T26615.hs, T26615.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 614, types: 666, coercions: 18, joins: 8/14}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T26615.$trModule2 :: GHC.Internal.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
T26615.$trModule2 = "T26615"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T26615.$trModule1 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615.$trModule1 = GHC.Internal.Types.TrNameS T26615.$trModule2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T26615.$trModule4 :: GHC.Internal.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 0}]
T26615.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T26615.$trModule3 :: GHC.Internal.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615.$trModule3 = GHC.Internal.Types.TrNameS T26615.$trModule4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T26615.$trModule :: GHC.Internal.Types.Module
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
T26615.$trModule
  = GHC.Internal.Types.Module T26615.$trModule3 T26615.$trModule1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: GHC.Internal.Prim.Addr#
[GblId, Unf=OtherCon []]
lvl = "T26615a.hs:(26,1)-(65,59)|function disjointSubtrees"#

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
lvl1 :: ()
[GblId, Str=b, Cpr=b]
lvl1
  = GHC.Internal.Control.Exception.Base.patError
      @GHC.Internal.Types.LiftedRep @() lvl

Rec {
-- RHS size: {terms: 37, types: 30, coercions: 0, joins: 0/0}
$wpoly_lookupInArrayCont_
  :: forall a.
     String
     -> GHC.Internal.Prim.SmallArray# (T26615a.Leaf String a)
     -> GHC.Internal.Prim.Int#
     -> GHC.Internal.Prim.Int#
     -> Bool
[GblId[StrictWorker([!])],
 Arity=4,
 Str=<1L><L><L><L>,
 Unf=OtherCon []]
$wpoly_lookupInArrayCont_
  = \ (@a)
      (k1 :: String)
      (ww :: GHC.Internal.Prim.SmallArray# (T26615a.Leaf String a))
      (ww1 :: GHC.Internal.Prim.Int#)
      (ww2 :: GHC.Internal.Prim.Int#) ->
      case k1 of k2 { __DEFAULT ->
      case GHC.Internal.Prim.>=# ww1 ww2 of {
        __DEFAULT ->
          case GHC.Internal.Prim.indexSmallArray#
                 @GHC.Internal.Types.Lifted @(T26615a.Leaf String a) ww ww1
          of
          { (# ipv5 #) ->
          case ipv5 of { T26615a.L kx v ->
          case GHC.Internal.Base.eqString k2 kx of {
            False ->
              $wpoly_lookupInArrayCont_
                @a k2 ww (GHC.Internal.Prim.+# ww1 1#) ww2;
            True -> GHC.Internal.Types.False
          }
          }
          };
        1# -> GHC.Internal.Types.True
      }
      }
end Rec }

Rec {
-- RHS size: {terms: 98, types: 73, coercions: 0, joins: 0/1}
$wpoly_lookupCont_
  :: forall a.
     GHC.Internal.Prim.Word#
     -> String -> GHC.Internal.Prim.Int# -> HashMap String a -> Bool
[GblId[StrictWorker([~, !, ~, !])],
 Arity=4,
 Str=<L><1L><L><1L>,
 Unf=OtherCon []]
$wpoly_lookupCont_
  = \ (@a)
      (ww :: GHC.Internal.Prim.Word#)
      (ds5 :: String)
      (ww1 :: GHC.Internal.Prim.Int#)
      (ds7 :: HashMap String a) ->
      case ds5 of ds9 { __DEFAULT ->
      case ds7 of {
        T26615a.Empty -> GHC.Internal.Types.True;
        T26615a.Leaf bx1 ds11 ->
          case ds11 of { T26615a.L kx x ->
          case GHC.Internal.Prim.eqWord# ww bx1 of {
            __DEFAULT -> GHC.Internal.Types.True;
            1# ->
              case GHC.Internal.Base.eqString ds9 kx of {
                False -> GHC.Internal.Types.True;
                True -> GHC.Internal.Types.False
              }
          }
          };
        T26615a.Collision bx1 bx2 ->
          case GHC.Internal.Prim.eqWord# ww bx1 of {
            __DEFAULT -> GHC.Internal.Types.True;
            1# ->
              $wpoly_lookupInArrayCont_
                @a
                ds9
                bx2
                0#
                (GHC.Internal.Prim.sizeofSmallArray#
                   @GHC.Internal.Types.Lifted @(T26615a.Leaf String a) bx2)
          };
        T26615a.BitmapIndexed bx1 bx2 ->
          let {
            m :: GHC.Internal.Prim.Word#
            [LclId]
            m = GHC.Internal.Prim.uncheckedShiftL#
                  1##
                  (GHC.Internal.Prim.word2Int#
                     (GHC.Internal.Prim.and#
                        (GHC.Internal.Prim.uncheckedShiftRL# ww ww1) 31##)) } in
          case GHC.Internal.Prim.and# bx1 m of {
            __DEFAULT ->
              case GHC.Internal.Prim.indexSmallArray#
                     @GHC.Internal.Types.Lifted
                     @(HashMap String a)
                     bx2
                     (GHC.Internal.Prim.word2Int#
                        (GHC.Internal.Prim.popCnt#
                           (GHC.Internal.Prim.and# bx1 (GHC.Internal.Prim.minusWord# m 1##))))
              of
              { (# ipv2 #) ->
              $wpoly_lookupCont_ @a ww ds9 (GHC.Internal.Prim.+# ww1 5#) ipv2
              };
            0## -> GHC.Internal.Types.True
          };
        T26615a.Full bx1 ->
          case GHC.Internal.Prim.indexSmallArray#
                 @GHC.Internal.Types.Lifted
                 @(HashMap String a)
                 bx1
                 (GHC.Internal.Prim.word2Int#
                    (GHC.Internal.Prim.and#
                       (GHC.Internal.Prim.uncheckedShiftRL# ww ww1) 31##))
          of
          { (# ipv2 #) ->
          $wpoly_lookupCont_ @a ww ds9 (GHC.Internal.Prim.+# ww1 5#) ipv2
          }
      }
      }
end Rec }

Rec {
-- RHS size: {terms: 448, types: 507, coercions: 18, joins: 8/13}
T26615.$s$wdisjointSubtrees [InlPrag=[~], Occ=LoopBreaker]
  :: forall a b.
     GHC.Internal.Prim.Int#
     -> HashMap String a -> HashMap String b -> Bool
[GblId, Arity=3, Str=<L><SL><L>, Unf=OtherCon []]
T26615.$s$wdisjointSubtrees
  = \ (@a)
      (@b)
      (ww :: GHC.Internal.Prim.Int#)
      (ds :: HashMap String a)
      (_b :: HashMap String b) ->
      join {
        fail [Dmd=MC(1,L)] :: (# #) -> Bool
        [LclId[JoinId(1)(Nothing)], Arity=1, Str=<A>, Unf=OtherCon []]
        fail _ [Occ=Dead, OS=OneShot]
          = case _b of wild {
              __DEFAULT -> case lvl1 of {};
              T26615a.Empty -> GHC.Internal.Types.True;
              T26615a.Leaf bx ds2 ->
                case ds2 of { T26615a.L kB ds3 ->
                $wpoly_lookupCont_ @a bx kB ww ds
                };
              T26615a.Collision bx bx1 ->
                T26615.$s$wdisjointSubtrees @b @a ww wild ds
            } } in
      case ds of wild {
        T26615a.Empty -> GHC.Internal.Types.True;
        T26615a.Leaf bx ds1 ->
          case ds1 of { T26615a.L kA ds2 ->
          case _b of wild2 {
            __DEFAULT -> $wpoly_lookupCont_ @b bx kA ww wild2;
            T26615a.Leaf bx1 ds3 ->
              case ds3 of { T26615a.L kB ds4 ->
              case GHC.Internal.Prim.neWord# bx bx1 of {
                __DEFAULT ->
                  case GHC.Internal.Classes.$fEqList_$s$c==1 kA kB of {
                    False -> GHC.Internal.Types.True;
                    True -> GHC.Internal.Types.False
                  };
                1# -> GHC.Internal.Types.True
              }
              }
          }
          };
        T26615a.Collision bx bx1 ->
          case _b of {
            __DEFAULT -> jump fail GHC.Internal.Types.(##);
            T26615a.Collision bx2 bx3 ->
              case GHC.Internal.Prim.eqWord# bx bx2 of {
                __DEFAULT -> GHC.Internal.Types.True;
                1# ->
                  let {
                    lvl2 :: GHC.Internal.Prim.Int#
                    [LclId]
                    lvl2
                      = GHC.Internal.Prim.sizeofSmallArray#
                          @GHC.Internal.Types.Lifted @(T26615a.Leaf String b) bx3 } in
                  joinrec {
                    $s$wfoldr_ [InlPrag=[2],
                                Occ=LoopBreaker,
                                Dmd=SC(S,C(1,C(1,C(1,L))))]
                      :: Bool
                         -> GHC.Internal.Prim.Int#
                         -> GHC.Internal.Prim.Int#
                         -> GHC.Internal.Prim.SmallArray# (T26615a.Leaf [Char] a)
                         -> Bool
                    [LclId[JoinId(4)(Nothing)],
                     Arity=4,
                     Str=<L><L><L><L>,
                     Unf=OtherCon []]
                    $s$wfoldr_ (sc :: Bool)
                               (sc1 :: GHC.Internal.Prim.Int#)
                               (sc2 :: GHC.Internal.Prim.Int#)
                               (sc3 :: GHC.Internal.Prim.SmallArray# (T26615a.Leaf [Char] a))
                      = case GHC.Internal.Prim.>=# sc1 sc2 of {
                          __DEFAULT ->
                            case GHC.Internal.Prim.indexSmallArray#
                                   @GHC.Internal.Types.Lifted @(T26615a.Leaf String a) sc3 sc1
                            of
                            { (# ipv1 #) ->
                            case ipv1 of { T26615a.L kA ds2 ->
                            join {
                              $j :: Bool
                              [LclId[JoinId(0)(Nothing)]]
                              $j = jump $s$wfoldr_ sc (GHC.Internal.Prim.+# sc1 1#) sc2 sc3 } in
                            joinrec {
                              $wlookupInArrayCont_ [InlPrag=[2],
                                                    Occ=LoopBreaker,
                                                    Dmd=SC(S,C(1,C(1,C(1,L))))]
                                :: String
                                   -> GHC.Internal.Prim.SmallArray# (T26615a.Leaf String b)
                                   -> GHC.Internal.Prim.Int#
                                   -> GHC.Internal.Prim.Int#
                                   -> Bool
                              [LclId[JoinId(4)(Just [!])],
                               Arity=4,
                               Str=<1L><L><L><L>,
                               Unf=OtherCon []]
                              $wlookupInArrayCont_ (k1 :: String)
                                                   (ww1
                                                      :: GHC.Internal.Prim.SmallArray#
                                                           (T26615a.Leaf String b))
                                                   (ww2 :: GHC.Internal.Prim.Int#)
                                                   (ww3 :: GHC.Internal.Prim.Int#)
                                = case k1 of k2 { __DEFAULT ->
                                  case GHC.Internal.Prim.>=# ww2 ww3 of {
                                    __DEFAULT ->
                                      case GHC.Internal.Prim.indexSmallArray#
                                             @GHC.Internal.Types.Lifted
                                             @(T26615a.Leaf String b)
                                             ww1
                                             ww2
                                      of
                                      { (# ipv5 #) ->
                                      case ipv5 of { T26615a.L kx v ->
                                      case GHC.Internal.Base.eqString k2 kx of {
                                        False ->
                                          jump $wlookupInArrayCont_
                                            k2 ww1 (GHC.Internal.Prim.+# ww2 1#) ww3;
                                        True -> GHC.Internal.Types.False
                                      }
                                      }
                                      };
                                    1# -> jump $j
                                  }
                                  }; } in
                            jump $wlookupInArrayCont_ kA bx3 0# lvl2
                            }
                            };
                          1# -> sc
                        }; } in
                  jump $s$wfoldr_
                    GHC.Internal.Types.True
                    0#
                    (GHC.Internal.Prim.sizeofSmallArray#
                       @GHC.Internal.Types.Lifted @(T26615a.Leaf String a) bx1)
                    bx1
              };
            T26615a.BitmapIndexed bx2 bx3 ->
              let {
                m :: GHC.Internal.Prim.Word#
                [LclId]
                m = GHC.Internal.Prim.uncheckedShiftL#
                      1##
                      (GHC.Internal.Prim.word2Int#
                         (GHC.Internal.Prim.and#
                            (GHC.Internal.Prim.uncheckedShiftRL# bx ww) 31##)) } in
              case GHC.Internal.Prim.and# m bx2 of {
                __DEFAULT ->
                  case GHC.Internal.Prim.indexSmallArray#
                         @GHC.Internal.Types.Lifted
                         @(HashMap String b)
                         bx3
                         (GHC.Internal.Prim.word2Int#
                            (GHC.Internal.Prim.popCnt#
                               (GHC.Internal.Prim.and# bx2 (GHC.Internal.Prim.minusWord# m 1##))))
                  of
                  { (# ipv #) ->
                  T26615.$s$wdisjointSubtrees
                    @a @b (GHC.Internal.Prim.+# ww 5#) wild ipv
                  };
                0## -> GHC.Internal.Types.True
              };
            T26615a.Full bx2 ->
              case GHC.Internal.Prim.indexSmallArray#
                     @GHC.Internal.Types.Lifted
                     @(HashMap String b)
                     bx2
                     (GHC.Internal.Prim.word2Int#
                        (GHC.Internal.Prim.and#
                           (GHC.Internal.Prim.uncheckedShiftRL# bx ww) 31##))
              of
              { (# ipv #) ->
              T26615.$s$wdisjointSubtrees
                @a @b (GHC.Internal.Prim.+# ww 5#) wild ipv
              }
          };
        T26615a.BitmapIndexed bx bx1 ->
          case _b of {
            __DEFAULT -> jump fail GHC.Internal.Types.(##);
            T26615a.BitmapIndexed bx2 bx3 ->
              case GHC.Internal.Prim.and# bx bx2 of wild2 {
                __DEFAULT ->
                  case GHC.Internal.Unsafe.Coerce.unsafeEqualityProof
                         @(*)
                         @(GHC.Internal.Prim.SmallArray# (HashMap String a)
                           -> GHC.Internal.Prim.SmallArray# (HashMap String b)
                           -> GHC.Internal.Prim.Int#)
                         @(GHC.Internal.Types.ZonkAny 0
                           -> GHC.Internal.Types.ZonkAny 1 -> GHC.Internal.Prim.Int#)
                  of
                  { GHC.Internal.Unsafe.Coerce.UnsafeRefl v2 ->
                  case GHC.Internal.Prim.reallyUnsafePtrEquality#
                         @GHC.Internal.Types.Lifted
                         @GHC.Internal.Types.Lifted
                         @(GHC.Internal.Types.ZonkAny 0)
                         @(GHC.Internal.Types.ZonkAny 1)
                         (bx1
                          `cast` (SelCo:Fun(arg) (Sub (Sym v2))
                                  :: GHC.Internal.Prim.SmallArray# (HashMap String a)
                                     ~R# GHC.Internal.Types.ZonkAny 0))
                         (bx3
                          `cast` (SelCo:Fun(arg) (SelCo:Fun(res) (Sub (Sym v2)))
                                  :: GHC.Internal.Prim.SmallArray# (HashMap String b)
                                     ~R# GHC.Internal.Types.ZonkAny 1))
                  of {
                    __DEFAULT ->
                      joinrec {
                        $wgo [InlPrag=[2], Occ=LoopBreaker, Dmd=SC(S,L)]
                          :: GHC.Internal.Prim.Word# -> Bool
                        [LclId[JoinId(1)(Nothing)], Arity=1, Str=<1L>, Unf=OtherCon []]
                        $wgo (ww1 :: GHC.Internal.Prim.Word#)
                          = case ww1 of ds3 {
                              __DEFAULT ->
                                let {
                                  m :: GHC.Internal.Prim.Word#
                                  [LclId]
                                  m = GHC.Internal.Prim.and#
                                        ds3
                                        (GHC.Internal.Prim.int2Word#
                                           (GHC.Internal.Prim.negateInt#
                                              (GHC.Internal.Prim.word2Int# ds3))) } in
                                case GHC.Internal.Prim.indexSmallArray#
                                       @GHC.Internal.Types.Lifted
                                       @(HashMap String a)
                                       bx1
                                       (GHC.Internal.Prim.word2Int#
                                          (GHC.Internal.Prim.popCnt#
                                             (GHC.Internal.Prim.and#
                                                bx (GHC.Internal.Prim.minusWord# m 1##))))
                                of
                                { (# ipv #) ->
                                case GHC.Internal.Prim.indexSmallArray#
                                       @GHC.Internal.Types.Lifted
                                       @(HashMap String b)
                                       bx3
                                       (GHC.Internal.Prim.word2Int#
                                          (GHC.Internal.Prim.popCnt#
                                             (GHC.Internal.Prim.and#
                                                bx2 (GHC.Internal.Prim.minusWord# m 1##))))
                                of
                                { (# ipv1 #) ->
                                case T26615.$s$wdisjointSubtrees
                                       @a @b (GHC.Internal.Prim.+# ww 5#) ipv ipv1
                                of {
                                  False -> GHC.Internal.Types.False;
                                  True ->
                                    jump $wgo
                                      (GHC.Internal.Prim.and# ds3 (GHC.Internal.Prim.not# m))
                                }
                                }
                                };
                              0## -> GHC.Internal.Types.True
                            }; } in
                      jump $wgo wild2;
                    1# -> GHC.Internal.Types.False
                  }
                  };
                0## -> GHC.Internal.Types.True
              };
            T26615a.Full bx2 ->
              joinrec {
                $wgo [InlPrag=[2], Occ=LoopBreaker, Dmd=SC(S,L)]
                  :: GHC.Internal.Prim.Word# -> Bool
                [LclId[JoinId(1)(Nothing)], Arity=1, Str=<1L>, Unf=OtherCon []]
                $wgo (ww1 :: GHC.Internal.Prim.Word#)
                  = case ww1 of ds3 {
                      __DEFAULT ->
                        let {
                          m :: GHC.Internal.Prim.Word#
                          [LclId]
                          m = GHC.Internal.Prim.and#
                                ds3
                                (GHC.Internal.Prim.int2Word#
                                   (GHC.Internal.Prim.negateInt#
                                      (GHC.Internal.Prim.word2Int# ds3))) } in
                        case GHC.Internal.Prim.indexSmallArray#
                               @GHC.Internal.Types.Lifted
                               @(HashMap String a)
                               bx1
                               (GHC.Internal.Prim.word2Int#
                                  (GHC.Internal.Prim.popCnt#
                                     (GHC.Internal.Prim.and#
                                        bx (GHC.Internal.Prim.minusWord# m 1##))))
                        of
                        { (# ipv #) ->
                        case GHC.Internal.Prim.indexSmallArray#
                               @GHC.Internal.Types.Lifted
                               @(HashMap String b)
                               bx2
                               (GHC.Internal.Prim.word2Int#
                                  (GHC.Internal.Prim.popCnt#
                                     (GHC.Internal.Prim.and#
                                        4294967295## (GHC.Internal.Prim.minusWord# m 1##))))
                        of
                        { (# ipv1 #) ->
                        case T26615.$s$wdisjointSubtrees
                               @a @b (GHC.Internal.Prim.+# ww 5#) ipv ipv1
                        of {
                          False -> GHC.Internal.Types.False;
                          True ->
                            jump $wgo (GHC.Internal.Prim.and# ds3 (GHC.Internal.Prim.not# m))
                        }
                        }
                        };
                      0## -> GHC.Internal.Types.True
                    }; } in
              jump $wgo (GHC.Internal.Prim.and# bx 4294967295##)
          };
        T26615a.Full bx ->
          case _b of {
            __DEFAULT -> jump fail GHC.Internal.Types.(##);
            T26615a.BitmapIndexed bx1 bx2 ->
              joinrec {
                $wgo [InlPrag=[2], Occ=LoopBreaker, Dmd=SC(S,L)]
                  :: GHC.Internal.Prim.Word# -> Bool
                [LclId[JoinId(1)(Nothing)], Arity=1, Str=<1L>, Unf=OtherCon []]
                $wgo (ww1 :: GHC.Internal.Prim.Word#)
                  = case ww1 of ds3 {
                      __DEFAULT ->
                        let {
                          m :: GHC.Internal.Prim.Word#
                          [LclId]
                          m = GHC.Internal.Prim.and#
                                ds3
                                (GHC.Internal.Prim.int2Word#
                                   (GHC.Internal.Prim.negateInt#
                                      (GHC.Internal.Prim.word2Int# ds3))) } in
                        case GHC.Internal.Prim.indexSmallArray#
                               @GHC.Internal.Types.Lifted
                               @(HashMap String a)
                               bx
                               (GHC.Internal.Prim.word2Int#
                                  (GHC.Internal.Prim.popCnt#
                                     (GHC.Internal.Prim.and#
                                        4294967295## (GHC.Internal.Prim.minusWord# m 1##))))
                        of
                        { (# ipv #) ->
                        case GHC.Internal.Prim.indexSmallArray#
                               @GHC.Internal.Types.Lifted
                               @(HashMap String b)
                               bx2
                               (GHC.Internal.Prim.word2Int#
                                  (GHC.Internal.Prim.popCnt#
                                     (GHC.Internal.Prim.and#
                                        bx1 (GHC.Internal.Prim.minusWord# m 1##))))
                        of
                        { (# ipv1 #) ->
                        case T26615.$s$wdisjointSubtrees
                               @a @b (GHC.Internal.Prim.+# ww 5#) ipv ipv1
                        of {
                          False -> GHC.Internal.Types.False;
                          True ->
                            jump $wgo (GHC.Internal.Prim.and# ds3 (GHC.Internal.Prim.not# m))
                        }
                        }
                        };
                      0## -> GHC.Internal.Types.True
                    }; } in
              jump $wgo (GHC.Internal.Prim.and# 4294967295## bx1);
            T26615a.Full bx1 ->
              case GHC.Internal.Unsafe.Coerce.unsafeEqualityProof
                     @(*)
                     @(GHC.Internal.Prim.SmallArray# (HashMap String a)
                       -> GHC.Internal.Prim.SmallArray# (HashMap String b)
                       -> GHC.Internal.Prim.Int#)
                     @(GHC.Internal.Types.ZonkAny 0
                       -> GHC.Internal.Types.ZonkAny 1 -> GHC.Internal.Prim.Int#)
              of
              { GHC.Internal.Unsafe.Coerce.UnsafeRefl v2 ->
              case GHC.Internal.Prim.reallyUnsafePtrEquality#
                     @GHC.Internal.Types.Lifted
                     @GHC.Internal.Types.Lifted
                     @(GHC.Internal.Types.ZonkAny 0)
                     @(GHC.Internal.Types.ZonkAny 1)
                     (bx
                      `cast` (SelCo:Fun(arg) (Sub (Sym v2))
                              :: GHC.Internal.Prim.SmallArray# (HashMap String a)
                                 ~R# GHC.Internal.Types.ZonkAny 0))
                     (bx1
                      `cast` (SelCo:Fun(arg) (SelCo:Fun(res) (Sub (Sym v2)))
                              :: GHC.Internal.Prim.SmallArray# (HashMap String b)
                                 ~R# GHC.Internal.Types.ZonkAny 1))
              of {
                __DEFAULT ->
                  joinrec {
                    $wgo [InlPrag=[2], Occ=LoopBreaker, Dmd=SC(S,L)]
                      :: GHC.Internal.Prim.Int# -> Bool
                    [LclId[JoinId(1)(Nothing)], Arity=1, Str=<L>, Unf=OtherCon []]
                    $wgo (ww1 :: GHC.Internal.Prim.Int#)
                      = case GHC.Internal.Prim.<# ww1 0# of {
                          __DEFAULT ->
                            case GHC.Internal.Prim.indexSmallArray#
                                   @GHC.Internal.Types.Lifted @(HashMap String a) bx ww1
                            of
                            { (# ipv #) ->
                            case GHC.Internal.Prim.indexSmallArray#
                                   @GHC.Internal.Types.Lifted @(HashMap String b) bx1 ww1
                            of
                            { (# ipv1 #) ->
                            case T26615.$s$wdisjointSubtrees
                                   @a @b (GHC.Internal.Prim.+# ww 5#) ipv ipv1
                            of {
                              False -> GHC.Internal.Types.False;
                              True -> jump $wgo (GHC.Internal.Prim.-# ww1 1#)
                            }
                            }
                            };
                          1# -> GHC.Internal.Types.True
                        }; } in
                  jump $wgo 31#;
                1# -> GHC.Internal.Types.False
              }
              }
          }
      }
end Rec }

-- RHS size: {terms: 8, types: 10, coercions: 0, joins: 0/0}
f :: forall a b. HashMap String a -> HashMap String b -> Bool
[GblId,
 Arity=2,
 Str=<SL><L>,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 40 0}]
f = \ (@a)
      (@b)
      (ds :: HashMap String a)
      (_b :: HashMap String b) ->
      T26615.$s$wdisjointSubtrees @a @b 0# ds _b


------ Local rules for imported ids --------
"SPEC/T26615 $wdisjointSubtrees @String @_ @_" [2]
    forall (@a) (@b) ($dEq :: Eq String).
      T26615a.$wdisjointSubtrees @String @a @b $dEq
      = T26615.$s$wdisjointSubtrees @a @b


