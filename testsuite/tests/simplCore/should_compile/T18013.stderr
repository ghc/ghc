Rule fired: Class op arr (BUILTIN)
Rule fired: Class op $p1Arrow (BUILTIN)
Rule fired: Class op $p1Arrow (BUILTIN)
Rule fired: Class op $p1Arrow (BUILTIN)
Rule fired: Class op $p1Arrow (BUILTIN)
Rule fired: Class op $p1Arrow (BUILTIN)
Rule fired: Class op $p1Arrow (BUILTIN)
Rule fired: Class op $p1Arrow (BUILTIN)
Rule fired: Class op id (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op . (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op $p1Applicative (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op . (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op $p1Applicative (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op $p1Arrow (BUILTIN)
Rule fired: Class op $p1Arrow (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op $p1Arrow (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op . (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op $p1Applicative (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op first (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op . (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op $p1Applicative (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op . (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op $p1Applicative (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op . (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op $p1Applicative (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op . (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op $p1Applicative (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op $p1Arrow (BUILTIN)
Rule fired: Class op $p1Arrow (BUILTIN)
Rule fired: Class op id (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op . (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op $p1Applicative (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op ||| (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op $p1Applicative (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op . (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op $p1Applicative (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: Class op . (BUILTIN)
Rule fired: Class op $p1Monad (BUILTIN)
Rule fired: Class op $p1Applicative (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op >>= (BUILTIN)
Rule fired: Class op pure (BUILTIN)
Rule fired: mkRule @((), _) (T18013a)
Rule fired: Class op fmap (BUILTIN)
Rule fired: mkRule @((), _) (T18013a)
Rule fired: Class op fmap (BUILTIN)
Rule fired: mkRule @((), _) (T18013a)
Rule fired: Class op fmap (BUILTIN)
Rule fired: mkRule @(_, ()) (T18013a)
Rule fired: Class op fmap (BUILTIN)
Rule fired: mkRule @((), _) (T18013a)
Rule fired: Class op fmap (BUILTIN)
Rule fired: mkRule @((), _) (T18013a)
Rule fired: Class op fmap (BUILTIN)
Rule fired: mkRule @((), _) (T18013a)
Rule fired: Class op fmap (BUILTIN)
Rule fired: mkRule @((), _) (T18013a)
Rule fired: Class op fmap (BUILTIN)
Rule fired: mkRule @((), _) (T18013a)
Rule fired: Class op fmap (BUILTIN)
Rule fired: mkRule @(_, ()) (T18013a)
Rule fired: Class op fmap (BUILTIN)
Rule fired: mkRule @(_, ()) (T18013a)
Rule fired: Class op fmap (BUILTIN)

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 52, types: 95, coercions: 17, joins: 0/1}

-- RHS size: {terms: 37, types: 78, coercions: 17, joins: 0/1}
mapMaybeRule [InlPrag=[2]]
  :: forall a b. Rule IO a b -> Rule IO (Maybe a) (Maybe b)
[GblId,
 Arity=1,
 Str=<1!P(L,LCL(C1(C1(P(L,1L)))))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@a) (@b) (f [Occ=Once1!] :: Rule IO a b) ->
                 case f of { Rule @s ww ww1 [Occ=OnceL1!] ->
                 T18013a.Rule
                   @IO
                   @(Maybe a)
                   @(Maybe b)
                   @s
                   ww
                   ((\ (s2 [Occ=Once1] :: s)
                       (a1 [Occ=Once1!] :: Maybe a)
                       (s1 [Occ=Once2] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                       case a1 of {
                         Nothing ->
                           (# s1, T18013a.Result @s @(Maybe b) ww (GHC.Maybe.Nothing @b) #);
                         Just x [Occ=Once1] ->
                           case ((ww1 s2 x)
                                 `cast` <Co:4> :: IO (Result s b)
                                                  ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                                                       -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             Result s b #)))
                                  s1
                           of
                           { (# ipv [Occ=Once1], ipv1 [Occ=Once1!] #) ->
                           case ipv1 of { Result t2 [Occ=Once1] c1 [Occ=Once1] ->
                           (# ipv, T18013a.Result @s @(Maybe b) t2 (GHC.Maybe.Just @b c1) #)
                           }
                           }
                       })
                    `cast` <Co:13> :: (s
                                       -> Maybe a
                                       -> GHC.Prim.State# GHC.Prim.RealWorld
                                       -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                             Result s (Maybe b) #))
                                      ~R# (s -> Maybe a -> IO (Result s (Maybe b))))
                 }}]
mapMaybeRule
  = \ (@a) (@b) (f :: Rule IO a b) ->
      case f of { Rule @s ww ww1 ->
      let {
        lvl :: Result s (Maybe b)
        [LclId]
        lvl = T18013a.Result @s @(Maybe b) ww (GHC.Maybe.Nothing @b) } in
      T18013a.Rule
        @IO
        @(Maybe a)
        @(Maybe b)
        @s
        ww
        ((\ (s2 :: s)
            (a1 :: Maybe a)
            (s1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
            case a1 of {
              Nothing -> (# s1, lvl #);
              Just x ->
                case ((ww1 s2 x)
                      `cast` <Co:4> :: IO (Result s b)
                                       ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                                            -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                  Result s b #)))
                       s1
                of
                { (# ipv, ipv1 #) ->
                case ipv1 of { Result t2 c1 ->
                (# ipv, T18013a.Result @s @(Maybe b) t2 (GHC.Maybe.Just @b c1) #)
                }
                }
            })
         `cast` <Co:13> :: (s
                            -> Maybe a
                            -> GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, Result s (Maybe b) #))
                           ~R# (s -> Maybe a -> IO (Result s (Maybe b))))
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T18013.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
T18013.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T18013.$trModule3 :: GHC.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18013.$trModule3 = GHC.Types.TrNameS T18013.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T18013.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
T18013.$trModule2 = "T18013"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T18013.$trModule1 :: GHC.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18013.$trModule1 = GHC.Types.TrNameS T18013.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18013.$trModule :: GHC.Types.Module
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18013.$trModule
  = GHC.Types.Module T18013.$trModule3 T18013.$trModule1



