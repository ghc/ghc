
abstract_refinement_hole_fits.hs:4:5: warning: [-Wtyped-holes (in -Wdefault)]
    • Found hole: _ :: [Integer] -> Integer
    • In the expression: _
      In an equation for ‘f’: f = _
    • Relevant bindings include
        f :: [Integer] -> Integer
          (bound at abstract_refinement_hole_fits.hs:4:1)
      Valid hole fits include
        f :: [Integer] -> Integer
        g :: [Integer] -> Integer
        head :: forall a. [a] -> a
        last :: forall a. [a] -> a
        maximum :: forall (t :: * -> *) a. (Foldable t, Ord a) => t a -> a
        minimum :: forall (t :: * -> *) a. (Foldable t, Ord a) => t a -> a
        product :: forall (t :: * -> *) a. (Foldable t, Num a) => t a -> a
        sum :: forall (t :: * -> *) a. (Foldable t, Num a) => t a -> a
      Valid refinement hole fits include
        foldl1 (_ :: Integer -> Integer -> Integer)
          where foldl1 :: forall (t :: * -> *) a.
                          Foldable t =>
                          (a -> a -> a) -> t a -> a
        foldr1 (_ :: Integer -> Integer -> Integer)
          where foldr1 :: forall (t :: * -> *) a.
                          Foldable t =>
                          (a -> a -> a) -> t a -> a
        foldl (_ :: Integer -> Integer -> Integer) (_ :: Integer)
          where foldl :: forall (t :: * -> *) b a.
                         Foldable t =>
                         (b -> a -> b) -> b -> t a -> b
        foldr (_ :: Integer -> Integer -> Integer) (_ :: Integer)
          where foldr :: forall (t :: * -> *) a b.
                         Foldable t =>
                         (a -> b -> b) -> b -> t a -> b
        const (_ :: Integer)
          where const :: forall a b. a -> b -> a
        ($) (_ :: [Integer] -> Integer)
          where ($) :: forall a b. (a -> b) -> a -> b
        return (_ :: Integer)
          where return :: forall (m :: * -> *) a. Monad m => a -> m a
        pure (_ :: Integer)
          where pure :: forall (f :: * -> *) a. Applicative f => a -> f a
        ($!) (_ :: [Integer] -> Integer)
          where ($!) :: forall a b. (a -> b) -> a -> b
        curry (_ :: (t0, [Integer]) -> Integer) (_ :: t0)
          where curry :: forall a b c. ((a, b) -> c) -> a -> b -> c
        (.) (_ :: b1 -> Integer) (_ :: [Integer] -> b1)
          where (.) :: forall b c a. (b -> c) -> (a -> b) -> a -> c
        flip (_ :: [Integer] -> t0 -> Integer) (_ :: t0)
          where flip :: forall a b c. (a -> b -> c) -> b -> a -> c
        (>>=) (_ :: [Integer] -> a8) (_ :: a8 -> [Integer] -> Integer)
          where (>>=) :: forall (m :: * -> *) a b.
                         Monad m =>
                         m a -> (a -> m b) -> m b
        (>>) (_ :: [Integer] -> a7) (_ :: [Integer] -> Integer)
          where (>>) :: forall (m :: * -> *) a b.
                        Monad m =>
                        m a -> m b -> m b
        fmap (_ :: a9 -> Integer) (_ :: [Integer] -> a9)
          where fmap :: forall (f :: * -> *) a b.
                        Functor f =>
                        (a -> b) -> f a -> f b
        (<*>) (_ :: [Integer] -> a5 -> Integer) (_ :: [Integer] -> a5)
          where (<*>) :: forall (f :: * -> *) a b.
                         Applicative f =>
                         f (a -> b) -> f a -> f b
        (*>) (_ :: [Integer] -> a4) (_ :: [Integer] -> Integer)
          where (*>) :: forall (f :: * -> *) a b.
                        Applicative f =>
                        f a -> f b -> f b
        (<$>) (_ :: a1 -> Integer) (_ :: [Integer] -> a1)
          where (<$>) :: forall (f :: * -> *) a b.
                         Functor f =>
                         (a -> b) -> f a -> f b
        (=<<) (_ :: a6 -> [Integer] -> Integer) (_ :: [Integer] -> a6)
          where (=<<) :: forall (m :: * -> *) a b.
                         Monad m =>
                         (a -> m b) -> m a -> m b
        (<*) (_ :: [Integer] -> Integer) (_ :: [Integer] -> b5)
          where (<*) :: forall (f :: * -> *) a b.
                        Applicative f =>
                        f a -> f b -> f a
        (<$) (_ :: Integer) (_ :: [Integer] -> b4)
          where (<$) :: forall (f :: * -> *) a b.
                        Functor f =>
                        a -> f b -> f a
        id (_ :: t0 -> [Integer] -> Integer) (_ :: t0)
          where id :: forall a. a -> a
        head (_ :: [t0 -> [Integer] -> Integer]) (_ :: t0)
          where head :: forall a. [a] -> a
        last (_ :: [t0 -> [Integer] -> Integer]) (_ :: t0)
          where last :: forall a. [a] -> a
        fst (_ :: (t0 -> [Integer] -> Integer, b2)) (_ :: t0)
          where fst :: forall a b. (a, b) -> a
        snd (_ :: (a2, t0 -> [Integer] -> Integer)) (_ :: t0)
          where snd :: forall a b. (a, b) -> b
        id (_ :: [Integer] -> Integer)
          where id :: forall a. a -> a
        head (_ :: [[Integer] -> Integer])
          where head :: forall a. [a] -> a
        last (_ :: [[Integer] -> Integer])
          where last :: forall a. [a] -> a
        asTypeOf (_ :: [Integer] -> Integer) (_ :: [Integer] -> Integer)
          where asTypeOf :: forall a. a -> a -> a
        (!!) (_ :: [[Integer] -> Integer]) (_ :: Int)
          where (!!) :: forall a. [a] -> Int -> a
        fst (_ :: ([Integer] -> Integer, b0))
          where fst :: forall a b. (a, b) -> a
        snd (_ :: (a0, [Integer] -> Integer))
          where snd :: forall a b. (a, b) -> b
        const (_ :: [Integer] -> Integer) (_ :: t0)
          where const :: forall a b. a -> b -> a
        seq (_ :: t2) (_ :: [Integer] -> Integer)
          where seq :: forall a b. a -> b -> b
        ($) (_ :: t0 -> [Integer] -> Integer) (_ :: t0)
          where ($) :: forall a b. (a -> b) -> a -> b
        return (_ :: [Integer] -> Integer) (_ :: t0)
          where return :: forall (m :: * -> *) a. Monad m => a -> m a
        pure (_ :: [Integer] -> Integer) (_ :: t0)
          where pure :: forall (f :: * -> *) a. Applicative f => a -> f a
        uncurry (_ :: a3 -> b3 -> [Integer] -> Integer) (_ :: (a3, b3))
          where uncurry :: forall a b c. (a -> b -> c) -> (a, b) -> c
        ($!) (_ :: t0 -> [Integer] -> Integer) (_ :: t0)
          where ($!) :: forall a b. (a -> b) -> a -> b

abstract_refinement_hole_fits.hs:7:5: warning: [-Wtyped-holes (in -Wdefault)]
    • Found hole: _ :: Integer -> [Integer] -> Integer
    • In the expression: _
      In the expression: _ 0
      In an equation for ‘g’: g = _ 0
    • Relevant bindings include
        g :: [Integer] -> Integer
          (bound at abstract_refinement_hole_fits.hs:7:1)
      Valid hole fits include
        const :: forall a b. a -> b -> a
        return :: forall (m :: * -> *) a. Monad m => a -> m a
        pure :: forall (f :: * -> *) a. Applicative f => a -> f a
      Valid refinement hole fits include
        foldl (_ :: Integer -> Integer -> Integer)
          where foldl :: forall (t :: * -> *) b a.
                         Foldable t =>
                         (b -> a -> b) -> b -> t a -> b
        foldr (_ :: Integer -> Integer -> Integer)
          where foldr :: forall (t :: * -> *) a b.
                         Foldable t =>
                         (a -> b -> b) -> b -> t a -> b
        curry (_ :: (Integer, [Integer]) -> Integer)
          where curry :: forall a b c. ((a, b) -> c) -> a -> b -> c
        flip (_ :: [Integer] -> Integer -> Integer)
          where flip :: forall a b c. (a -> b -> c) -> b -> a -> c
        const (_ :: [Integer] -> Integer)
          where const :: forall a b. a -> b -> a
        ($) (_ :: Integer -> [Integer] -> Integer)
          where ($) :: forall a b. (a -> b) -> a -> b
        return (_ :: [Integer] -> Integer)
          where return :: forall (m :: * -> *) a. Monad m => a -> m a
        pure (_ :: [Integer] -> Integer)
          where pure :: forall (f :: * -> *) a. Applicative f => a -> f a
        ($!) (_ :: Integer -> [Integer] -> Integer)
          where ($!) :: forall a b. (a -> b) -> a -> b
        curry (_ :: (t0, Integer) -> [Integer] -> Integer) (_ :: t0)
          where curry :: forall a b c. ((a, b) -> c) -> a -> b -> c
        (.) (_ :: b1 -> [Integer] -> Integer) (_ :: Integer -> b1)
          where (.) :: forall b c a. (b -> c) -> (a -> b) -> a -> c
        flip (_ :: Integer -> t0 -> [Integer] -> Integer) (_ :: t0)
          where flip :: forall a b c. (a -> b -> c) -> b -> a -> c
        (>>=) (_ :: Integer -> a8)
              (_ :: a8 -> Integer -> [Integer] -> Integer)
          where (>>=) :: forall (m :: * -> *) a b.
                         Monad m =>
                         m a -> (a -> m b) -> m b
        (>>) (_ :: Integer -> a7) (_ :: Integer -> [Integer] -> Integer)
          where (>>) :: forall (m :: * -> *) a b.
                        Monad m =>
                        m a -> m b -> m b
        fmap (_ :: a9 -> [Integer] -> Integer) (_ :: Integer -> a9)
          where fmap :: forall (f :: * -> *) a b.
                        Functor f =>
                        (a -> b) -> f a -> f b
        (<*>) (_ :: Integer -> a5 -> [Integer] -> Integer)
              (_ :: Integer -> a5)
          where (<*>) :: forall (f :: * -> *) a b.
                         Applicative f =>
                         f (a -> b) -> f a -> f b
        (*>) (_ :: Integer -> a4) (_ :: Integer -> [Integer] -> Integer)
          where (*>) :: forall (f :: * -> *) a b.
                        Applicative f =>
                        f a -> f b -> f b
        (<$>) (_ :: a1 -> [Integer] -> Integer) (_ :: Integer -> a1)
          where (<$>) :: forall (f :: * -> *) a b.
                         Functor f =>
                         (a -> b) -> f a -> f b
        (=<<) (_ :: a6 -> Integer -> [Integer] -> Integer)
              (_ :: Integer -> a6)
          where (=<<) :: forall (m :: * -> *) a b.
                         Monad m =>
                         (a -> m b) -> m a -> m b
        (<*) (_ :: Integer -> [Integer] -> Integer) (_ :: Integer -> b5)
          where (<*) :: forall (f :: * -> *) a b.
                        Applicative f =>
                        f a -> f b -> f a
        (<$) (_ :: [Integer] -> Integer) (_ :: Integer -> b4)
          where (<$) :: forall (f :: * -> *) a b.
                        Functor f =>
                        a -> f b -> f a
        id (_ :: t0 -> Integer -> [Integer] -> Integer) (_ :: t0)
          where id :: forall a. a -> a
        head (_ :: [t0 -> Integer -> [Integer] -> Integer]) (_ :: t0)
          where head :: forall a. [a] -> a
        last (_ :: [t0 -> Integer -> [Integer] -> Integer]) (_ :: t0)
          where last :: forall a. [a] -> a
        fst (_ :: (t0 -> Integer -> [Integer] -> Integer, b2)) (_ :: t0)
          where fst :: forall a b. (a, b) -> a
        snd (_ :: (a2, t0 -> Integer -> [Integer] -> Integer)) (_ :: t0)
          where snd :: forall a b. (a, b) -> b
        id (_ :: Integer -> [Integer] -> Integer)
          where id :: forall a. a -> a
        head (_ :: [Integer -> [Integer] -> Integer])
          where head :: forall a. [a] -> a
        last (_ :: [Integer -> [Integer] -> Integer])
          where last :: forall a. [a] -> a
        asTypeOf (_ :: Integer -> [Integer] -> Integer)
                 (_ :: Integer -> [Integer] -> Integer)
          where asTypeOf :: forall a. a -> a -> a
        (!!) (_ :: [Integer -> [Integer] -> Integer]) (_ :: Int)
          where (!!) :: forall a. [a] -> Int -> a
        fst (_ :: (Integer -> [Integer] -> Integer, b0))
          where fst :: forall a b. (a, b) -> a
        snd (_ :: (a0, Integer -> [Integer] -> Integer))
          where snd :: forall a b. (a, b) -> b
        const (_ :: Integer -> [Integer] -> Integer) (_ :: t0)
          where const :: forall a b. a -> b -> a
        seq (_ :: t2) (_ :: Integer -> [Integer] -> Integer)
          where seq :: forall a b. a -> b -> b
        ($) (_ :: t0 -> Integer -> [Integer] -> Integer) (_ :: t0)
          where ($) :: forall a b. (a -> b) -> a -> b
        return (_ :: Integer -> [Integer] -> Integer) (_ :: t0)
          where return :: forall (m :: * -> *) a. Monad m => a -> m a
        pure (_ :: Integer -> [Integer] -> Integer) (_ :: t0)
          where pure :: forall (f :: * -> *) a. Applicative f => a -> f a
        uncurry (_ :: a3 -> b3 -> Integer -> [Integer] -> Integer)
                (_ :: (a3, b3))
          where uncurry :: forall a b c. (a -> b -> c) -> (a, b) -> c
        ($!) (_ :: t0 -> Integer -> [Integer] -> Integer) (_ :: t0)
          where ($!) :: forall a b. (a -> b) -> a -> b
