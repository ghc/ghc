# Top-level Makefile
#
# This file is still _TOO_ large (should be < 100L). There are too many moving
# _global_ parts, most of this should be relegated to the respective packages.
# The whole version replacement therapy is utterly ridiculous. It should be done
# in the respective packages.

SHELL := bash
.SHELLFLAGS := -eu -o pipefail -O globstar -c

ROOT_DIR := $(patsubst %/,%,$(dir $(realpath $(lastword $(MAKEFILE_LIST)))))

GHC0 ?= ghc-9.8.4
PYTHON ?= python3
CABAL ?= cabal

# :exploding-head: It turns out override doesn't override the command-line
# value but it overrides Make's normal behavior of ignoring assignments to
# command-line variables. This allows the += operations to append to whatever
# was passed from the command line.

override CABAL_ARGS += \
	--remote-repo-cache _build/packages \
	--store-dir=_build/$(STAGE)/store \
	--logs-dir=_build/$(STAGE)/logs

override CABAL_BUILD_ARGS += \
	-j -v -w $(GHC) --with-gcc=$(CC) \
	--project-file=cabal.project.$(STAGE) \
	--builddir=_build/$(STAGE)

# just some defaults
STAGE ?= stage1
GHC ?= $(GHC0)

CABAL_BUILD = $(CABAL) $(CABAL_ARGS) build $(CABAL_BUILD_ARGS)

GHC1 = _build/stage1/bin/ghc
GHC2 = _build/stage2/bin/ghc

define GHC_INFO
$(shell sh -c "$(GHC0) --info | $(GHC0) -e 'getContents >>= foldMap putStrLn . lookup \"$1\" . read'")
endef

TARGET_PLATFORM := $(call GHC_INFO,target platform string)
TARGET_ARCH     := $(call GHC_INFO,target arch)
TARGET_OS       := $(call GHC_INFO,target os)
TARGET_TRIPLE   := $(call GHC_INFO,Target platform)
GIT_COMMIT_ID   := $(shell git rev-parse HEAD)

define HADRIAN_SETTINGS
[ ("hostPlatformArch",    "$(TARGET_ARCH)") \
, ("hostPlatformOS",      "$(TARGET_OS)") \
, ("cProjectGitCommitId", "$(GIT_COMMIT_ID)") \
, ("cProjectVersion",     "9.13") \
, ("cProjectVersionInt",  "913") \
, ("cProjectPatchLevel",  "0") \
, ("cProjectPatchLevel1", "0") \
, ("cProjectPatchLevel2", "0") \
]
endef

define run_and_log
@set -e; \
LOGDIR=$(@D)/../logs; \
mkdir -p "$$LOGDIR"; \
STDOUT_LOG="$$LOGDIR/$(notdir $@).stdout.log"; \
STDERR_LOG="$$LOGDIR/$(notdir $@).stderr.log"; \
echo "+ $(1)"; \
( { $(1); } >"$$STDOUT_LOG" 2>"$$STDERR_LOG" ) || { \
  if [ -s "$$STDERR_LOG" ]; then \
    cat "$$STDERR_LOG"; \
    echo "See logs: $$STDERR_LOG (stderr), $$STDOUT_LOG (stdout)"; \
  elif [ -s "$$STDOUT_LOG" ]; then \
    cat "$$STDOUT_LOG"; \
    echo "See logs: $$STDERR_LOG (stderr), $$STDOUT_LOG (stdout)"; \
  fi; \
  exit 1; \
}
endef

# Handle CPUS and THREADS
CPUS_DETECT_SCRIPT := ./mk/detect-cpu-count.sh
CPUS := $(shell if [ -x $(CPUS_DETECT_SCRIPT) ]; then $(CPUS_DETECT_SCRIPT); else echo 2; fi)
THREADS ?= $(shell echo $$(( $(CPUS) + 1 )))

# Files that will be generated by config.status from their .in counterparts
# FIXME: This is stupid. Why do we patch versions across multiple libraries? Idiotic.
#        also, why on earth do we use a non standard SnakeCase convention for substitutions
#        when CAPITAL_CASE is the standard?
CONFIGURED_FILES := \
	ghc/ghc-bin.cabal \
	compiler/ghc.cabal \
	libraries/ghc-boot/ghc-boot.cabal \
	libraries/ghc-boot-th/ghc-boot-th.cabal \
	libraries/ghc-heap/ghc-heap.cabal \
	libraries/template-haskell/template-haskell.cabal \
	libraries/ghci/ghci.cabal \
	utils/ghc-pkg/ghc-pkg.cabal \
	utils/ghc-iserv/ghc-iserv.cabal \
	utils/runghc/runghc.cabal \
	libraries/ghc-internal/ghc-internal.cabal \
	libraries/ghc-experimental/ghc-experimental.cabal \
	libraries/base/base.cabal \
	rts/include/ghcversion.h

# --- Main Targets ---
all: _build/bindist # booted will depend on prepare-sources

STAGE_UTIL_TARGETS := \
	deriveConstants:deriveConstants \
	genapply:genapply \
	genprimopcode:genprimopcode \
	ghc-pkg:ghc-pkg \
	hsc2hs:hsc2hs \
	rts-headers:rts-headers \
	unlit:unlit

STAGE1_TARGETS := $(STAGE_UTIL_TARGETS) ghc-bin:ghc ghc-toolchain-bin:ghc-toolchain-bin

# TODO: dedup
STAGE1_EXECUTABLES := \
	deriveConstants \
	genapply \
	genprimopcode \
	ghc \
	ghc-pkg \
	ghc-toolchain-bin \
	hsc2hs \
	unlit

# We really want to work towards `cabal build/instsall ghc-bin:ghc`.
STAGE2_TARGETS := \
	ghc-bin:ghc

STAGE2_UTIL_TARGETS := \
	$(STAGE_UTIL_TARGETS) \
	ghc-iserv:ghc-iserv \
	rts:nonthreaded-debug \
	rts:nonthreaded-nodebug \
	hp2ps:hp2ps \
	hpc-bin:hpc \
	runghc:runghc \
	ghc-bignum:ghc-bignum \
	ghc-compact:ghc-compact \
	ghc-experimental:ghc-experimental \
	ghc-toolchain:ghc-toolchain \
	integer-gmp:integer-gmp \
	system-cxx-std-lib:system-cxx-std-lib \
	terminfo:terminfo \
	xhtml:xhtml

# These things should be built on demand.
# hp2ps:hp2ps \
# hpc-bin:hpc \
# ghc-iserv:ghc-iserv \
# runghc:runghc \

# This package is just utterly retarded
# I don't understand why this following line somehow breaks the build...
# STAGE2_TARGETS += system-cxx-std-lib:system-cxx-std-lib

# TODO: dedup
STAGE2_EXECUTABLES := \
	ghc

STAGE2_UTIL_EXECUTABLES := \
	deriveConstants \
	genapply \
	genprimopcode \
	hsc2hs \
	ghc-iserv \
	ghc-pkg \
	hp2ps \
	hpc \
	runghc \
	unlit

# export CABAL := $(shell cabal update 2>&1 >/dev/null && cabal build cabal-install -v0 --disable-tests --project-dir libraries/Cabal && cabal list-bin -v0 --project-dir libraries/Cabal cabal-install:exe:cabal)
$(abspath _build/stage0/bin/cabal): _build/stage0/bin/cabal

.PHONY: _build/stage0/bin/cabal
_build/stage0/bin/cabal:
	@echo ">>> Building Cabal..."
	@mkdir -p _build/stage0/bin _build/logs
	$(call run_and_log, cabal build -j -w $(GHC0) --disable-tests --project-dir libraries/Cabal --builddir=_build/stage0/cabal cabal-install:exe:cabal)
	cp -rfp $(shell cabal list-bin -v0 -j -w $(GHC0) --project-dir libraries/Cabal --builddir=_build/stage0/cabal cabal-install:exe:cabal) _build/stage0/bin/cabal
	@echo ">>> Cabal built successfully."

# --- Stage 1 build ---

_build/stage1/%: private STAGE=stage1
_build/stage1/%: private GHC=$(GHC0)

.PHONY: $(addprefix _build/stage1/bin/,$(STAGE1_EXECUTABLES))
$(addprefix _build/stage1/bin/,$(STAGE1_EXECUTABLES)) &: $(CABAL) | _build/booted
	# Force cabal to replan
	rm -rf _build/stage2/cache
	$(call run_and_log, HADRIAN_SETTINGS='$(HADRIAN_SETTINGS)' \
		$(CABAL_BUILD) $(STAGE1_TARGETS))

_build/stage1/lib/settings: _build/stage1/bin/ghc-toolchain-bin
	@mkdir -p $(@D)
	$(call run_and_log, _build/stage1/bin/ghc-toolchain-bin --triple $(TARGET_TRIPLE) --output-settings -o $@ --cc $(CC) --cxx $(CXX))

_build/stage1/lib/package.conf.d/package.cache: _build/stage1/bin/ghc-pkg _build/stage1/lib/settings
	@mkdir -p _build/stage1/lib/package.conf.d
	@rm -rf _build/stage1/lib/package.conf.d/*
	cp -rfp _build/stage1/packagedb/host/*/* _build/stage1/lib/package.conf.d
	_build/stage1/bin/ghc-pkg recache

_build/stage1/lib/template-hsc.h: utils/hsc2hs/data/template-hsc.h
	@mkdir -p $(@D)
	cp -rfp $< $@

.PHONY: stage1
stage1: $(addprefix _build/stage1/bin/,$(STAGE1_EXECUTABLES)) _build/stage1/lib/settings _build/stage1/lib/package.conf.d/package.cache _build/stage1/lib/template-hsc.h

# --- Stage 2 build ---

_build/stage2/%: private STAGE=stage2
_build/stage2/%: private GHC=$(realpath _build/stage1/bin/ghc)

.PHONY: $(addprefix _build/stage2/bin/,$(STAGE2_EXECUTABLES))
$(addprefix _build/stage2/bin/,$(STAGE2_EXECUTABLES)) &: $(CABAL) stage1
	# Force cabal to replan
	rm -rf _build/stage2/cache
	$(call run_and_log, HADRIAN_SETTINGS='$(HADRIAN_SETTINGS)' \
		PATH=$(PWD)/_build/stage1/bin:$(PATH) \
		$(CABAL_BUILD) --ghc-options="-ghcversion-file=$(abspath ./rts/include/ghcversion.h)" -W $(GHC0) $(STAGE2_TARGETS) )

# Do we want to build these with the stage2 GHC or the stage1 GHC?
# Traditionally we build them with the stage1 ghc, but we could just as well
# build them with the stage2 ghc; seems like a better/cleaner idea to me (moritz).
.PHONY: $(addprefix _build/stage2/bin/,$(STAGE2_UTIL_EXECUTABLES))
$(addprefix _build/stage2/bin/,$(STAGE2_UTIL_EXECUTABLES)) &: $(CABAL) stage1
	# Force cabal to replan
	rm -rf _build/stage2/cache
	$(call run_and_log, HADRIAN_SETTINGS='$(HADRIAN_SETTINGS)' \
		PATH=$(PWD)/_build/stage1/bin:$(PATH) \
		$(CABAL_BUILD) --ghc-options="-ghcversion-file=$(abspath ./rts/include/ghcversion.h)" -W $(GHC0) $(STAGE2_UTIL_TARGETS) )


# # We use PATH=... here to ensure all the build-tool-depends (deriveConstants, genapply, genprimopcode, ...) are
# # available in PATH while cabal evaluates configure files. Cabal sadly does not support build-tool-depends or
# # handle build-depends properly prior to building the package.  Thus Configure/Setup/... do not have build-tool-depends
# # available in PATH.  This is a workaround for that.  I consider this a defect in cabal.
# _build/stage2/bin/ghc: _build/stage1.done
# 	@$(LIB)
# 	@echo ">>> Building with GHC: $(GHC1) and Cabal: $(CABAL)"
# 	@echo ">>> Using $(THREADS) threads"

# 	# this is stupid, having to build the rts first. We need to find a better way to do this.
# 	# We might be able to just have the `ghc` executable depend on the specific rts we want to
# 	# set as a default.
# 	HADRIAN_SETTINGS='$(HADRIAN_SETTINGS)' \
# 		PATH=$(PWD)/_build/stage1/bin:$(PATH) \
# 		$(CABAL) $(CABAL_ARGS) build --project-file=cabal.project.stage2 --builddir=_build/stage2/cabal -j -w ghc \
# 		$(CABAL_BUILD_ARGS) \
# 		--ghc-options="-ghcversion-file=$(abspath ./rts/include/ghcversion.h)" \
# 		rts:nonthreaded-nodebug rts:nonthreaded-debug \
# 		|& tee _build/logs/rts.log

# 	HADRIAN_SETTINGS='$(HADRIAN_SETTINGS)' \
# 		PATH=$(PWD)/_build/stage1/bin:$(PATH) \
# 		$(CABAL) $(CABAL_ARGS) build --project-file=cabal.project.stage2 --builddir=_build/stage2/cabal -j -w ghc \
# 		$(CABAL_BUILD_ARGS) \
# 		--ghc-options="-ghcversion-file=$(abspath ./rts/include/ghcversion.h)" \
# 		$(STAGE2_TARGETS) \
# 		|& tee _build/logs/stage2.log

_build/stage2/lib/settings: _build/stage1/lib/settings
	@mkdir -p $(@D)
	cp -rfp _build/stage1/lib/settings _build/stage2/lib/settings

_build/stage2/lib/package.conf.d/package.cache: _build/stage2/bin/ghc-pkg _build/stage2/lib/settings
	@mkdir -p _build/stage2/lib/package.conf.d
	@rm -rf _build/stage2/lib/package.conf.d/*
	cp -rfp _build/stage2/packagedb/host/*/* _build/stage2/lib/package.conf.d
	_build/stage2/bin/ghc-pkg recache

_build/stage2/lib/template-hsc.h: utils/hsc2hs/data/template-hsc.h
	@mkdir -p $(@D)
	cp -rfp $< $@

.PHONY: stage2
stage2: $(addprefix _build/stage2/bin/,$(STAGE2_EXECUTABLES)) _build/stage2/lib/settings _build/stage2/lib/package.conf.d/package.cache _build/stage2/lib/template-hsc.h

# Target for creating the final binary distribution directory
_build/bindist: stage2 driver/ghc-usage.txt driver/ghci-usage.txt
	@echo "Creating binary distribution in _build/bindist"
	@mkdir -p _build/bindist/bin
	@mkdir -p _build/bindist/lib
	# Copy executables from stage2 bin
	@cp -rfp _build/stage2/bin/* _build/bindist/bin/
	# Copy libraries and settings from stage2 lib
	@cp -rfp _build/stage2/lib/* _build/bindist/lib/
	# Copy driver usage files
	@cp -rfp driver/ghc-usage.txt _build/bindist/lib/
	@cp -rfp driver/ghci-usage.txt _build/bindist/lib/
	@echo "FIXME: Changing 'Support SMP' from YES to NO in settings file"
	@sed 's/("Support SMP","YES")/("Support SMP","NO")/' -i.bck _build/bindist/lib/settings
	@echo "Binary distribution created."

# --- Configuration ---

$(GHC1) $(GHC2): | hackage
hackage: _build/packages/hackage.haskell.org/01-index.tar.gz
_build/packages/hackage.haskell.org/01-index.tar.gz: | $(CABAL)
	@mkdir -p $(@D)
	$(CABAL) $(CABAL_ARGS) update --index-state 2025-04-22T01:25:40Z

# booted depends on successful source preparation
_build/booted:
	@echo ">>> Running ./boot script..."
	@mkdir -p _build/logs
	./boot |& tee _build/logs/boot.log
	@echo ">>> Running ./configure script..."
	$(call run_and_log, ./configure)
	touch $@

# --- Clean Targets ---
clean:
	@echo ">>> Cleaning build artifacts..."
	rm -rf _build
	@echo ">>> Build artifacts cleaned."

clean-stage1:
	@echo ">>> Cleaning stage1 build artifacts..."
	rm -rf _build/stage1
	@echo ">>> Stage1 build artifacts cleaned."

clean-stage2:
	@echo ">>> Cleaning stage2 build artifacts..."
	rm -rf _build/stage2
	@echo ">>> Stage2 build artifacts cleaned."

distclean: clean
	@echo ">>> Cleaning all generated files (distclean)..."
	rm -rf autom4te.cache
	rm -f config.status config.log config.h configure aclocal.m4
	rm -rf build-aux/config.guess build-aux/config.sub build-aux/install-sh build-aux/missing build-aux/compile depcomp
	find . -name 'Makefile.in' -delete
	rm -f $(CONFIGURED_FILES)
	@echo ">>> All generated files cleaned."


# --- Test Target ---
test: _build/bindist
	@echo ">>> Running tests with THREADS=${THREADS}" >&2
	TEST_HC=`pwd`/_build/bindist/bin/ghc \
	TEST_CC=$(CC) \
	TEST_CXX=$(CXX) \
	METRICS_FILE=`pwd`/_build/test-perf.csv \
	SUMMARY_FILE=`pwd`/_build/test-summary.txt \
	JUNIT_FILE=`pwd`/_build/test-junit.xml \
	make -C testsuite/tests test THREADS=${THREADS}

# Inform Make that these are not actual files if they get deleted by other means
.PHONY: clean distclean test all configure
