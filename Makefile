# Top-level Makefile
#
# This file is still _TOO_ large (should be < 100L). There are too many moving
# _global_ parts, most of this should be relegated to the respective packages.
# The whole version replacement therapy is utterly ridiculous. It should be done
# in the respective packages.

GHC0 ?= ghc-9.8.4
PYTHON ?= python3
CABAL ?= cabal

GHC1 = _build/stage1/bin/ghc
GHC2 = _build/stage2/bin/ghc

define GHC_INFO
$(shell $(GHC0) --info | $(GHC0) -e 'getContents >>= foldMap putStrLn . lookup "$1" . read')
endef

define COPY_BIN # $1: cabal, $2: ghc, $3: stage, $4: target, $5: name
cp -rfp $(shell $1 list-bin --project-file=cabal.project.$3 -w $2 --builddir=_build/$3/cabal $4 -v0) _build/$3/bin/$5
endef

TARGET_PLATFORM := $(call GHC_INFO,target platform string)
TARGET_ARCH     := $(call GHC_INFO,target arch)
TARGET_OS       := $(call GHC_INFO,target os)
TARGET_TRIPLE   := $(call GHC_INFO,Target platform)
GIT_COMMIT_ID   := $(shell git rev-parse HEAD)

define HADRIAN_SETTINGS
[ ("hostPlatformArch",    "$(TARGET_ARCH)") \
, ("hostPlatformOS",      "$(TARGET_OS)") \
, ("cProjectGitCommitId", "$(GIT_COMMIT_ID)") \
, ("cProjectVersion",     "9.13") \
, ("cProjectVersionInt",  "913") \
, ("cProjectPatchLevel",  "0") \
, ("cProjectPatchLevel1", "0") \
, ("cProjectPatchLevel2", "0") \
]
endef

# Handle CPUS and THREADS
CPUS_DETECT_SCRIPT := ./mk/detect-cpu-count.sh
CPUS := $(shell if [ -x $(CPUS_DETECT_SCRIPT) ]; then $(CPUS_DETECT_SCRIPT); else echo 2; fi)
THREADS ?= $(shell echo $$(( $(CPUS) + 1 )))

# Files that will be generated by config.status from their .in counterparts
# FIXME: This is stupid. Why do we patch versions across multiple libraries? Idiotic.
#        also, why on earth do we use a non standard SnakeCase convention for substitutions
#        when CAPITAL_CASE is the standard?
CONFIGURED_FILES := \
	ghc/ghc-bin.cabal \
	compiler/ghc.cabal \
	libraries/ghc-boot/ghc-boot.cabal \
	libraries/ghc-boot-th/ghc-boot-th.cabal \
	libraries/ghc-heap/ghc-heap.cabal \
	libraries/template-haskell/template-haskell.cabal \
	libraries/ghci/ghci.cabal \
	utils/ghc-pkg/ghc-pkg.cabal \
	utils/iserv/iserv.cabal \
	utils/runghc/runghc.cabal \
	libraries/ghc-internal/ghc-internal.cabal \
	libraries/ghc-experimental/ghc-experimental.cabal \
	libraries/base/base.cabal \
	rts/include/ghcversion.h

# --- Main Targets ---
all: _build/bindist # booted will depend on prepare-sources

STAGE_TARGETS := rts-headers:rts-headers ghc-bin:ghc ghc-pkg:ghc-pkg genprimopcode:genprimopcode deriveConstants:deriveConstants genapply:genapply unlit:unlit hsc2hs:hsc2hs
STAGE1_TARGETS := $(STAGE_TARGETS) ghc-toolchain-bin:ghc-toolchain-bin
STAGE2_TARGETS := $(STAGE_TARGETS) hp2ps:hp2ps hpc-bin:hpc iserv:iserv runghc:runghc

# All these libraries are somehow needed by some tests :rolleyes: this seems to be needed occationally.
STAGE2_TARGETS += ghc-bignum:ghc-bignum ghc-compact:ghc-compact ghc-experimental:ghc-experimental integer-gmp:integer-gmp xhtml:xhtml terminfo:terminfo ghc-toolchain:ghc-toolchain system-cxx-std-lib:system-cxx-std-lib
# This package is just utterly retarded
# I don't understand why this following line somehow breaks the build...
# STAGE2_TARGETS += system-cxx-std-lib:system-cxx-std-lib

$(GHC1): _build/booted
	@echo ">>> Building with GHC: $(GHC0) and Cabal: $(CABAL)"
	@echo ">>> Using $(THREADS) threads"
	@mkdir -p _build/logs
	HADRIAN_SETTINGS='$(HADRIAN_SETTINGS)' \
		$(CABAL) build --project-file=cabal.project.stage1 --builddir=_build/stage1/cabal -j -w $(GHC0) \
		$(STAGE1_TARGETS) \
		> _build/logs/stage1.log 2> _build/logs/stage1.err

_build/stage1.done: $(GHC1)
	mkdir -p _build/stage1/{bin,lib}
	$(call COPY_BIN,$(CABAL),$(GHC0),stage1,ghc-bin:ghc,ghc)
	$(call COPY_BIN,$(CABAL),$(GHC0),stage1,ghc-pkg:ghc-pkg,ghc-pkg)
	$(call COPY_BIN,$(CABAL),$(GHC0),stage1,unlit:unlit,unlit)
	$(call COPY_BIN,$(CABAL),$(GHC0),stage1,hsc2hs:hsc2hs,hsc2hs)
	$(call COPY_BIN,$(CABAL),$(GHC0),stage1,deriveConstants:deriveConstants,deriveConstants)
	$(call COPY_BIN,$(CABAL),$(GHC0),stage1,genprimopcode:genprimopcode,genprimopcode)
	$(call COPY_BIN,$(CABAL),$(GHC0),stage1,genapply:genapply,genapply)
	$(call COPY_BIN,$(CABAL),$(GHC0),stage1,ghc-toolchain-bin:ghc-toolchain-bin,ghc-toolchain)

	cp -rfp utils/hsc2hs/data/template-hsc.h _build/stage1/lib/template-hsc.h

	_build/stage1/bin/ghc-toolchain --triple $(TARGET_TRIPLE) --output-settings -o _build/stage1/lib/settings --cc $(CC) --cxx $(CXX) > _build/logs/ghc-toolchain.log 2> _build/logs/ghc-toolchain.err

	rm -fR _build/stage1/lib/package.conf.d; ln -s $(abspath $(wildcard ./_build/stage1/cabal/packagedb/ghc-*)) _build/stage1/lib/package.conf.d
	_build/stage1/bin/ghc-pkg recache

# We use PATH=... here to ensure all the build-tool-depends (deriveConstants, genapply, genprimopcode, ...) are
# available in PATH while cabal evaluates configure files. Cabal sadly does not support build-tool-depends or
# handle build-depends properly prior to building the package.  Thus Configure/Setup/... do not have build-tool-depends
# available in PATH.  This is a workaround for that.  I consider this a defect in cabal.
$(GHC2): _build/stage1.done
	@$(LIB)
	@echo ">>> Building with GHC: $(GHC1) and Cabal: $(CABAL)"
	@echo ">>> Using $(THREADS) threads"

	# this is stupid, having to build the rts first. We need to find a better way to do this.
	# We might be able to just have the `ghc` executable depend on the specific rts we want to
	# set as a default.
	HADRIAN_SETTINGS='$(HADRIAN_SETTINGS)' \
		PATH=$(PWD)/_build/stage1/bin:$(PATH) \
		$(CABAL) build --project-file=cabal.project.stage2 --builddir=_build/stage2/cabal -j -w ghc \
		--ghc-options="-ghcversion-file=$(abspath ./rts/include/ghcversion.h)" \
		rts:nonthreaded-nodebug \
		> _build/logs/rts.log 2> _build/logs/rts.err

	HADRIAN_SETTINGS='$(HADRIAN_SETTINGS)' \
		PATH=$(PWD)/_build/stage1/bin:$(PATH) \
		$(CABAL) build --project-file=cabal.project.stage2 --builddir=_build/stage2/cabal -j -w ghc \
		--ghc-options="-ghcversion-file=$(abspath ./rts/include/ghcversion.h)" \
		$(STAGE2_TARGETS) \
		> _build/logs/stage2.log 2> _build/logs/stage2.err

_build/stage2.done: $(GHC2)
	mkdir -p _build/stage2/{bin,lib}
	$(call COPY_BIN,$(CABAL),$(GHC1),stage2,ghc-bin:ghc,ghc)
	$(call COPY_BIN,$(CABAL),$(GHC1),stage2,ghc-pkg:ghc-pkg,ghc-pkg)
	$(call COPY_BIN,$(CABAL),$(GHC1),stage2,unlit:unlit,unlit)
	$(call COPY_BIN,$(CABAL),$(GHC1),stage2,hsc2hs:hsc2hs,hsc2hs)
	$(call COPY_BIN,$(CABAL),$(GHC1),stage2,deriveConstants:deriveConstants,deriveConstants)
	$(call COPY_BIN,$(CABAL),$(GHC1),stage2,genprimopcode:genprimopcode,genprimopcode)
	$(call COPY_BIN,$(CABAL),$(GHC1),stage2,genapply:genapply,genapply)
	$(call COPY_BIN,$(CABAL),$(GHC1),stage2,hp2ps:hp2ps,hp2ps)
	$(call COPY_BIN,$(CABAL),$(GHC1),stage2,hpc-bin:hpc,hpc)
	$(call COPY_BIN,$(CABAL),$(GHC1),stage2,runghc:runghc,runghc)
	$(call COPY_BIN,$(CABAL),$(GHC1),stage2,iserv:iserv,ghc-iserv)

	cp -rfp utils/hsc2hs/data/template-hsc.h _build/stage2/lib/template-hsc.h

	cp -rfp _build/stage1/lib/settings _build/stage2/lib/settings

	rm -fR _build/stage2/lib/package.conf.d; ln -s $(abspath $(wildcard ./_build/stage2/cabal/packagedb/ghc-*)) _build/stage2/lib/package.conf.d
	_build/stage2/bin/ghc-pkg recache

# Target for creating the final binary distribution directory
_build/bindist: _build/stage2.done driver/ghc-usage.txt driver/ghci-usage.txt
	@echo "Creating binary distribution in _build/bindist"
	@mkdir -p _build/bindist/bin
	@mkdir -p _build/bindist/lib
	# Copy executables from stage2 bin
	@cp -rfp _build/stage2/bin/* _build/bindist/bin/
	# Copy libraries and settings from stage2 lib
	@cp -rfp _build/stage2/lib/* _build/bindist/lib/
	# Copy driver usage files
	@cp -rfp driver/ghc-usage.txt _build/bindist/lib/
	@cp -rfp driver/ghci-usage.txt _build/bindist/lib/
	@echo "FIXME: swpaaing Support SMP from YES to NO in settings file"
	@sed 's/("Support SMP","YES")/("Support SMP","NO")/' -i.bck _build/bindist/lib/settings
	@echo "Binary distribution created."
# --- Configuration ---

# booted depends on successful source preparation
_build/booted:
	@echo ">>> Running ./boot script..."
	@mkdir -p _build/logs
	./boot > _build/logs/boot.log 2> _build/logs/boot.err
	touch $@

# --- Clean Targets ---
clean:
	@echo ">>> Cleaning build artifacts..."
	rm -rf _build
	@echo ">>> Build artifacts cleaned."

distclean: clean
	@echo ">>> Cleaning all generated files (distclean)..."
	rm -rf autom4te.cache
	rm -f config.status config.log config.h configure aclocal.m4
	rm -rf build-aux/config.guess build-aux/config.sub build-aux/install-sh build-aux/missing build-aux/compile depcomp
	find . -name 'Makefile.in' -delete
	rm -f $(CONFIGURED_FILES)
	@echo ">>> All generated files cleaned."


# --- Test Target ---
test: _build/bindist
	@echo ">>> Running tests with THREADS=${THREADS}" >&2
	TEST_HC=`pwd`/_build/bindist/bin/ghc \
	METRICS_FILE=`pwd`/_build/test-perf.csv \
	SUMMARY_FILE=`pwd`/_build/test-summary.txt \
	JUNIT_FILE=`pwd`/_build/test-junit.xml \
	make -C testsuite/tests test THREADS=${THREADS}

# Inform Make that these are not actual files if they get deleted by other means
.PHONY: clean distclean test all configure
