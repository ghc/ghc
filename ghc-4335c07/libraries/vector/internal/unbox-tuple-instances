#ifdef DEFINE_INSTANCES
data instance MVector s (a, b)
    = MV_2 {-# UNPACK #-} !Int !(MVector s a)
                               !(MVector s b)
data instance Vector (a, b)
    = V_2 {-# UNPACK #-} !Int !(Vector a)
                              !(Vector b)
instance (Unbox a, Unbox b) => Unbox (a, b)
instance (Unbox a, Unbox b) => M.MVector MVector (a, b) where
  {-# INLINE basicLength  #-}
  basicLength (MV_2 n_ _ _) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice i_ m_ (MV_2 _ as bs)
      = MV_2 m_ (M.basicUnsafeSlice i_ m_ as)
                (M.basicUnsafeSlice i_ m_ bs)
  {-# INLINE basicOverlaps  #-}
  basicOverlaps (MV_2 _ as1 bs1) (MV_2 _ as2 bs2)
      = M.basicOverlaps as1 as2
        || M.basicOverlaps bs1 bs2
  {-# INLINE basicUnsafeNew  #-}
  basicUnsafeNew n_
      = do
          as <- M.basicUnsafeNew n_
          bs <- M.basicUnsafeNew n_
          return $ MV_2 n_ as bs
  {-# INLINE basicInitialize  #-}
  basicInitialize (MV_2 _ as bs)
      = do
          M.basicInitialize as
          M.basicInitialize bs
  {-# INLINE basicUnsafeReplicate  #-}
  basicUnsafeReplicate n_ (a, b)
      = do
          as <- M.basicUnsafeReplicate n_ a
          bs <- M.basicUnsafeReplicate n_ b
          return $ MV_2 n_ as bs
  {-# INLINE basicUnsafeRead  #-}
  basicUnsafeRead (MV_2 _ as bs) i_
      = do
          a <- M.basicUnsafeRead as i_
          b <- M.basicUnsafeRead bs i_
          return (a, b)
  {-# INLINE basicUnsafeWrite  #-}
  basicUnsafeWrite (MV_2 _ as bs) i_ (a, b)
      = do
          M.basicUnsafeWrite as i_ a
          M.basicUnsafeWrite bs i_ b
  {-# INLINE basicClear  #-}
  basicClear (MV_2 _ as bs)
      = do
          M.basicClear as
          M.basicClear bs
  {-# INLINE basicSet  #-}
  basicSet (MV_2 _ as bs) (a, b)
      = do
          M.basicSet as a
          M.basicSet bs b
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_2 _ as1 bs1) (MV_2 _ as2 bs2)
      = do
          M.basicUnsafeCopy as1 as2
          M.basicUnsafeCopy bs1 bs2
  {-# INLINE basicUnsafeMove  #-}
  basicUnsafeMove (MV_2 _ as1 bs1) (MV_2 _ as2 bs2)
      = do
          M.basicUnsafeMove as1 as2
          M.basicUnsafeMove bs1 bs2
  {-# INLINE basicUnsafeGrow  #-}
  basicUnsafeGrow (MV_2 n_ as bs) m_
      = do
          as' <- M.basicUnsafeGrow as m_
          bs' <- M.basicUnsafeGrow bs m_
          return $ MV_2 (m_+n_) as' bs'
instance (Unbox a, Unbox b) => G.Vector Vector (a, b) where
  {-# INLINE basicUnsafeFreeze  #-}
  basicUnsafeFreeze (MV_2 n_ as bs)
      = do
          as' <- G.basicUnsafeFreeze as
          bs' <- G.basicUnsafeFreeze bs
          return $ V_2 n_ as' bs'
  {-# INLINE basicUnsafeThaw  #-}
  basicUnsafeThaw (V_2 n_ as bs)
      = do
          as' <- G.basicUnsafeThaw as
          bs' <- G.basicUnsafeThaw bs
          return $ MV_2 n_ as' bs'
  {-# INLINE basicLength  #-}
  basicLength (V_2 n_ _ _) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice i_ m_ (V_2 _ as bs)
      = V_2 m_ (G.basicUnsafeSlice i_ m_ as)
               (G.basicUnsafeSlice i_ m_ bs)
  {-# INLINE basicUnsafeIndexM  #-}
  basicUnsafeIndexM (V_2 _ as bs) i_
      = do
          a <- G.basicUnsafeIndexM as i_
          b <- G.basicUnsafeIndexM bs i_
          return (a, b)
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_2 _ as1 bs1) (V_2 _ as2 bs2)
      = do
          G.basicUnsafeCopy as1 as2
          G.basicUnsafeCopy bs1 bs2
  {-# INLINE elemseq  #-}
  elemseq _ (a, b)
      = G.elemseq (undefined :: Vector a) a
        . G.elemseq (undefined :: Vector b) b
#endif
#ifdef DEFINE_MUTABLE
-- | /O(1)/ Zip 2 vectors
zip :: (Unbox a, Unbox b) => MVector s a ->
                             MVector s b -> MVector s (a, b)
{-# INLINE_FUSED zip #-}
zip as bs = MV_2 len (unsafeSlice 0 len as) (unsafeSlice 0 len bs)
  where len = length as `delayed_min` length bs
-- | /O(1)/ Unzip 2 vectors
unzip :: (Unbox a, Unbox b) => MVector s (a, b) -> (MVector s a,
                                                    MVector s b)
{-# INLINE unzip #-}
unzip (MV_2 _ as bs) = (as, bs)
#endif
#ifdef DEFINE_IMMUTABLE
-- | /O(1)/ Zip 2 vectors
zip :: (Unbox a, Unbox b) => Vector a -> Vector b -> Vector (a, b)
{-# INLINE_FUSED zip #-}
zip as bs = V_2 len (unsafeSlice 0 len as) (unsafeSlice 0 len bs)
  where len = length as `delayed_min` length bs
{-# RULES "stream/zip [Vector.Unboxed]" forall as bs .
  G.stream (zip as bs) = Bundle.zipWith (,) (G.stream as)
                                            (G.stream bs)   #-}

-- | /O(1)/ Unzip 2 vectors
unzip :: (Unbox a, Unbox b) => Vector (a, b) -> (Vector a,
                                                 Vector b)
{-# INLINE unzip #-}
unzip (V_2 _ as bs) = (as, bs)
#endif
#ifdef DEFINE_INSTANCES
data instance MVector s (a, b, c)
    = MV_3 {-# UNPACK #-} !Int !(MVector s a)
                               !(MVector s b)
                               !(MVector s c)
data instance Vector (a, b, c)
    = V_3 {-# UNPACK #-} !Int !(Vector a)
                              !(Vector b)
                              !(Vector c)
instance (Unbox a, Unbox b, Unbox c) => Unbox (a, b, c)
instance (Unbox a,
          Unbox b,
          Unbox c) => M.MVector MVector (a, b, c) where
  {-# INLINE basicLength  #-}
  basicLength (MV_3 n_ _ _ _) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice i_ m_ (MV_3 _ as bs cs)
      = MV_3 m_ (M.basicUnsafeSlice i_ m_ as)
                (M.basicUnsafeSlice i_ m_ bs)
                (M.basicUnsafeSlice i_ m_ cs)
  {-# INLINE basicOverlaps  #-}
  basicOverlaps (MV_3 _ as1 bs1 cs1) (MV_3 _ as2 bs2 cs2)
      = M.basicOverlaps as1 as2
        || M.basicOverlaps bs1 bs2
        || M.basicOverlaps cs1 cs2
  {-# INLINE basicUnsafeNew  #-}
  basicUnsafeNew n_
      = do
          as <- M.basicUnsafeNew n_
          bs <- M.basicUnsafeNew n_
          cs <- M.basicUnsafeNew n_
          return $ MV_3 n_ as bs cs
  {-# INLINE basicInitialize #-}
  basicInitialize (MV_3 _ as bs cs)
      = do
          M.basicInitialize as
          M.basicInitialize bs
          M.basicInitialize cs
  {-# INLINE basicUnsafeReplicate  #-}
  basicUnsafeReplicate n_ (a, b, c)
      = do
          as <- M.basicUnsafeReplicate n_ a
          bs <- M.basicUnsafeReplicate n_ b
          cs <- M.basicUnsafeReplicate n_ c
          return $ MV_3 n_ as bs cs
  {-# INLINE basicUnsafeRead  #-}
  basicUnsafeRead (MV_3 _ as bs cs) i_
      = do
          a <- M.basicUnsafeRead as i_
          b <- M.basicUnsafeRead bs i_
          c <- M.basicUnsafeRead cs i_
          return (a, b, c)
  {-# INLINE basicUnsafeWrite  #-}
  basicUnsafeWrite (MV_3 _ as bs cs) i_ (a, b, c)
      = do
          M.basicUnsafeWrite as i_ a
          M.basicUnsafeWrite bs i_ b
          M.basicUnsafeWrite cs i_ c
  {-# INLINE basicClear  #-}
  basicClear (MV_3 _ as bs cs)
      = do
          M.basicClear as
          M.basicClear bs
          M.basicClear cs
  {-# INLINE basicSet  #-}
  basicSet (MV_3 _ as bs cs) (a, b, c)
      = do
          M.basicSet as a
          M.basicSet bs b
          M.basicSet cs c
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_3 _ as1 bs1 cs1) (MV_3 _ as2 bs2 cs2)
      = do
          M.basicUnsafeCopy as1 as2
          M.basicUnsafeCopy bs1 bs2
          M.basicUnsafeCopy cs1 cs2
  {-# INLINE basicUnsafeMove  #-}
  basicUnsafeMove (MV_3 _ as1 bs1 cs1) (MV_3 _ as2 bs2 cs2)
      = do
          M.basicUnsafeMove as1 as2
          M.basicUnsafeMove bs1 bs2
          M.basicUnsafeMove cs1 cs2
  {-# INLINE basicUnsafeGrow  #-}
  basicUnsafeGrow (MV_3 n_ as bs cs) m_
      = do
          as' <- M.basicUnsafeGrow as m_
          bs' <- M.basicUnsafeGrow bs m_
          cs' <- M.basicUnsafeGrow cs m_
          return $ MV_3 (m_+n_) as' bs' cs'
instance (Unbox a,
          Unbox b,
          Unbox c) => G.Vector Vector (a, b, c) where
  {-# INLINE basicUnsafeFreeze  #-}
  basicUnsafeFreeze (MV_3 n_ as bs cs)
      = do
          as' <- G.basicUnsafeFreeze as
          bs' <- G.basicUnsafeFreeze bs
          cs' <- G.basicUnsafeFreeze cs
          return $ V_3 n_ as' bs' cs'
  {-# INLINE basicUnsafeThaw  #-}
  basicUnsafeThaw (V_3 n_ as bs cs)
      = do
          as' <- G.basicUnsafeThaw as
          bs' <- G.basicUnsafeThaw bs
          cs' <- G.basicUnsafeThaw cs
          return $ MV_3 n_ as' bs' cs'
  {-# INLINE basicLength  #-}
  basicLength (V_3 n_ _ _ _) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice i_ m_ (V_3 _ as bs cs)
      = V_3 m_ (G.basicUnsafeSlice i_ m_ as)
               (G.basicUnsafeSlice i_ m_ bs)
               (G.basicUnsafeSlice i_ m_ cs)
  {-# INLINE basicUnsafeIndexM  #-}
  basicUnsafeIndexM (V_3 _ as bs cs) i_
      = do
          a <- G.basicUnsafeIndexM as i_
          b <- G.basicUnsafeIndexM bs i_
          c <- G.basicUnsafeIndexM cs i_
          return (a, b, c)
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_3 _ as1 bs1 cs1) (V_3 _ as2 bs2 cs2)
      = do
          G.basicUnsafeCopy as1 as2
          G.basicUnsafeCopy bs1 bs2
          G.basicUnsafeCopy cs1 cs2
  {-# INLINE elemseq  #-}
  elemseq _ (a, b, c)
      = G.elemseq (undefined :: Vector a) a
        . G.elemseq (undefined :: Vector b) b
        . G.elemseq (undefined :: Vector c) c
#endif
#ifdef DEFINE_MUTABLE
-- | /O(1)/ Zip 3 vectors
zip3 :: (Unbox a, Unbox b, Unbox c) => MVector s a ->
                                       MVector s b ->
                                       MVector s c -> MVector s (a, b, c)
{-# INLINE_FUSED zip3 #-}
zip3 as bs cs = MV_3 len (unsafeSlice 0 len as)
                         (unsafeSlice 0 len bs)
                         (unsafeSlice 0 len cs)
  where
    len = length as `delayed_min` length bs `delayed_min` length cs
-- | /O(1)/ Unzip 3 vectors
unzip3 :: (Unbox a,
           Unbox b,
           Unbox c) => MVector s (a, b, c) -> (MVector s a,
                                               MVector s b,
                                               MVector s c)
{-# INLINE unzip3 #-}
unzip3 (MV_3 _ as bs cs) = (as, bs, cs)
#endif
#ifdef DEFINE_IMMUTABLE
-- | /O(1)/ Zip 3 vectors
zip3 :: (Unbox a, Unbox b, Unbox c) => Vector a ->
                                       Vector b ->
                                       Vector c -> Vector (a, b, c)
{-# INLINE_FUSED zip3 #-}
zip3 as bs cs = V_3 len (unsafeSlice 0 len as)
                        (unsafeSlice 0 len bs)
                        (unsafeSlice 0 len cs)
  where
    len = length as `delayed_min` length bs `delayed_min` length cs
{-# RULES "stream/zip3 [Vector.Unboxed]" forall as bs cs .
  G.stream (zip3 as bs cs) = Bundle.zipWith3 (, ,) (G.stream as)
                                                   (G.stream bs)
                                                   (G.stream cs)   #-}

-- | /O(1)/ Unzip 3 vectors
unzip3 :: (Unbox a,
           Unbox b,
           Unbox c) => Vector (a, b, c) -> (Vector a, Vector b, Vector c)
{-# INLINE unzip3 #-}
unzip3 (V_3 _ as bs cs) = (as, bs, cs)
#endif
#ifdef DEFINE_INSTANCES
data instance MVector s (a, b, c, d)
    = MV_4 {-# UNPACK #-} !Int !(MVector s a)
                               !(MVector s b)
                               !(MVector s c)
                               !(MVector s d)
data instance Vector (a, b, c, d)
    = V_4 {-# UNPACK #-} !Int !(Vector a)
                              !(Vector b)
                              !(Vector c)
                              !(Vector d)
instance (Unbox a, Unbox b, Unbox c, Unbox d) => Unbox (a, b, c, d)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d) => M.MVector MVector (a, b, c, d) where
  {-# INLINE basicLength  #-}
  basicLength (MV_4 n_ _ _ _ _) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice i_ m_ (MV_4 _ as bs cs ds)
      = MV_4 m_ (M.basicUnsafeSlice i_ m_ as)
                (M.basicUnsafeSlice i_ m_ bs)
                (M.basicUnsafeSlice i_ m_ cs)
                (M.basicUnsafeSlice i_ m_ ds)
  {-# INLINE basicOverlaps  #-}
  basicOverlaps (MV_4 _ as1 bs1 cs1 ds1) (MV_4 _ as2 bs2 cs2 ds2)
      = M.basicOverlaps as1 as2
        || M.basicOverlaps bs1 bs2
        || M.basicOverlaps cs1 cs2
        || M.basicOverlaps ds1 ds2
  {-# INLINE basicUnsafeNew  #-}
  basicUnsafeNew n_
      = do
          as <- M.basicUnsafeNew n_
          bs <- M.basicUnsafeNew n_
          cs <- M.basicUnsafeNew n_
          ds <- M.basicUnsafeNew n_
          return $ MV_4 n_ as bs cs ds
  {-# INLINE basicInitialize #-}
  basicInitialize (MV_4 _ as bs cs ds)
      = do
          M.basicInitialize as
          M.basicInitialize bs
          M.basicInitialize cs
          M.basicInitialize ds
  {-# INLINE basicUnsafeReplicate  #-}
  basicUnsafeReplicate n_ (a, b, c, d)
      = do
          as <- M.basicUnsafeReplicate n_ a
          bs <- M.basicUnsafeReplicate n_ b
          cs <- M.basicUnsafeReplicate n_ c
          ds <- M.basicUnsafeReplicate n_ d
          return $ MV_4 n_ as bs cs ds
  {-# INLINE basicUnsafeRead  #-}
  basicUnsafeRead (MV_4 _ as bs cs ds) i_
      = do
          a <- M.basicUnsafeRead as i_
          b <- M.basicUnsafeRead bs i_
          c <- M.basicUnsafeRead cs i_
          d <- M.basicUnsafeRead ds i_
          return (a, b, c, d)
  {-# INLINE basicUnsafeWrite  #-}
  basicUnsafeWrite (MV_4 _ as bs cs ds) i_ (a, b, c, d)
      = do
          M.basicUnsafeWrite as i_ a
          M.basicUnsafeWrite bs i_ b
          M.basicUnsafeWrite cs i_ c
          M.basicUnsafeWrite ds i_ d
  {-# INLINE basicClear  #-}
  basicClear (MV_4 _ as bs cs ds)
      = do
          M.basicClear as
          M.basicClear bs
          M.basicClear cs
          M.basicClear ds
  {-# INLINE basicSet  #-}
  basicSet (MV_4 _ as bs cs ds) (a, b, c, d)
      = do
          M.basicSet as a
          M.basicSet bs b
          M.basicSet cs c
          M.basicSet ds d
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_4 _ as1 bs1 cs1 ds1) (MV_4 _ as2
                                                   bs2
                                                   cs2
                                                   ds2)
      = do
          M.basicUnsafeCopy as1 as2
          M.basicUnsafeCopy bs1 bs2
          M.basicUnsafeCopy cs1 cs2
          M.basicUnsafeCopy ds1 ds2
  {-# INLINE basicUnsafeMove  #-}
  basicUnsafeMove (MV_4 _ as1 bs1 cs1 ds1) (MV_4 _ as2
                                                   bs2
                                                   cs2
                                                   ds2)
      = do
          M.basicUnsafeMove as1 as2
          M.basicUnsafeMove bs1 bs2
          M.basicUnsafeMove cs1 cs2
          M.basicUnsafeMove ds1 ds2
  {-# INLINE basicUnsafeGrow  #-}
  basicUnsafeGrow (MV_4 n_ as bs cs ds) m_
      = do
          as' <- M.basicUnsafeGrow as m_
          bs' <- M.basicUnsafeGrow bs m_
          cs' <- M.basicUnsafeGrow cs m_
          ds' <- M.basicUnsafeGrow ds m_
          return $ MV_4 (m_+n_) as' bs' cs' ds'
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d) => G.Vector Vector (a, b, c, d) where
  {-# INLINE basicUnsafeFreeze  #-}
  basicUnsafeFreeze (MV_4 n_ as bs cs ds)
      = do
          as' <- G.basicUnsafeFreeze as
          bs' <- G.basicUnsafeFreeze bs
          cs' <- G.basicUnsafeFreeze cs
          ds' <- G.basicUnsafeFreeze ds
          return $ V_4 n_ as' bs' cs' ds'
  {-# INLINE basicUnsafeThaw  #-}
  basicUnsafeThaw (V_4 n_ as bs cs ds)
      = do
          as' <- G.basicUnsafeThaw as
          bs' <- G.basicUnsafeThaw bs
          cs' <- G.basicUnsafeThaw cs
          ds' <- G.basicUnsafeThaw ds
          return $ MV_4 n_ as' bs' cs' ds'
  {-# INLINE basicLength  #-}
  basicLength (V_4 n_ _ _ _ _) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice i_ m_ (V_4 _ as bs cs ds)
      = V_4 m_ (G.basicUnsafeSlice i_ m_ as)
               (G.basicUnsafeSlice i_ m_ bs)
               (G.basicUnsafeSlice i_ m_ cs)
               (G.basicUnsafeSlice i_ m_ ds)
  {-# INLINE basicUnsafeIndexM  #-}
  basicUnsafeIndexM (V_4 _ as bs cs ds) i_
      = do
          a <- G.basicUnsafeIndexM as i_
          b <- G.basicUnsafeIndexM bs i_
          c <- G.basicUnsafeIndexM cs i_
          d <- G.basicUnsafeIndexM ds i_
          return (a, b, c, d)
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_4 _ as1 bs1 cs1 ds1) (V_4 _ as2
                                                  bs2
                                                  cs2
                                                  ds2)
      = do
          G.basicUnsafeCopy as1 as2
          G.basicUnsafeCopy bs1 bs2
          G.basicUnsafeCopy cs1 cs2
          G.basicUnsafeCopy ds1 ds2
  {-# INLINE elemseq  #-}
  elemseq _ (a, b, c, d)
      = G.elemseq (undefined :: Vector a) a
        . G.elemseq (undefined :: Vector b) b
        . G.elemseq (undefined :: Vector c) c
        . G.elemseq (undefined :: Vector d) d
#endif
#ifdef DEFINE_MUTABLE
-- | /O(1)/ Zip 4 vectors
zip4 :: (Unbox a, Unbox b, Unbox c, Unbox d) => MVector s a ->
                                                MVector s b ->
                                                MVector s c ->
                                                MVector s d -> MVector s (a, b, c, d)
{-# INLINE_FUSED zip4 #-}
zip4 as bs cs ds = MV_4 len (unsafeSlice 0 len as)
                            (unsafeSlice 0 len bs)
                            (unsafeSlice 0 len cs)
                            (unsafeSlice 0 len ds)
  where
    len = length as `delayed_min`
          length bs `delayed_min`
          length cs `delayed_min`
          length ds
-- | /O(1)/ Unzip 4 vectors
unzip4 :: (Unbox a,
           Unbox b,
           Unbox c,
           Unbox d) => MVector s (a, b, c, d) -> (MVector s a,
                                                  MVector s b,
                                                  MVector s c,
                                                  MVector s d)
{-# INLINE unzip4 #-}
unzip4 (MV_4 _ as bs cs ds) = (as, bs, cs, ds)
#endif
#ifdef DEFINE_IMMUTABLE
-- | /O(1)/ Zip 4 vectors
zip4 :: (Unbox a, Unbox b, Unbox c, Unbox d) => Vector a ->
                                                Vector b ->
                                                Vector c ->
                                                Vector d -> Vector (a, b, c, d)
{-# INLINE_FUSED zip4 #-}
zip4 as bs cs ds = V_4 len (unsafeSlice 0 len as)
                           (unsafeSlice 0 len bs)
                           (unsafeSlice 0 len cs)
                           (unsafeSlice 0 len ds)
  where
    len = length as `delayed_min`
          length bs `delayed_min`
          length cs `delayed_min`
          length ds
{-# RULES "stream/zip4 [Vector.Unboxed]" forall as bs cs ds .
  G.stream (zip4 as bs cs ds) = Bundle.zipWith4 (, , ,) (G.stream as)
                                                        (G.stream bs)
                                                        (G.stream cs)
                                                        (G.stream ds)   #-}

-- | /O(1)/ Unzip 4 vectors
unzip4 :: (Unbox a,
           Unbox b,
           Unbox c,
           Unbox d) => Vector (a, b, c, d) -> (Vector a,
                                               Vector b,
                                               Vector c,
                                               Vector d)
{-# INLINE unzip4 #-}
unzip4 (V_4 _ as bs cs ds) = (as, bs, cs, ds)
#endif
#ifdef DEFINE_INSTANCES
data instance MVector s (a, b, c, d, e)
    = MV_5 {-# UNPACK #-} !Int !(MVector s a)
                               !(MVector s b)
                               !(MVector s c)
                               !(MVector s d)
                               !(MVector s e)
data instance Vector (a, b, c, d, e)
    = V_5 {-# UNPACK #-} !Int !(Vector a)
                              !(Vector b)
                              !(Vector c)
                              !(Vector d)
                              !(Vector e)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e) => Unbox (a, b, c, d, e)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e) => M.MVector MVector (a, b, c, d, e) where
  {-# INLINE basicLength  #-}
  basicLength (MV_5 n_ _ _ _ _ _) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice i_ m_ (MV_5 _ as bs cs ds es)
      = MV_5 m_ (M.basicUnsafeSlice i_ m_ as)
                (M.basicUnsafeSlice i_ m_ bs)
                (M.basicUnsafeSlice i_ m_ cs)
                (M.basicUnsafeSlice i_ m_ ds)
                (M.basicUnsafeSlice i_ m_ es)
  {-# INLINE basicOverlaps  #-}
  basicOverlaps (MV_5 _ as1 bs1 cs1 ds1 es1) (MV_5 _ as2
                                                     bs2
                                                     cs2
                                                     ds2
                                                     es2)
      = M.basicOverlaps as1 as2
        || M.basicOverlaps bs1 bs2
        || M.basicOverlaps cs1 cs2
        || M.basicOverlaps ds1 ds2
        || M.basicOverlaps es1 es2
  {-# INLINE basicUnsafeNew  #-}
  basicUnsafeNew n_
      = do
          as <- M.basicUnsafeNew n_
          bs <- M.basicUnsafeNew n_
          cs <- M.basicUnsafeNew n_
          ds <- M.basicUnsafeNew n_
          es <- M.basicUnsafeNew n_
          return $ MV_5 n_ as bs cs ds es
  {-# INLINE basicInitialize #-}
  basicInitialize (MV_5 _ as bs cs ds es)
      = do
          M.basicInitialize as
          M.basicInitialize bs
          M.basicInitialize cs
          M.basicInitialize ds
          M.basicInitialize es
  {-# INLINE basicUnsafeReplicate  #-}
  basicUnsafeReplicate n_ (a, b, c, d, e)
      = do
          as <- M.basicUnsafeReplicate n_ a
          bs <- M.basicUnsafeReplicate n_ b
          cs <- M.basicUnsafeReplicate n_ c
          ds <- M.basicUnsafeReplicate n_ d
          es <- M.basicUnsafeReplicate n_ e
          return $ MV_5 n_ as bs cs ds es
  {-# INLINE basicUnsafeRead  #-}
  basicUnsafeRead (MV_5 _ as bs cs ds es) i_
      = do
          a <- M.basicUnsafeRead as i_
          b <- M.basicUnsafeRead bs i_
          c <- M.basicUnsafeRead cs i_
          d <- M.basicUnsafeRead ds i_
          e <- M.basicUnsafeRead es i_
          return (a, b, c, d, e)
  {-# INLINE basicUnsafeWrite  #-}
  basicUnsafeWrite (MV_5 _ as bs cs ds es) i_ (a, b, c, d, e)
      = do
          M.basicUnsafeWrite as i_ a
          M.basicUnsafeWrite bs i_ b
          M.basicUnsafeWrite cs i_ c
          M.basicUnsafeWrite ds i_ d
          M.basicUnsafeWrite es i_ e
  {-# INLINE basicClear  #-}
  basicClear (MV_5 _ as bs cs ds es)
      = do
          M.basicClear as
          M.basicClear bs
          M.basicClear cs
          M.basicClear ds
          M.basicClear es
  {-# INLINE basicSet  #-}
  basicSet (MV_5 _ as bs cs ds es) (a, b, c, d, e)
      = do
          M.basicSet as a
          M.basicSet bs b
          M.basicSet cs c
          M.basicSet ds d
          M.basicSet es e
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_5 _ as1 bs1 cs1 ds1 es1) (MV_5 _ as2
                                                       bs2
                                                       cs2
                                                       ds2
                                                       es2)
      = do
          M.basicUnsafeCopy as1 as2
          M.basicUnsafeCopy bs1 bs2
          M.basicUnsafeCopy cs1 cs2
          M.basicUnsafeCopy ds1 ds2
          M.basicUnsafeCopy es1 es2
  {-# INLINE basicUnsafeMove  #-}
  basicUnsafeMove (MV_5 _ as1 bs1 cs1 ds1 es1) (MV_5 _ as2
                                                       bs2
                                                       cs2
                                                       ds2
                                                       es2)
      = do
          M.basicUnsafeMove as1 as2
          M.basicUnsafeMove bs1 bs2
          M.basicUnsafeMove cs1 cs2
          M.basicUnsafeMove ds1 ds2
          M.basicUnsafeMove es1 es2
  {-# INLINE basicUnsafeGrow  #-}
  basicUnsafeGrow (MV_5 n_ as bs cs ds es) m_
      = do
          as' <- M.basicUnsafeGrow as m_
          bs' <- M.basicUnsafeGrow bs m_
          cs' <- M.basicUnsafeGrow cs m_
          ds' <- M.basicUnsafeGrow ds m_
          es' <- M.basicUnsafeGrow es m_
          return $ MV_5 (m_+n_) as' bs' cs' ds' es'
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e) => G.Vector Vector (a, b, c, d, e) where
  {-# INLINE basicUnsafeFreeze  #-}
  basicUnsafeFreeze (MV_5 n_ as bs cs ds es)
      = do
          as' <- G.basicUnsafeFreeze as
          bs' <- G.basicUnsafeFreeze bs
          cs' <- G.basicUnsafeFreeze cs
          ds' <- G.basicUnsafeFreeze ds
          es' <- G.basicUnsafeFreeze es
          return $ V_5 n_ as' bs' cs' ds' es'
  {-# INLINE basicUnsafeThaw  #-}
  basicUnsafeThaw (V_5 n_ as bs cs ds es)
      = do
          as' <- G.basicUnsafeThaw as
          bs' <- G.basicUnsafeThaw bs
          cs' <- G.basicUnsafeThaw cs
          ds' <- G.basicUnsafeThaw ds
          es' <- G.basicUnsafeThaw es
          return $ MV_5 n_ as' bs' cs' ds' es'
  {-# INLINE basicLength  #-}
  basicLength (V_5 n_ _ _ _ _ _) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice i_ m_ (V_5 _ as bs cs ds es)
      = V_5 m_ (G.basicUnsafeSlice i_ m_ as)
               (G.basicUnsafeSlice i_ m_ bs)
               (G.basicUnsafeSlice i_ m_ cs)
               (G.basicUnsafeSlice i_ m_ ds)
               (G.basicUnsafeSlice i_ m_ es)
  {-# INLINE basicUnsafeIndexM  #-}
  basicUnsafeIndexM (V_5 _ as bs cs ds es) i_
      = do
          a <- G.basicUnsafeIndexM as i_
          b <- G.basicUnsafeIndexM bs i_
          c <- G.basicUnsafeIndexM cs i_
          d <- G.basicUnsafeIndexM ds i_
          e <- G.basicUnsafeIndexM es i_
          return (a, b, c, d, e)
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_5 _ as1 bs1 cs1 ds1 es1) (V_5 _ as2
                                                      bs2
                                                      cs2
                                                      ds2
                                                      es2)
      = do
          G.basicUnsafeCopy as1 as2
          G.basicUnsafeCopy bs1 bs2
          G.basicUnsafeCopy cs1 cs2
          G.basicUnsafeCopy ds1 ds2
          G.basicUnsafeCopy es1 es2
  {-# INLINE elemseq  #-}
  elemseq _ (a, b, c, d, e)
      = G.elemseq (undefined :: Vector a) a
        . G.elemseq (undefined :: Vector b) b
        . G.elemseq (undefined :: Vector c) c
        . G.elemseq (undefined :: Vector d) d
        . G.elemseq (undefined :: Vector e) e
#endif
#ifdef DEFINE_MUTABLE
-- | /O(1)/ Zip 5 vectors
zip5 :: (Unbox a,
         Unbox b,
         Unbox c,
         Unbox d,
         Unbox e) => MVector s a ->
                     MVector s b ->
                     MVector s c ->
                     MVector s d ->
                     MVector s e -> MVector s (a, b, c, d, e)
{-# INLINE_FUSED zip5 #-}
zip5 as bs cs ds es = MV_5 len (unsafeSlice 0 len as)
                               (unsafeSlice 0 len bs)
                               (unsafeSlice 0 len cs)
                               (unsafeSlice 0 len ds)
                               (unsafeSlice 0 len es)
  where
    len = length as `delayed_min`
          length bs `delayed_min`
          length cs `delayed_min`
          length ds `delayed_min`
          length es
-- | /O(1)/ Unzip 5 vectors
unzip5 :: (Unbox a,
           Unbox b,
           Unbox c,
           Unbox d,
           Unbox e) => MVector s (a, b, c, d, e) -> (MVector s a,
                                                     MVector s b,
                                                     MVector s c,
                                                     MVector s d,
                                                     MVector s e)
{-# INLINE unzip5 #-}
unzip5 (MV_5 _ as bs cs ds es) = (as, bs, cs, ds, es)
#endif
#ifdef DEFINE_IMMUTABLE
-- | /O(1)/ Zip 5 vectors
zip5 :: (Unbox a,
         Unbox b,
         Unbox c,
         Unbox d,
         Unbox e) => Vector a ->
                     Vector b ->
                     Vector c ->
                     Vector d ->
                     Vector e -> Vector (a, b, c, d, e)
{-# INLINE_FUSED zip5 #-}
zip5 as bs cs ds es = V_5 len (unsafeSlice 0 len as)
                              (unsafeSlice 0 len bs)
                              (unsafeSlice 0 len cs)
                              (unsafeSlice 0 len ds)
                              (unsafeSlice 0 len es)
  where
    len = length as `delayed_min`
          length bs `delayed_min`
          length cs `delayed_min`
          length ds `delayed_min`
          length es
{-# RULES "stream/zip5 [Vector.Unboxed]" forall as bs cs ds es .
  G.stream (zip5 as
                 bs
                 cs
                 ds
                 es) = Bundle.zipWith5 (, , , ,) (G.stream as)
                                                 (G.stream bs)
                                                 (G.stream cs)
                                                 (G.stream ds)
                                                 (G.stream es)   #-}

-- | /O(1)/ Unzip 5 vectors
unzip5 :: (Unbox a,
           Unbox b,
           Unbox c,
           Unbox d,
           Unbox e) => Vector (a, b, c, d, e) -> (Vector a,
                                                  Vector b,
                                                  Vector c,
                                                  Vector d,
                                                  Vector e)
{-# INLINE unzip5 #-}
unzip5 (V_5 _ as bs cs ds es) = (as, bs, cs, ds, es)
#endif
#ifdef DEFINE_INSTANCES
data instance MVector s (a, b, c, d, e, f)
    = MV_6 {-# UNPACK #-} !Int !(MVector s a)
                               !(MVector s b)
                               !(MVector s c)
                               !(MVector s d)
                               !(MVector s e)
                               !(MVector s f)
data instance Vector (a, b, c, d, e, f)
    = V_6 {-# UNPACK #-} !Int !(Vector a)
                              !(Vector b)
                              !(Vector c)
                              !(Vector d)
                              !(Vector e)
                              !(Vector f)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f) => Unbox (a, b, c, d, e, f)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f) => M.MVector MVector (a, b, c, d, e, f) where
  {-# INLINE basicLength  #-}
  basicLength (MV_6 n_ _ _ _ _ _ _) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice i_ m_ (MV_6 _ as bs cs ds es fs)
      = MV_6 m_ (M.basicUnsafeSlice i_ m_ as)
                (M.basicUnsafeSlice i_ m_ bs)
                (M.basicUnsafeSlice i_ m_ cs)
                (M.basicUnsafeSlice i_ m_ ds)
                (M.basicUnsafeSlice i_ m_ es)
                (M.basicUnsafeSlice i_ m_ fs)
  {-# INLINE basicOverlaps  #-}
  basicOverlaps (MV_6 _ as1 bs1 cs1 ds1 es1 fs1) (MV_6 _ as2
                                                         bs2
                                                         cs2
                                                         ds2
                                                         es2
                                                         fs2)
      = M.basicOverlaps as1 as2
        || M.basicOverlaps bs1 bs2
        || M.basicOverlaps cs1 cs2
        || M.basicOverlaps ds1 ds2
        || M.basicOverlaps es1 es2
        || M.basicOverlaps fs1 fs2
  {-# INLINE basicUnsafeNew  #-}
  basicUnsafeNew n_
      = do
          as <- M.basicUnsafeNew n_
          bs <- M.basicUnsafeNew n_
          cs <- M.basicUnsafeNew n_
          ds <- M.basicUnsafeNew n_
          es <- M.basicUnsafeNew n_
          fs <- M.basicUnsafeNew n_
          return $ MV_6 n_ as bs cs ds es fs
  {-# INLINE basicInitialize #-}
  basicInitialize (MV_6 _ as bs cs ds es fs)
      = do
          M.basicInitialize as
          M.basicInitialize bs
          M.basicInitialize cs
          M.basicInitialize ds
          M.basicInitialize es
          M.basicInitialize fs
  {-# INLINE basicUnsafeReplicate  #-}
  basicUnsafeReplicate n_ (a, b, c, d, e, f)
      = do
          as <- M.basicUnsafeReplicate n_ a
          bs <- M.basicUnsafeReplicate n_ b
          cs <- M.basicUnsafeReplicate n_ c
          ds <- M.basicUnsafeReplicate n_ d
          es <- M.basicUnsafeReplicate n_ e
          fs <- M.basicUnsafeReplicate n_ f
          return $ MV_6 n_ as bs cs ds es fs
  {-# INLINE basicUnsafeRead  #-}
  basicUnsafeRead (MV_6 _ as bs cs ds es fs) i_
      = do
          a <- M.basicUnsafeRead as i_
          b <- M.basicUnsafeRead bs i_
          c <- M.basicUnsafeRead cs i_
          d <- M.basicUnsafeRead ds i_
          e <- M.basicUnsafeRead es i_
          f <- M.basicUnsafeRead fs i_
          return (a, b, c, d, e, f)
  {-# INLINE basicUnsafeWrite  #-}
  basicUnsafeWrite (MV_6 _ as bs cs ds es fs) i_ (a, b, c, d, e, f)
      = do
          M.basicUnsafeWrite as i_ a
          M.basicUnsafeWrite bs i_ b
          M.basicUnsafeWrite cs i_ c
          M.basicUnsafeWrite ds i_ d
          M.basicUnsafeWrite es i_ e
          M.basicUnsafeWrite fs i_ f
  {-# INLINE basicClear  #-}
  basicClear (MV_6 _ as bs cs ds es fs)
      = do
          M.basicClear as
          M.basicClear bs
          M.basicClear cs
          M.basicClear ds
          M.basicClear es
          M.basicClear fs
  {-# INLINE basicSet  #-}
  basicSet (MV_6 _ as bs cs ds es fs) (a, b, c, d, e, f)
      = do
          M.basicSet as a
          M.basicSet bs b
          M.basicSet cs c
          M.basicSet ds d
          M.basicSet es e
          M.basicSet fs f
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_6 _ as1 bs1 cs1 ds1 es1 fs1) (MV_6 _ as2
                                                           bs2
                                                           cs2
                                                           ds2
                                                           es2
                                                           fs2)
      = do
          M.basicUnsafeCopy as1 as2
          M.basicUnsafeCopy bs1 bs2
          M.basicUnsafeCopy cs1 cs2
          M.basicUnsafeCopy ds1 ds2
          M.basicUnsafeCopy es1 es2
          M.basicUnsafeCopy fs1 fs2
  {-# INLINE basicUnsafeMove  #-}
  basicUnsafeMove (MV_6 _ as1 bs1 cs1 ds1 es1 fs1) (MV_6 _ as2
                                                           bs2
                                                           cs2
                                                           ds2
                                                           es2
                                                           fs2)
      = do
          M.basicUnsafeMove as1 as2
          M.basicUnsafeMove bs1 bs2
          M.basicUnsafeMove cs1 cs2
          M.basicUnsafeMove ds1 ds2
          M.basicUnsafeMove es1 es2
          M.basicUnsafeMove fs1 fs2
  {-# INLINE basicUnsafeGrow  #-}
  basicUnsafeGrow (MV_6 n_ as bs cs ds es fs) m_
      = do
          as' <- M.basicUnsafeGrow as m_
          bs' <- M.basicUnsafeGrow bs m_
          cs' <- M.basicUnsafeGrow cs m_
          ds' <- M.basicUnsafeGrow ds m_
          es' <- M.basicUnsafeGrow es m_
          fs' <- M.basicUnsafeGrow fs m_
          return $ MV_6 (m_+n_) as' bs' cs' ds' es' fs'
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f) => G.Vector Vector (a, b, c, d, e, f) where
  {-# INLINE basicUnsafeFreeze  #-}
  basicUnsafeFreeze (MV_6 n_ as bs cs ds es fs)
      = do
          as' <- G.basicUnsafeFreeze as
          bs' <- G.basicUnsafeFreeze bs
          cs' <- G.basicUnsafeFreeze cs
          ds' <- G.basicUnsafeFreeze ds
          es' <- G.basicUnsafeFreeze es
          fs' <- G.basicUnsafeFreeze fs
          return $ V_6 n_ as' bs' cs' ds' es' fs'
  {-# INLINE basicUnsafeThaw  #-}
  basicUnsafeThaw (V_6 n_ as bs cs ds es fs)
      = do
          as' <- G.basicUnsafeThaw as
          bs' <- G.basicUnsafeThaw bs
          cs' <- G.basicUnsafeThaw cs
          ds' <- G.basicUnsafeThaw ds
          es' <- G.basicUnsafeThaw es
          fs' <- G.basicUnsafeThaw fs
          return $ MV_6 n_ as' bs' cs' ds' es' fs'
  {-# INLINE basicLength  #-}
  basicLength (V_6 n_ _ _ _ _ _ _) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice i_ m_ (V_6 _ as bs cs ds es fs)
      = V_6 m_ (G.basicUnsafeSlice i_ m_ as)
               (G.basicUnsafeSlice i_ m_ bs)
               (G.basicUnsafeSlice i_ m_ cs)
               (G.basicUnsafeSlice i_ m_ ds)
               (G.basicUnsafeSlice i_ m_ es)
               (G.basicUnsafeSlice i_ m_ fs)
  {-# INLINE basicUnsafeIndexM  #-}
  basicUnsafeIndexM (V_6 _ as bs cs ds es fs) i_
      = do
          a <- G.basicUnsafeIndexM as i_
          b <- G.basicUnsafeIndexM bs i_
          c <- G.basicUnsafeIndexM cs i_
          d <- G.basicUnsafeIndexM ds i_
          e <- G.basicUnsafeIndexM es i_
          f <- G.basicUnsafeIndexM fs i_
          return (a, b, c, d, e, f)
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_6 _ as1 bs1 cs1 ds1 es1 fs1) (V_6 _ as2
                                                          bs2
                                                          cs2
                                                          ds2
                                                          es2
                                                          fs2)
      = do
          G.basicUnsafeCopy as1 as2
          G.basicUnsafeCopy bs1 bs2
          G.basicUnsafeCopy cs1 cs2
          G.basicUnsafeCopy ds1 ds2
          G.basicUnsafeCopy es1 es2
          G.basicUnsafeCopy fs1 fs2
  {-# INLINE elemseq  #-}
  elemseq _ (a, b, c, d, e, f)
      = G.elemseq (undefined :: Vector a) a
        . G.elemseq (undefined :: Vector b) b
        . G.elemseq (undefined :: Vector c) c
        . G.elemseq (undefined :: Vector d) d
        . G.elemseq (undefined :: Vector e) e
        . G.elemseq (undefined :: Vector f) f
#endif
#ifdef DEFINE_MUTABLE
-- | /O(1)/ Zip 6 vectors
zip6 :: (Unbox a,
         Unbox b,
         Unbox c,
         Unbox d,
         Unbox e,
         Unbox f) => MVector s a ->
                     MVector s b ->
                     MVector s c ->
                     MVector s d ->
                     MVector s e ->
                     MVector s f -> MVector s (a, b, c, d, e, f)
{-# INLINE_FUSED zip6 #-}
zip6 as bs cs ds es fs = MV_6 len (unsafeSlice 0 len as)
                                  (unsafeSlice 0 len bs)
                                  (unsafeSlice 0 len cs)
                                  (unsafeSlice 0 len ds)
                                  (unsafeSlice 0 len es)
                                  (unsafeSlice 0 len fs)
  where
    len = length as `delayed_min`
          length bs `delayed_min`
          length cs `delayed_min`
          length ds `delayed_min`
          length es `delayed_min`
          length fs
-- | /O(1)/ Unzip 6 vectors
unzip6 :: (Unbox a,
           Unbox b,
           Unbox c,
           Unbox d,
           Unbox e,
           Unbox f) => MVector s (a, b, c, d, e, f) -> (MVector s a,
                                                        MVector s b,
                                                        MVector s c,
                                                        MVector s d,
                                                        MVector s e,
                                                        MVector s f)
{-# INLINE unzip6 #-}
unzip6 (MV_6 _ as bs cs ds es fs) = (as, bs, cs, ds, es, fs)
#endif
#ifdef DEFINE_IMMUTABLE
-- | /O(1)/ Zip 6 vectors
zip6 :: (Unbox a,
         Unbox b,
         Unbox c,
         Unbox d,
         Unbox e,
         Unbox f) => Vector a ->
                     Vector b ->
                     Vector c ->
                     Vector d ->
                     Vector e ->
                     Vector f -> Vector (a, b, c, d, e, f)
{-# INLINE_FUSED zip6 #-}
zip6 as bs cs ds es fs = V_6 len (unsafeSlice 0 len as)
                                 (unsafeSlice 0 len bs)
                                 (unsafeSlice 0 len cs)
                                 (unsafeSlice 0 len ds)
                                 (unsafeSlice 0 len es)
                                 (unsafeSlice 0 len fs)
  where
    len = length as `delayed_min`
          length bs `delayed_min`
          length cs `delayed_min`
          length ds `delayed_min`
          length es `delayed_min`
          length fs
{-# RULES "stream/zip6 [Vector.Unboxed]" forall as bs cs ds es fs .
  G.stream (zip6 as
                 bs
                 cs
                 ds
                 es
                 fs) = Bundle.zipWith6 (, , , , ,) (G.stream as)
                                                   (G.stream bs)
                                                   (G.stream cs)
                                                   (G.stream ds)
                                                   (G.stream es)
                                                   (G.stream fs)   #-}

-- | /O(1)/ Unzip 6 vectors
unzip6 :: (Unbox a,
           Unbox b,
           Unbox c,
           Unbox d,
           Unbox e,
           Unbox f) => Vector (a, b, c, d, e, f) -> (Vector a,
                                                     Vector b,
                                                     Vector c,
                                                     Vector d,
                                                     Vector e,
                                                     Vector f)
{-# INLINE unzip6 #-}
unzip6 (V_6 _ as bs cs ds es fs) = (as, bs, cs, ds, es, fs)
#endif
